VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "SeqA"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_Description = "Seq is a multipurpose Collection/ArrayList replacement.  Items use 1 based indexing. ToArray returns Arrays with an Lbound of 1.  For a Keyed collection, use one of the Kvp classes"
'@PredeclaredId
'@Exposed
'@Folder("Seq")
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C

'@ModuleDescription("SeqA is a multipurpose Collection/ArrayList replacement.  It uses a one dimensional array to store the items.  Items are access using a single 1 based index. Multi dimensions addressing can be converted to linrear addressing using ArrayInfo.GetIndex. For a Keyed collection, use one of the Kvp classes")
' SeqA uses the VBA Collection class as a host for the items
' Other versions of SeqA are available (SeqA, SeqAL, SeqAH, SeqAT)

Option Explicit
'Implements SeqA

Private Const MY_TYPENAME                       As String = "SeqA"
Private Const DEFAULT_CHUNK                     As Long = 16&
Private Const FIRST_INDEX                       As Long = 1

Private Type State

   ' HostCopy                                    As variantudt
    Host()                                      As Variant ' an array
    LastIndex                                   As Long
    Size                                        As Long
    Tmp                                         As SeqA
    
End Type

Private s                                       As State

' Deb is a Factory method of the PredeclaredId which returns a new instance of SeqA
'=================================================================================
' The input for Deb is a ParamArray.
' The ParamArray is interpreted according to the folowing rules
' If the ParamArray contains no Items
' - A empty SeqAuence (count = 0)
' If the ParamArray has 2 or more items
' - A SeqA of size equal to the ParamArray, items as generated by for each over the ParamArray
' If the ParamArray has a single Item
' - Number: SeqA with specified capacity with each Item being the Value 'Empty'
' - String: A SeqA whose capacity is the length of the string with one character per Item
' - Array: SeqA of items as provided by For Each over the array.  Multidimension arrays are flattened but the position in the original array can be calculated by the user if required. See also Bind
' - Dictionaries: a SeqA of key/value arrays as generated from for each on the Keys array.
' - Collection: The collection is copied to the Host collection.  There is no refererence link to the original collection (See Host Property)
' - SeqA: Items as generated by for each on the SeqA
' - mscorlib Arraylist: Items as generated by for each on the arrylist
' - mscorlib Stack: Items as generated by for each on the stack
' - mscorlib Queue: Items as generated by for eac on the queue

'@DefaultMember
Public Function Deb(ParamArray ipParamArray() As Variant) As SeqA
Attribute Deb.VB_UserMemId = 0
    
    With New SeqA
        Set s.Tmp = .ConstructInstance
    End With
    
    ' the assignment to s.tmp is a kludge that allows the various
    ' Populate methods to operate on the new instance
    ' which greatly simplifies the populate methods at some processing cost.
    If ArrayInfo.LacksItems(VBA.CVar(ipParamArray)) Then
        Set Deb = s.Tmp
        Set s.Tmp = Nothing
        Exit Function
    End If
    
'    'do some preemptive checking and if we only have item(0) and it is an array
'    ' we need to do special memory copying to preseve the mutability of the external array
'    If ArrayInfo.Count(VBA.CVar(ipParamArray)) = 1 Then
'        If ArrayInfo.IsArray(ipParamArray(0)) Then
'
'            PopulateFromArray ipParamArray(0)
'            Set Deb = s.Tmp
'            Set s.Tmp = Nothing
'            Exit Function
'        End If
'
'    End If
        
    ' Now it is safe to resolve the paramarray if it only has a single item
    Dim myParam As Variant
    myParam = VBA.CVar(ipParamArray)
    Sys.ResolveParamArray myParam

    ' myParam may now be any type so we process in accordance with the rules stated above
    Dim myGroupId As e_Group
    myGroupId = GroupInfo.Id(myParam)
    

    Select Case myGroupId

        Case e_Group.m_Empty:               s.Tmp.Add myParam
        Case e_Group.m_Admin:               s.Tmp.Add myParam
        Case e_Group.m_number:              PopulateUsingInitialSize VBA.CLng(myParam)
        Case e_Group.m_string:              PopulateFromString VBA.CStr(myParam)
        Case e_Group.m_array:               PopulateUsingForEach myParam
        Case e_Group.m_List:                PopulateUsingForEach myParam
        Case e_Group.m_Dictionary:          PopulateFromDictionary myParam
        Case e_Group.m_Other:               s.Tmp.Add myParam
                  
    End Select

    Set Deb = s.Tmp
    Set s.Tmp = Nothing
    
End Function


Friend Function ConstructInstance() As SeqA
    s.LastIndex = 0
    s.Size = DEFAULT_CHUNK
    Resize
    Set ConstructInstance = Me
End Function

Private Sub PopulateFromArray(ByRef ipArray As Variant)

'do the memory juggery pokery here
End Sub


Private Sub PopulateUsingInitialSize(ByVal ipInitialSize As Long)
    
    GuardInsufficientCapacity ipInitialSize, "VBALib.SeqA.Deb"
    
    Dim myCount As Long
    For myCount = FIRST_INDEX To ipInitialSize
       s.Tmp.Add Empty
    Next

End Sub

Private Sub PopulateFromString(ByRef ipString As String)
    
    If VBA.Len(ipString) = 0 Then
        Exit Sub
    End If
    
    Dim myIndex As Long
    For myIndex = 1 To VBA.Len(ipString)
        s.Tmp.Add VBA.Mid$(ipString, myIndex, 1)
    Next
        
End Sub

Private Sub PopulateUsingForEach(ByVal ipForEach As Variant)
   
   Dim myLen As Long
   If VBA.IsArray(ipForEach) Then
        myLen = ArrayInfo.Count(ipForEach)
    Else
        myLen = ipForEach.Count
    End If
    
    If myLen <= 1 Then
        Exit Sub
    End If
    
    Dim myItem As Variant
    For Each myItem In ipForEach
      s.Tmp.Add myItem
    Next
 
End Sub

' A SeqA can be constructed using Dictionary.Keys or Dictionary.Items
' Consequently, if the single item in the paramarray is a Dictionary
' it is assumed that the sequence will be Key/Item pairs as single pair entities
' initially we will do this as an array
Private Sub PopulateFromDictionary(ByVal ipD As Variant)
    
    If ipD.Count = 0 Then
        Exit Sub
    End If

    Dim myKey As Variant
    For Each myKey In ipD.Keys
         s.Tmp.Add Array(myKey, ipD.Item(myKey))
    Next
   
End Sub

'' get and let host need some jiggery pokery as
'Public Property Get Host() As Collection
'    Set Host = s.Host
'End Property
'
'Public Property Set Host(ByVal ipCollection As Collection)
'    Set s.Host = ipCollection
'End Property
'@Description("allows and external array to be inserted into s.Host")
'ToDo: update BInd to do the necessary memorty copying jiggery pokery
Public Function Bind(ByRef ipArray As Variant) As SeqA
Attribute Bind.VB_Description = "allows and external array to be inserted into s.Host"
    
'    GuardExpectingArray ipArray, "VBALib.SeqA.Bind"
'
'    'ToDO: his code requires updating I think
'     ' make a copy of the content of s.host
'    CopyMemoryToAny ByVal VarPtr(s.HostCopy), ByVal VarPtr(s.Host), 16
'   ' transplant the structure of ipoATable to s.host
'    CopyMemoryToAny ByVal VarPtr(s.Host), ByVal VarPtr(ipArray.Cargo), 16
'
'    Set Bind = Me

End Function

Public Function Clone() As SeqA
    ReDim Preserve s.Host(1 To s.LastIndex)
    Set Clone = SeqA(s.Host)
End Function

'@Enumerator
Public Function NewEnum() As IUnknown
    Err.Raise 17 + vbObjectError, _
        "VBALib.SeqA.NewEnum", _
        "Not implemented for SeqA"
End Function

'ToDo: Update to necessary memory jiggery pokery
Private Sub Class_Terminate()

'    If s.HostCopy.VT = 0 Then
'        Exit Sub
'    Else
'        CopyMemByVal ByVal VarPtr(s.Host), ByVal VarPtr(s.HostCopy), 16
'    End If

End Sub


'@Description("Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer")
Public Function Count(Optional ByRef ipItem As Variant) As Long
Attribute Count.VB_Description = "Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer"

    If VBA.IsMissing(ipItem) Then
        Count = s.LastIndex
        Exit Function
    End If
    
    Dim myCount As Long
    myCount = 0
    
    Dim myIndex As Long
    For myIndex = 1 To s.LastIndex
        If ComparerHelpers.Equals(s.Host(myIndex), ipItem) Then
            myCount = myCount + 1
        End If
    Next
    
    Count = IIf(myCount = 0, -1, myCount)
    
End Function

Public Function Items() As Variant

    ReDim Preserve s.Host(1 To s.LastIndex)
    Items = s.Host
    
End Function

'@Description("Returns a subset of the SeqA")
Public Function Slice _
( _
    Optional ByRef ipStart As Long = 1, _
    Optional ByRef ipRun As Long = -1, _
    Optional ByRef ipStep As Long = 1 _
) As SeqA
Attribute Slice.VB_Description = "Returns a subset of the SeqA"
    
    If s.LastIndex = 0 Then
        Set Slice = SeqA.Deb
        Exit Function
    End If
    
    GuardIndexOutOfBounds ipStart, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Sice"
    
    Dim myRun As Long
    myRun = ipRun
    If myRun = -1 Then
        myRun = s.LastIndex - ipStart + 1
    Else
        GuardIndexOutOfBounds myRun + ipStart, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Sice"
    End If

    Dim myS As SeqA
    Set myS = SeqA.Deb
   
    Dim mySeqIndex As Long
    'Debug.Print ipStart + myRun - 1
    For mySeqIndex = ipStart To ipStart + myRun - 1 Step ipStep
        '@Ignore FunctionReturnValueDiscarded
        myS.Add s.Host(mySeqIndex)
    Next

    Set Slice = myS

End Function

'@Description("Returns a shallow copy of the SeqA as a VBA collection")
Public Function ToCollection() As Collection
Attribute ToCollection.VB_Description = "Returns a shallow copy of the SeqA as a VBA collection"
    
    Dim myC As Collection
    Set myC = New Collection
    
    Dim myIndex As Long
    For myIndex = FIRST_INDEX To s.LastIndex
        myC.Add s.Host(myIndex)
    Next
    
    Set ToCollection = myC
    
End Function

'@Description("Returns a shallow copy of the SeqA as an Array.  The Lbound of the array is 1")
Public Function ToArray() As Variant
Attribute ToArray.VB_Description = "Returns a shallow copy of the SeqA as an Array.  The Lbound of the array is 1"
    ReDim Preserve s.Host(FIRST_INDEX To s.LastIndex)
    ToArray = s.Host
End Function

'@Description("Returns the Host of the first Index")
Public Function FirstIndex() As Long
Attribute FirstIndex.VB_Description = "Returns the Host of the first Index"

    If s.LastIndex < FirstIndex Then
        FirstIndex = -1
    Else
        FirstIndex = FIRST_INDEX
    End If
    
End Function

'@Description("Returns the UBound of the SeqA or -1 if the SeqA is empty.  Equivalent to Count.")
Public Function LastIndex() As Long
Attribute LastIndex.VB_Description = "Returns the UBound of the SeqA or -1 if the SeqA is empty.  Equivalent to Count."

    If s.LastIndex < FIRST_INDEX Then
        LastIndex = -1
    Else
        LastIndex = s.LastIndex
    End If
   
End Function

'@Description("Returns the First but One index or error 9")
Public Function FBOIndex() As Long
Attribute FBOIndex.VB_Description = "Returns the First but One index or error 9"

    If FIRST_INDEX + 1 <= s.LastIndex Then
        FBOIndex = FirstIndex + 1
    Else
        FBOIndex = -1
    End If
    
End Function

 '@Description("Returns the last but One index or error 9")
Public Function LBOIndex() As Long
Attribute LBOIndex.VB_Description = "Returns the last but One index or error 9"
    If s.LastIndex - 1 >= FIRST_INDEX Then
        LBOIndex = s.LastIndex - 1
    Else
        LBOIndex = -1
    End If
End Function

Public Function TypeName() As String
    TypeName = MY_TYPENAME
End Function

'@Description("Add a single item.  Returns the index at which added.  For compatibility with ArrayList")
Public Function Add(ByRef ipItem As Variant) As Long
Attribute Add.VB_Description = "Add a single item.  Returns the index at which added.  For compatibility with ArrayList"

    Dim myIndex As Long
    myIndex = GetNextIndex

    If VBA.IsObject(ipItem) Then
        Set s.Host(myIndex) = ipItem
    Else
        s.Host(myIndex) = ipItem
    End If
    
    Add = myIndex
    
End Function


'@Description("Add Items in the paramarray to the  )
Public Function AddItems(ParamArray ipParamArray() As Variant) As SeqA

    If ArrayInfo.LacksItems(VBA.CVar(ipParamArray)) Then
        Set AddItems = Me
        Exit Function
    End If

    Dim myItem As Variant
    For Each myItem In ipParamArray
        If VBA.IsObject(myItem) Then
            Set s.Host(GetNextIndex) = myItem
        Else
            s.Host(GetNextIndex) = myItem
        End If
    Next

    Set AddItems = Me
    
End Function

'@Description("Add an array,  list type, dictionary type, or characters of a string")
Public Function AddRange(ByVal ipRange As Variant) As SeqA
Attribute AddRange.VB_Description = "Add an array,  list type, dictionary type, or characters of a string"

    Dim myGroupId As e_Group
    myGroupId = GroupInfo.Id(ipRange)
    GuardInvalidRangeObject myGroupId, ipRange, "VBALib.SeqA.AddRange"
    
    Select Case myGroupId
        Case e_Group.m_string:      AddRangeFromString VBA.CStr(ipRange)
        Case e_Group.m_array:       AddRangeUsingForEach ipRange
        Case e_Group.m_List:        AddRangeUsingForEach ipRange
        Case e_Group.m_Dictionary:  AddRangeFromDictionary ipRange
    End Select
    
    Set AddRange = Me

End Function

Private Sub AddRangeFromString(ByVal ipString As String)

    Dim myLen As Long
    myLen = VBA.Len(ipString)
    
    If myLen = 0 Then
        Exit Sub
    End If

    Dim myIndex As Long
    For myIndex = 1 To myLen
         s.Host(GetNextIndex) = VBA.Mid$(ipString, myIndex, 1)
    Next

End Sub

Private Sub AddRangeUsingForEach(ByVal ipForEach As Variant)

    If ArrayInfo.IsArray(ipForEach) Then
        If ArrayInfo.LacksItems(ipForEach) Then
            Exit Sub
        End If
    ElseIf ipForEach.Count < 1 Then
        Exit Sub
    End If
    
    Dim myItem As Variant
    For Each myItem In ipForEach
        If VBA.IsObject(myItem) Then
            Set s.Host(GetNextIndex) = myItem
        Else
           s.Host(GetNextIndex) = myItem
        End If
    Next

End Sub

Private Sub AddRangeFromDictionary(ByVal ipD As Variant)

    If ipD.Count < 1 Then
        Exit Sub
    End If

    Dim myKey As Variant
    For Each myKey In ipD.Keys
        s.Host(GetNextIndex) = Array(myKey, ipD.Item(myKey))
    Next

End Sub

'@Description("Get the index of the next item in the seq")
Private Function GetNextIndex() As Long
Attribute GetNextIndex.VB_Description = "Get the index of the next item in the seq"

    s.LastIndex = s.LastIndex + 1
    If s.LastIndex > s.Size Then

            s.Size = s.Size + DEFAULT_CHUNK
            Resize

    End If

   GetNextIndex = s.LastIndex

End Function


Public Property Get Item(ByVal ipIndex As Long) As Variant
    
    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Get_Item"
    
    Dim myItem As Variant
    myItem = Array(s.Host(ipIndex))
    
    If VBA.IsObject(myItem(0)) Then
        Set Item = myItem(0)
    Else
        Item = myItem(0)
    End If
   
End Property

Public Property Let Item(ByVal ipIndex As Long, ByVal ipItem As Variant)

    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Get_Item"
    
    s.Host(ipIndex) = ipItem
 
End Property

Public Property Set Item(ByVal ipIndex As Long, ByVal ipItem As Variant)
    
    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Get_Item"
    
    Set s.Host(ipIndex) = ipItem
    
End Property

Public Function Insert(ByVal ipIndex As Long, ByVal ipItem As Variant) As Long

    If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
        Insert = -1
        Exit Function
    End If

    MoveUp ipIndex, 1
    
    If VBA.IsObject(ipItem) Then
        Set s.Host(ipIndex) = ipItem
    Else
        s.Host(ipIndex) = ipItem
    End If
  
    Insert = ipIndex

End Function

Public Function InsertItems(ByVal ipIndex As Long, ParamArray ipParamArray() As Variant) As SeqA

    If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
        Set InsertItems = Me
    End If
    
    If ArrayInfo.LacksItems(VBA.CVar(ipParamArray)) Then
        Set InsertItems = Me
    End If
    
    Set InsertItems = InsertRange(ipIndex, VBA.CVar(ipParamArray))

End Function



Public Function InsertRange(ByVal ipIndex As Long, ByRef ipRange As Variant) As SeqA

    If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
        Set InsertRange = Me
        Exit Function
    End If

    Dim myGroupId As e_Group
    myGroupId = GroupInfo.Id(ipRange)
    GuardInvalidRangeObject myGroupId, ipRange, "VBALib.SeqA.InsertRange"
    
    Select Case myGroupId
        
        Case e_Group.m_string:         InsertRangeFromString ipIndex, VBA.CStr(ipRange)
        Case e_Group.m_array:          InsertRangeUsingForeach ipIndex, ipRange
        Case e_Group.m_List:           InsertRangeUsingForeach ipIndex, ipRange
        Case e_Group.m_Dictionary:      InsertRangeFromDictionary ipIndex, ipRange
        Case Else
        
    End Select

    Set InsertRange = Me
End Function

Private Sub InsertRangeFromString(ByRef ipIndex As Long, ByRef ipString As String)
    
    Dim myLen As Long
    myLen = VBA.Len(ipString)
    
    If myLen = 0 Then
        Exit Sub
    End If
    
    MoveUp ipIndex, myLen
     
    Dim myStrIndex As Long
    For myStrIndex = 1 To myLen
        s.Host(ipIndex + myStrIndex - 1) = VBA.Mid$(ipString, myStrIndex, 1)
    Next
    
End Sub
'
Private Sub InsertRangeUsingForeach(ByRef ipIndex As Long, ByRef ipForEach As Variant)
    
    Dim myLen As Long
    If ArrayInfo.IsArray(ipForEach) Then
        myLen = ArrayInfo.Count(ipForEach)
    Else
        myLen = ipForEach.Count
    End If
    
    If myLen < 1 Then
        Exit Sub
    End If
    
    Dim mySeqIndex As Long
    mySeqIndex = ipIndex
    
    MoveUp ipIndex, myLen
    
    Dim myItem As Variant
    For Each myItem In ipForEach
        If VBA.IsObject(myItem) Then
            Set s.Host(mySeqIndex) = myItem
        Else
            s.Host(mySeqIndex) = myItem
        End If
        mySeqIndex = mySeqIndex + 1
    Next
   
End Sub

Private Sub InsertRangeFromDictionary(ByRef ipIndex As Long, ByRef ipD As Variant)
    
    If ipD.Count < 1 Then
        Exit Sub
    End If
    
    Dim mySeqIndex As Long
    mySeqIndex = ipIndex
    
    MoveUp ipIndex, ipD.Count
    
    Dim myKey As Variant
    For Each myKey In ipD.Keys
        s.Host(mySeqIndex) = Array(myKey, ipD.Item(myKey))
        mySeqIndex = mySeqIndex + 1
    Next
    
End Sub


'Public Function RemoveRange(ByVal ipIndex As Long, ByVal ipCount As Long) As SeqA
'    Return Me.RemoveAt(ipCount, ipCount)
'End Function
'
'
'Public Function RemoveAt(ByVal ipRemoveIndex As Long, Optional ipCount As Long = 1) As SeqA
'
'    If ipRemoveIndex < 1 Or ipRemoveIndex > s.LastIndex Then
'        Return Me
'    End If
'
'    If ipCount < 1 Then
'        Return Me
'    End If
'
'    If ipRemoveIndex + ipCount > s.LastIndex Then
'
'        ipCount = s.LastIndex - ipRemoveIndex + 1
'
'    End If
'
'    MoveDown ipRemoveIndex, ipCount ' -1 +1 cancels
'
'    Return Me
'
'End Function
'
'
'Public Function Repeat(ByVal ipIterator As IterConst) As SeqA
'
'    Do
'        Dim myItem As Variant = ipIterator.Item
'        If VBA.IsObject(myItem) Then
'            Set s.Host(GetNextIndex) = myItem
'        Else
'            s.Host(GetNextIndex) = myItem
'        End If
'
'    Loop While ipIterator.MoveNext
'
'    Return Me
'
'End Function
'
'
'Public Function Repeat(ByVal ipIterator As IterNum) As SeqA
'
'    Do
'       s.Host(GetNextIndex) = ipIterator.Item
'    Loop While ipIterator.MoveNext
'
'    Return Me
'
'End Function
'
'
'Public Function Repeat(ByRef ipItem As pVar, ByVal ipCount As Long) As SeqA
'
'    Dim myCount As Long
'    For myCount = 1 To ipCount
'        If VBA.IsObject(ipItem) Then
'            Set s.Host(GetNextIndex) = ipItem
'        Else
'            s.Host(GetNextIndex) = ipItem
'        End If
'    Next
'
'    Return Me
'
'End Function
'
'
''@DescriptiPN("Makes a shallow copy of the SeqA to the provided array")
'Public Function CopyTo(ByRef ipArray As pArray) As SeqA
'
''    ' Dim myArray As Variant = ipoArr.Cargo
''     If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''     If Guard.LacksItems(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''     If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''     'If Guard.SizeMismatch(s.LastIndex > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
'    If Var.LacksItems(ipArray.Cargo) Then
'        Return Me
'    End If
'
'    Dim myIndex  As Long
'    For myIndex = FirstIndex To LastIndex
'
'        Dim myItem As Variant = s.Host(myIndex)
'
'        If VBA.IsObject(myItem) Then
'            Set ipArray.Cargo(myIndex) = myItem
'        Else
'            ipArray.Cargo(myIndex) = myItem
'        End If
'
'        If myIndex > Var.LastIndex(ipArray.Cargo) Then
'            Exit For
'        End If
'    Next
'
'    Return Me
'
'End Function
'
'
'Public Function CopyTo(ByRef ipArray As pArray, ByVal ipArrayStartIndex As Long) As SeqA
'
'    '  ' Dim myArray As Variant = ipoArr.Cargo
'    ' If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' If Guard.LacksItems(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' 'If Guard.SizeMismatch(s.LastIndex > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
'
'    Dim myArrayIndex  As Long = ipArrayStartIndex
'
'    Dim myHostIndex As Long
'    For myHostIndex = FirstIndex To LastIndex
'        Dim myItem As Variant = s.Host(myHostindex)
'
'        If VBA.IsObject(myItem) Then
'            Set ipArray.Cargo(myArrayIndex) = myItem
'        Else
'            ipArray.Cargo(myArrayIndex) = myItem
'        End If
'
'        myArrayIndex += 1
'        If myArrayIndex >= Var.LastIndex(ipArray.Cargo) Then
'            Exit For
'        End If
'    Next
'
'    Return Me
'
'End Function
'
'Public Function CopyTo _
'() '( _
'    ByVal ipSeqStartIndex As Long, _
'    ByRef ipArray As pArray, _
'    ByVal ipArrayStartIndex As Long, _
'    ByVal ipArrayCount As Long _
') As SeqA IMplements SeqA.CopyTo
'
'    '  ' Dim myArray As Variant = ipoArr.Cargo
'    ' If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' If Guard.LacksItems(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' 'If Guard.SizeMismatch(s.LastIndex > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
'
'    Dim myArrayIndex  As Long = ipArrayStartIndex
'
'    Dim myHostIndex As Long
'    For myHostIndex = ipSeqStartIndex - 1 To LastIndex
'        Dim myItem As Variant = s.Host.Item(myHostIndex)
'
'        If VBA.IsObject(myItem) Then
'            Set ipArray.Cargo(myArrayIndex) = myItem
'        Else
'            ipArray.Cargo(myArrayIndex) = myItem
'        End If
'
'        myArrayIndex += 1
'
'        If myArrayIndex > Var.LastIndex(ipArray.Cargo) Then
'            Exit For
'        End If
'
'    Next
'
'    Return Me
'
'End Function
'
'Public Function GetRange(ByVal ipStartIndex As Long, Optional ByVal ipRun As pNum = Nothing, ByVal ipEndIndex As pNum = Nothing) As SeqA Implements SeqA.GetRange
'    Return Slice(PN(ipStartIndex), ipRun, ipEndIndex)
'End Function
'
'
'
'
'
'
'
'
'
'
'
'
'Public Property Get myTypename() As String
'   myTypename = MY_TYPENAME
'End Property
'
'
'
'
'Public Function SplitAt(ByVal ipIndex As Long, Optional ByVal ipSplitType As e_SeqSplit = e_SeqSplit.m_Before) As SeqA
'
'    Dim mySer As SER = Ranges.ResolveStartEndRun(FirstIndex, LastIndex, ipIndex)
'
'    Dim mySplit As SeqA
'    If ipSplitType = m_Before Then
'         Set mySplit = SeqA.Deb.AddItems(PL(Me.Slice(PN(1), PN(mySER.NativeStart - 1)), Me.Slice(PN(mySER.NativeStart))))
'    Else
'        Set mySplit = SeqA.Deb.AddItems(PL(Me.Slice(PN(1), PN(mySER.NativeStart)), Me.Slice(PN(mySER.NativeStart + 1))))
'
'    End If
'    Return mySplit
'
'
'End Function
'
''@DescriptiPN("Splits the SeqA at the first occurence of ipItem")
'Public Function SplitAtItem(ByVal ipItem As pVar, Optional ByVal ipSplitType As e_SeqSplit = e_SeqSplit.m_Before) As SeqA
'    Dim mySplit As SeqA
'    Dim myItems As IterItems = IterItems(Me)
'    Do
'
'        If myItems.GetItem = ipItem.Cargo Then
'            Dim myIndex As Long = myItems.Key(0).cargo
'            If ipSplitType = e_SeqSplit.m_Before Then
'                Set mySplit = SeqA.Deb.AddItems(PL(Me.Slice(PN(1), PN(myIndex - 1)), Me.Slice(PN(myIndex))))
'            Else
'                Set mySplit = SeqA.Deb.AddItems(PL(Me.Slice(PN(1), PN(myIndex)), Me.Slice(PN(myIndex + 1))))
'            End If
'        End If
'
'    Loop While myItems.MoveNext
'
'End Function
'
'
'
''@DescriptiPN("Deletes all items in the seq")
'Public Function Clear() As SeqA
'    Return RemoveAll
'End Function
'
'Public Function RemoveAll() As SeqA
'
'    If Count = 0 Then
'        Return Me
'    End If
'
'    Dim myIndex As Long
'    For myIndex = LastIndex To FirstIndex Step -1
'        s.Host(myIndex) = Empty
'    Next
'    s.LastIndex = 0
'    s.Size = DEFAULT_CHUNK
'    Resize
'    Return Me
'End Function
'
'  '@DescriptiPN("Removes one(default) or more instances of ipItem from the seq.  A count of -1 removes all instances")
'Public Function Remove(ByRef ipItem As pVar, Optional ByVal ipCount As Long = 1) As SeqA
'
'    Dim myIndex As Long = 1
'    Dim myCounter As Long = 0
'    Do
'
'        If s.Host(myIndex) = ipItem.Cargo Then
'            Me.RemoveAt (myIndex)
'            If ipCount = -1 Then
'                Continue Do
'            End If
'
'            myCounter += 1
'
'            If ipCount > myCounter Then
'                Continue Do
'            End If
'
'        Else
'
'            myIndex += 1
'
'        End If
'
'    Loop Until myIndex > UBound(s.Host)
'
'    Return Me
'
'End Function
'
'Public Function Contains(ByRef ipItem As pVar) As Boolean
'    Return Me.HoldsItem(ipItem)
'End Function
'
'@Description("Moves all elements from ipIndex to s.lastindex down by ipCount places")
Private Sub MoveDown(ByVal ipToIndex As Long, ByVal ipCount As Long)
Attribute MoveDown.VB_Description = "Moves all elements from ipIndex to s.lastindex down by ipCount places"

    If ipCount < 1 Then
        Exit Sub
    End If

    ' If ipIndex < FirstIndex Or ipIndex > s.LastIndex Then
    '     Exit Sub
    ' End If

    Dim myToIndex As Long
    myToIndex = ipToIndex

    Dim myFromIndex As Long
    For myFromIndex = ipToIndex + ipCount To s.LastIndex

        If VBA.IsObject(s.Host(myFromIndex)) Then
            Set s.Host(myToIndex) = s.Host(myFromIndex)
        Else
            s.Host(myToIndex) = s.Host(myFromIndex)
        End If
       ' s.host(myFromIndex) = Empty
        myToIndex = myToIndex + 1


    Next
    Dim myIndex As Long
    For myIndex = s.LastIndex - ipCount + 1 To s.LastIndex
        s.Host(myIndex) = Empty
    Next
    s.LastIndex = s.LastIndex - ipCount

End Sub
'
'@Description("Moves all elements from ipIndex to s.lastindex up by ipCount places")
Private Sub MoveUp(ByVal ipIndex As Long, Optional ByVal ipCount As Long = 1)
Attribute MoveUp.VB_Description = "Moves all elements from ipIndex to s.lastindex up by ipCount places"

    If ipCount < 1 Then
        Exit Sub
    End If

    If ipIndex < FirstIndex Or ipIndex > s.LastIndex Then
        Exit Sub
    End If


    Do While s.LastIndex + ipCount > s.Size
        DoEvents
        s.Size = s.Size + DEFAULT_CHUNK
        Resize

    Loop

    Dim myToIndex As Long
    myToIndex = s.LastIndex + ipCount
    Dim myFromIndex As Long
    myFromIndex = s.LastIndex

    Dim myIterations As Long
    For myIterations = 0 To s.LastIndex - ipIndex

        Swap s.Host(myToIndex - myIterations), s.Host(myFromIndex - myIterations)

    Next

    s.LastIndex = s.LastIndex + ipCount

End Sub
'
'
'
'Public Function HoldsItem(ByRef ipItem As Variant) As Boolean
'
'    If s.LastIndex < 1 Then
'        HoldsItem = False
'    End If
'
'    Dim myIndex As Long
'    For myIndex = FIRST_INDEX To s.LastIndex
'        Dim myItem As Variant
'        myItem = Array(s.Host(myIndex))
'        If ComparerHelpers.Equals(myItem, ipItem) Then
'            HoldsItem = True
'        End If
'    Next
'
'    HoldsItem = False
'End Function
'
'Public Function LacksItem(ByRef ipItem As Variant) As Boolean
'    LacksItem = Not HoldsItem(ipItem)
'End Function
'
'Public Function MapIt(ByVal ipMapper As IMapper) As SeqA
'
'    Dim myS As SeqA
'    Set myS = SeqA.Deb
'
'    Dim myIndex As Long
'    For myIndex = FIRST_INDEX To s.LastIndex
'        myS.Add = ipMapper.ExecMapper(s.Host(myIndex))(0)
'    Next
'
'    Set MapIt = myS
'
'End Function
'
'Public Function FilterIt(ByVal ipComparer As IComparer) As SeqA
'
'    Dim myS As SeqA
'    Set myS = SeqA.Deb
'
'    Dim myIndex As Long
'    For myIndex = FIRST_INDEX To s.LastIndex
'        If ipComparer.ExecCmp(s.Host(myIndex)) Then
'            mySeq.Add s.Host(myIndex)
'        End If
'    Next
'
'    Set FilterIt = myS
'
'End Function
'
'' Does not generate an interim SeqA as would filterIt followed by Count.
'Public Function CountIt(ByVal ipComparer As IComparer) As Long
'
'    Dim myCount As Long
'    myCount = 0
'
'    Dim myIndex As Long
'    For myIndex = FIRST_INDEX To s.LastIndex
'        If ipComparer.ExecCmp(s.Host(myIndex)) Then
'            myCount = myCount + 1
'        End If
'    Next
'
'    CountIt = myCount
'
'End Function
'
''@DescriptiPN("Returns a single Host based on the Reducer").
'Public Function ReduceIt(ByRef ipReducer As IReducer) As Variant
'    ReduceIt = ipReducer.ExecReduction(Me)
'End Function
'
''@DescriptiPN("Returns the item at FirstIndex")
'Public Property Get First() As pVar IMplements SeqA.First
'    Return s.Host(FirstIndex)
'End Function
'
''@DescriptiPN("Assigns to the Item at FirstIndex")
'Public Property Let First(ByRef ipItem As pVar)
'    s.Host(FirstIndex) = ipItem
'End Property
'
''@DescriptiPN("Assigns to the Item at FirstIndex")
'Public Property Set First(ByRef ipItem As pVar)
'    Set s.Host(FirstIndex) = ipItem
'End Property
'
''@DescriptiPN("Returns the Item at LastIndex")
'Public Property Get Last() As pVar
'    Return s.Host(s.LastIndex)
'End Property
''@DescriptiPN("Assigns to the Item at LastIndex")
'Public Property Let Last(ByRef ipItem As pVar)
'    s.Host(s.LastIndex) = ipItem
'End Property
''@DescriotiPN("Assigns to the item at LastIndex")
'Public Property Set Last(ByRef ipItem As pVar)
'    Set s.Host(s.LastIndex) = ipItem
'End Property
'
'
'
''@DescriptiPN("Returns the Host of the last used index")
'Public Function LastIndex() As Long
'    If s.LastIndex < FirstIndex Then
'        Return CVErr(9&)
'    Else
'        Return s.LastIndex
'    End If
'End Function
'
'
'
'
'
'Public Function Count() As Long
'    Count = s.LastIndex
'End Function
'
''Public Property Get Capacity() As Long
''    Capacity = s.Size
''End Property
''
'''@("Resizes the host array to the specifies capacity, existing Hosts in the capacity range are preserved")
''Public Property Let Capacity(ByVal ipCapacity As Long)
''    s.Size = ipCapacity
''    Resize
''End Property
'
'
''@DescriptiPN("Returns the index of the Item")
'Public Function IndexOf _
'() '( _
'    ByVal ipItem As pVar, _
'    Optional ipStart As Long, _
'    Optional ipEnd As Long, _
'    Optional ipRun As Long _
') As Long  IMplements SeqA.IndexOf
'
'    Dim mySER As SER = Ranges.ResolveStartEndRun(FirstIndex, LastIndex, ipStart, ipEnd, ipRun)
'
'    Dim myIndex As Long
'    For myIndex = mySER.NativeStart To mySER.NativeEnd
'        If s.Host(myIndex) = ipItem.cargo Then Return myIndex
'    Next
'    Return -1
'End Sub
'
'Public Function LastIndexOf(ByVal ipItem As pVar) As Long
'
'    Dim myIndex As Long
'    For myIndex = s.LastIndex To FirstIndex Step -1
'        If s.Host(myIndex) = ipItem.cargo Then Return myIndex
'    Next
'    Return -1
'End Function
'
'Public Function Join(ByVal ipSeparator As String) As String
'
'    On Error Resume Next
'    Dim myString As String = VBA.Join(Me.ToArray, ipSeparator)
'    On Error GoTo 0
'    Return myString
'
'End Function
'
'Public Function Join() As String IMplements SeqA.JOin
'
'    On Error Resume Next
'    Dim myString As String = VBA.Join(Me.ToArray, chars.twcomma)
'    On Error GoTo 0
'    Return myString
'
'End Function
'
'Private Function TrimToSize() As SeqA
'    If s.LastIndex > 0 Then
'        ReDim Preserve s.Host(FirstIndex To s.LastIndex)
'    End If
'    Return Me
'End Function
'
'
Private Sub Resize()
    If s.Size < 1 Then
        ReDim Preserve s.Host(FIRST_INDEX To DEFAULT_CHUNK)
    Else
        ReDim Preserve s.Host(FIRST_INDEX To s.Size)
    End If

    ' The last index is not set here because it depends on the context where
    ' resize was called
    ' Last index should be adjusted at the calling site.
End Sub
'
'
'
'
'Public Function Id() As e_typeId
'    return e_typeId.m_SeqA
'End Function
'
'
'Public Function LacksItems() As Boolean
'    Return Count < 1
'End Function
'
'Public Function HoldsItems() As Boolean
'    Return Count > 1
'End Function
'
'' Public Function HasAnyItems() As Boolean
''     Return Count > 0
'' End Function
'
'' Public Function HasOneItem() As Boolean
''     Return Count = 1
'' End Function
'
'
'
'
'
'Public Function Push(ByRef ipItem As pVar) As SeqA
'        Set s.Host(GetNextIndex) = ipItem.Cargo
'    Else
'        s.Host(GetNextIndex) = ipItem.Cargo
'    End If
'    Return Me
'End Function
'
'Public Function Push(ByRef ipParams As pParamList) As SeqA
'
'    Dim myItem As Variant
'    For Each myItem In ipParams.Cargo
'        If VBA.IsObject(myItem) Then
'            Set s.Host(GetNextIndex) = myItem
'        Else
'            s.Host(GetNextIndex) = myItem
'        End If
'    Next
'
'    Return Me
'
'End Function
'
'Public Function Push(ByRef ipRange As oContainer) As SeqA
'    Return AddRange(ipRange)
'End Function
'
'Public Function Push(ByRef ipRange As pArray) As SeqA
'    Return AddRange(ipRange)
'End Function
'
'
'' Public Function enQueue(ByRef ipItemObject As oItemObj) As SeqA
''     Add ipItemObject
''     Return Me
'' End Function
'
'Public Function enQueue(ByRef ipItem As pVar) As SeqA
'    Return AddItems(ipItem)
'End Function
'
'
'Public Function enQueue(ByRef ipRange As pArray) As SeqA
'    Return AddRange(ipRange)
'End Function
'
'Public Function enQueue(ByRef ipRange As oContainer) As SeqA
'    Return AddRange(ipRange)
'End Function
'
'Public Function enQueue(ByRef ipRange As pParamList) As SeqA
'    Return AddItems(ipRange)
'End Function
'
'Public Function RotL(Optional ByVal ipCount As Long = 1) As SeqA
'    Dim myCount As Long
'    For myCount = 1 To ipCount
'        AddItems Dequeue
'    Next
'    Return Me
'End Function
'
'Public Function RotR(Optional ByVal ipCount As Long = 1) As SeqA
'    Dim myCount As Long
'    For myCount = 1 To ipCount
'        Insert 1, Pop
'    Next
'    Return Me
'End Function
'
'Public Function Pop(Optional ipCount As Long = 1) As pVar
'
'    If ipCount < 1 Then
'        Return Null
'    End If
'
'    Dim mySeq As SeqA = SeqA.Deb
'    Dim myCount As Long
'    For myCount = 1 To ipCount
'        Dim myItem As Variant = Me.Last
'        If VBA.IsObject(myItem) Then
'            mySeq.Add PO(Me.Last)
'        Else
'            mySeq.Add Pi(Me.Last)
'        End If
'        Me.RemoveAt (Me.LastIndex)
'    Next
'
'    If mySeq.Count = 1 Then
'        Return PV(mySeq.First)
'    Else
'        Return PV(mySeq)
'    End If
'
'    ' Dim myA As Variant = Me.Slice(s.LastIndex - ipCount + 1, s.LastIndex).ToArray
'    ' Me.RemoveAt(s.LastIndex - ipCount + 1, ipCount)
'    ' If ipCount = 1 Then
'    '     Return myA(0)
'    ' Else
'    '   Return myA
'    ' End If
'
'End Function
'
'Public Function Dequeue(Optional ipCount As Long = 1, Optional ByVal ipListType As e_List = e_List.m_pArrList) As Variant
'
'    If ipCount < 1 Then
'        Return Null
'    End If
'
'    Dim myA As Variant = Slice(PN(FirstIndex), iprun:=PN(ipCount)).ToArray
'    Me.RemoveAt(FirstIndex, ipCount)
'    If ipCount = 1 Then
'        return myA(0)
'    Else
'        return myA
'    End If
'
'End Function
'
'Public Function Sort() As SeqA  Implements SeqA.Sort
'    QuickSort1 Me
'    Return Me
'End Function
'
'Private Sub QuickSort1(ByRef iopSortable As Variant, Optional ByVal ipLeft As Long, Optional ByVal ipRight As Long)
'
'    Dim myFirst As Long
'    Dim myLast As Long
'    Dim myMid As Variant
'    Dim mySwap As Variant
'
'    'Dim iopSortable.Cargo As Meta = Meta.Deb(iopSortable)
'    'Dim myReversible As Meta = Meta.Deb(iopSortable)
'
'    ' Dim iopSortable.Cargo As Variant
'    ' If ArrayInfo.IsArray(iopSortable) Then
'    '     Set iopSortable.Cargo = ListArray.Deb(iopSortable)
'    ' Else
'    '     Set iopSortable.Cargo = iopSortable
'    ' End If
'
'
'    If ipRight = 0 Then
'        ipLeft = iopSortable.Cargo.FirstIndex(1) 'LBound(iopSortable)
'        ipRight = iopSortable.Cargo.LastIndex(1) 'UBound(iopSortable)
'    End If
'    myFirst = ipLeft
'    myLast = ipRight
'    myMid = iopSortable.Cargo.Item((ipLeft + ipRight) \ 2)
'    Do
'        Do While iopSortable.Cargo.Item(myFirst) < myMid And myFirst < ipRight
'            myFirst += 1
'        Loop
'        Do While myMid < iopSortable.Cargo.Item(myLast) And myLast > ipLeft
'            myLast -= 1
'        Loop
'
'        If myFirst <= myLast Then
'
'            If VBA.IsObject(iopSortable.Cargo.Item(myFirst)) Then
'                Set mySwap = iopSortable.Cargo.Item(myFirst)
'                Set iopSortable.Cargo.Item(myFirst) = iopSortable.Cargo.Item(myLast)
'                Set iopSortable.Cargo.Item(myLast) = mySwap
'            Else
'                mySwap = iopSortable.Cargo.Item(myFirst)
'                iopSortable.Cargo.Item(myFirst) = iopSortable.Cargo.Item(myLast)
'                iopSortable.Cargo.Item(myLast) = mySwap
'            End If
'            myFirst += 1
'            myLast -= 1
'        End If
'    Loop Until myFirst > myLast
'    If ipLeft < myLast Then
'        QuickSort1 iopSortable.Cargo, ipLeft, myLast
'    End If
'    If myFirst < ipRight Then
'        QuickSort1 iopSortable, myFirst, ipRight
'    End If
'End Sub
'
'Public Function Swap(ByRef ipLHS As Long, ByVal ipRHS As Long) As SeqA
'    Dim myTmp As Variant
'    If VBA.IsObject(s.Host(ipLHS)) Then
'        Set myTmp = s.Host(ipLHS)
'    Else
'        myTmp = s.Host(ipLHS)
'    End If
'
'    If VBA.IsObject(s.Host(ipRHS)) Then
'        Set s.Host(ipLHS) = s.Host(ipRHS)
'    Else
'        s.Host(ipLHS) = s.Host(ipRHS)
'    End If
'    If VBA.IsObject(myTmp) Then
'        Set s.Host(ipRHS) = myTmp
'    Else
'        s.Host(ipRHS) = myTmp
'    End If
'
'    Return Me
'End Function
'
'Public Function Reverse() As SeqA
'
'    ' we need to reverse in place
'
'    Dim myArray As Variant
'    ReDim myArray(LBound(s.Host, 1) To UBound(s.Host, 1))
'
'
'    Dim myindex As Long = 1
'    Dim myReverseIndex As Long
'    For myReverseIndex = LastIndex To FirstIndex Step -1
'
'        myArray(myReverseIndex) = s.Host(myIndex)
'        myindex += 1
'    Next
'
'    s.Host = myArray
'    ' Dim myReversed As SeqA = SeqA.Deb
'    ' Dim myItems As IterItems = IterItems.Deb(Me).MoveToEnd
'    ' Do
'    '   myReversed.Add myItems(0)
'    ' Loop While myItems.MovePrev
'     Return Me
'
'End Function
'
'' Public Function Set(ByVal ipSet As SetOf, ipParam As SeqA) As SeqA
''     Return Cops.Set(ipSet, Me, ipParam)
'' End Function
'
' Public Function SetOf(ByVal ipSet As e_Set, ipLHS As SeqA, ByRef ipRHS As oContainer) As SeqA
'
'        ' Dim myLHS As SeqA = SeqA.Deb(ipLHS)
'        ' Dim myRHS As SeqA = SeqA.Deb(ipRHS)
'
'        Select Case ipSet
'
'            Case e_Set.m_Both:              Return Both(ipLHS, ipRHS)
'            Case e_Set.m_HostOnly:          Return LHSOnly(ipLHS, ipRHS)
'            Case e_Set.m_ParamOnly:         Return LHSOnly(ipRHS, ipLHS) ' note reversal of params
'            Case e_Set.m_NotInBoth:           Return NotBoth(ipLHS, ipRHS)
'            Case e_Set.m_Unique:              Return MergeUnique(ipLHS, ipRHS)
'
'        End Select
'
'End Function
'
'
'
'
'Private Function LHSOnly(ByRef ipLHS As oContainer, ByRef ipRHS As oContainer) As SeqA
'    ' Dim myLHSIsKvp As Boolean = Var.IsItemByKey(ipLHS)
'    ' Dim myRHSIsKvp As Boolean = Var.IsItemByKey(ipRHS)
'    ' Dim myResult As SeqA = SeqA.Deb
'    ' Dim myH As IterItems = IterItems(ipLHs.host)
'    ' Do
'    '     If myLHSIsKvp Then
'
'
'    '     Dim myItem As Variant = myH.GetItem
'    '     If ipRHs.host.LacksItem(myItem) And myResult.LacksItem(myItem) Then
'    '         myResult.Add myItem
'    '     End If
'
'    ' Loop While myH.MoveNext
'
'    ' Return myResult
'
'End Function
'
'Private Function Both(ByRef ipLHS As SeqA, ByRef ipRHS As oContainer) As SeqA
'
'    Dim myResult As SeqA = SeqA.Deb
'
'    Dim myLHS As IterItems = IterItems(ipLHS)
'    Do
'        Dim myItem As Variant = myLHS.GetItem
'        If ipRHS.Cargo.HoldsItem(myItem) Then
'            myresult.Add pVar(myItem)
'        End If
'    Loop While myLHS.MoveNext
'
'    Return myResult
'
'End Function
'
'
'Private Function NotBoth(ByRef ipLHS As SeqA, ByRef ipRHS As oContainer) As SeqA
'
'    Return SeqA.Deb(PC(Me.LHSOnly(ipLHS, ipRHS))).Merge(PC(LHSOnly(ipRHS, ipLHS))) ' note the reversal of the parameters
'
'End Function
'
'Private Function MergeUnique(ByRef ipLHS As oContainer, ByRef ipRHS As oContainer) As SeqA
'
'    Dim myresult As SeqA = SeqA.Deb(ipLHS)
'    Dim myI As IterItems = IterItems(SeqA.Deb(ipRHS))
'    Do
'        Dim myItem As Variant = myI.GetItem
'        DoEvents
'        If myresult.Count = 0 Then
'            myresult.Add PV(myItem)
'        ElseIf myresult.LacksItem(PV(myItem)) Then
'            myresult.Add PV(myItem)
'        End If
'    Loop While myI.MoveNext
'    Return myresult
'End Function
'
'Public Function Merge(ByRef ioContainer As oContainer) As SeqA
'    Return Me.AddRange(ioContainer)
'End Function
'
'Public Function Host() As pvar Implements SeqA.Host
'    Return Items
'End Function
'
'Public Function IsUnique() As Boolean Implements SeqA.IsUnique
'
'    Dim myFreqs As KvpA = Me.Freq
'    Dim myIter As IterItems = IterItems(myFreqs)
'    Do
'
'        If myIter.GetItem > 1 Then
'
'            Return False
'
'        End If
'
'    Loop While myIter.MoveNext
'
'    Return True
'
'End Function
'
'Public Function IsNotUnique() As Boolean
'    Return Not IsUnique
'End Function
'
'
'Public Function Freq() As IKvp
'
'    Dim myKvp As IKvp = KvpA.Deb
'
'    Dim myIter As IterItems = IterItems(Me)
'    Do
'
'        If myKvp.HoldsKey(myIter.GetItem) Then
'
'            myKvp.Item(myIter.GetItem) += 1
'
'
'        Else
'
'            myKvp.Add PV(myIter.GetItem), PV(1)
'
'
'        End If
'
'    Loop While myIter.MoveNext
'
'    Return myKvp
'
'End Function
'
''@DescriptiPN(creates an KvpH of collections items where the items in the collection are bucketed based on the Host at an Index)
'Public Function Freq(ByVal ipIndex As Long) As IKvp
'
'    Dim myKvpH As IKvp = KvpA.Deb
'
'        Dim myIter As IterItems = IterItems(Me)
'        Do
'            Dim myItem As Variant = myIter.GetItem
'            If myKvpH.HoldsKey(myItem.Item(ipIndex)) Then
'
'                myKvpH.Item(myItem.Item(ipIndex)).Add myIter.GetItem
'
'
'            Else
'
'                myKvpH.Add PV(myItem.GetItem), PV(SeqA.Deb)
'
'
'            End If
'
'        Loop While myIter.MoveNext
'
'    Return myKvpH
'
'End Function
