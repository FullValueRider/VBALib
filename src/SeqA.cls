VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "SeqA"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_Description = "Seq is a multipurpose Collection/ArrayList replacement.  Items use 1 based indexing. ToArray returns Arrays with an Lbound of 1.  For a Keyed collection, use one of the Kvp classes"
'@PredeclaredId
'@Exposed
'@Folder("Seq")
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C

'@ModuleDescription("SeqA is a multipurpose Collection/ArrayList replacement.  It uses a one dimensional array to store the items.  Items are access using a single 1 based index. Multi dimensions addressing can be converted to linrear addressing using ArrayInfo.GetIndex. For a Keyed collection, use one of the Kvp classes")
' SeqA uses the VBA Collection class as a host for the items
' Other versions of SeqA are available (SeqA, SeqAL, SeqAH, SeqAT)

Option Explicit
'Implements SeqA

Private Const MY_TYPENAME                       As String = "SeqA"
Private Const DEFAULT_CHUNK                     As Long = 16&
Private Const FIRST_INDEX                       As Long = 1

Private Type State

   ' HostCopy                                    As variantudt
    Host()                                      As Variant ' an array
    LastIndex                                   As Long
    Size                                        As Long
    Tmp                                         As SeqA
    
End Type

Private s                                       As State

' Deb is a Factory method of the PredeclaredId which returns a new instance of SeqA
'=================================================================================
' The input for Deb is a ParamArray.
' The ParamArray is interpreted according to the folowing rules
' If the ParamArray contains no Items
' - A empty SeqAuence (count = 0)
' If the ParamArray has 2 or more items
' - A SeqA of size equal to the ParamArray, items as generated by for each over the ParamArray
' If the ParamArray has a single Item
' - Number: SeqA with specified capacity with each Item being the Value 'Empty'
' - String: A SeqA whose capacity is the length of the string with one character per Item
' - Array: SeqA of items as provided by For Each over the array.  Multidimension arrays are flattened but the position in the original array can be calculated by the user if required. See also Bind
' - Dictionaries: a SeqA of key/value arrays as generated from for each on the Keys array.
' - Collection: The collection is copied to the Host collection.  There is no refererence link to the original collection (See Host Property)
' - SeqA: Items as generated by for each on the SeqA
' - mscorlib Arraylist: Items as generated by for each on the arrylist
' - mscorlib Stack: Items as generated by for each on the stack
' - mscorlib Queue: Items as generated by for eac on the queue

'@DefaultMember
Public Function Deb(ParamArray ipParamArray() As Variant) As SeqA
Attribute Deb.VB_UserMemId = 0
    
    With New SeqA
        Set s.Tmp = .ConstructInstance
    End With
    
    ' the assignment to s.tmp is a kludge that allows the various
    ' Populate methods to operate on the new instance
    ' which greatly simplifies the populate methods at some processing cost.
    If ArrayInfo.LacksItems(VBA.CVar(ipParamArray)) Then
        Set Deb = s.Tmp
        Set s.Tmp = Nothing
        Exit Function
    End If
    
'    'do some preemptive checking and if we only have item(0) and it is an array
'    ' we need to do special memory copying to preseve the mutability of the external array
'    If ArrayInfo.Count(VBA.CVar(ipParamArray)) = 1 Then
'        If ArrayInfo.IsArray(ipParamArray(0)) Then
'
'            PopulateFromArray ipParamArray(0)
'            Set Deb = s.Tmp
'            Set s.Tmp = Nothing
'            Exit Function
'        End If
'
'    End If
        
    ' Now it is safe to resolve the paramarray if it only has a single item
    Dim myParam As Variant
    myParam = VBA.CVar(ipParamArray)
    Sys.ResolveParamArray myParam

    ' myParam may now be any type so we process in accordance with the rules stated above
    Dim myGroupId As e_Group
    myGroupId = GroupInfo.Id(myParam)
    

    Select Case myGroupId

        Case e_Group.m_Empty:               s.Tmp.Add myParam
        Case e_Group.m_Admin:               s.Tmp.Add myParam
        Case e_Group.m_number:              PopulateUsingInitialSize VBA.CLng(myParam)
        Case e_Group.m_string:              PopulateFromString VBA.CStr(myParam)
        Case e_Group.m_array:               PopulateUsingForEach myParam
        Case e_Group.m_List:                PopulateUsingForEach myParam
        Case e_Group.m_Dictionary:          PopulateFromDictionary myParam
        Case e_Group.m_Other:               s.Tmp.Add myParam
                  
    End Select

    Set Deb = s.Tmp
    Set s.Tmp = Nothing
    
End Function


Friend Function ConstructInstance() As SeqA
    s.LastIndex = 0
    s.Size = DEFAULT_CHUNK
    Resize
    Set ConstructInstance = Me
End Function

Private Sub PopulateFromArray(ByRef ipArray As Variant)

'do the memory juggery pokery here
End Sub


Private Sub PopulateUsingInitialSize(ByVal ipInitialSize As Long)
    
    GuardInsufficientCapacity ipInitialSize, "VBALib.SeqA.Deb"
    
    Dim myCount As Long
    For myCount = FIRST_INDEX To ipInitialSize
       s.Tmp.Add Empty
    Next

End Sub

Private Sub PopulateFromString(ByRef ipString As String)
    
    If VBA.Len(ipString) = 0 Then
        Exit Sub
    End If
    
    Dim myIndex As Long
    For myIndex = 1 To VBA.Len(ipString)
        s.Tmp.Add VBA.Mid$(ipString, myIndex, 1)
    Next
        
End Sub

Private Sub PopulateUsingForEach(ByVal ipForEach As Variant)
   
   Dim myLen As Long
   If VBA.IsArray(ipForEach) Then
        myLen = ArrayInfo.Count(ipForEach)
    Else
        myLen = ipForEach.Count
    End If
    
    If myLen < 1 Then
        Exit Sub
    End If
    
    Dim myItem As Variant
    For Each myItem In ipForEach
      s.Tmp.Add myItem
    Next
 
End Sub

' A SeqA can be constructed using Dictionary.Keys or Dictionary.Items
' Consequently, if the single item in the paramarray is a Dictionary
' it is assumed that the sequence will be Key/Item pairs as single pair entities
' initially we will do this as an array
Private Sub PopulateFromDictionary(ByVal ipD As Variant)
    
    If ipD.Count = 0 Then
        Exit Sub
    End If

    Dim myKey As Variant
    For Each myKey In ipD.Keys
         s.Tmp.Add Array(myKey, ipD.Item(myKey))
    Next
   
End Sub

'' get and let host need some jiggery pokery as
'Public Property Get Host() As Collection
'    Set Host = s.Host
'End Property
'
'Public Property Set Host(ByVal ipCollection As Collection)
'    Set s.Host = ipCollection
'End Property
'@Description("allows and external array to be inserted into s.Host")
'ToDo: update BInd to do the necessary memorty copying jiggery pokery
Public Function Bind(ByRef ipArray As Variant) As SeqA
Attribute Bind.VB_Description = "allows and external array to be inserted into s.Host"
    
'    GuardExpectingArray ipArray, "VBALib.SeqA.Bind"
'
'    'ToDO: his code requires updating I think
'     ' make a copy of the content of s.host
'    CopyMemoryToAny ByVal VarPtr(s.HostCopy), ByVal VarPtr(s.Host), 16
'   ' transplant the structure of ipoATable to s.host
'    CopyMemoryToAny ByVal VarPtr(s.Host), ByVal VarPtr(ipArray.Cargo), 16
'
'    Set Bind = Me

End Function

Public Function Clone() As SeqA
    ReDim Preserve s.Host(FIRST_INDEX To s.LastIndex)
    Set Clone = SeqA(s.Host)
End Function

'@Enumerator
Public Function NewEnum() As IUnknown
Attribute NewEnum.VB_UserMemId = -4
    Err.Raise 17 + vbObjectError, _
        "VBALib.SeqA.NewEnum", _
        "Not implemented for SeqA"
End Function

'ToDo: Update to necessary memory jiggery pokery
Private Sub Class_Terminate()

'    If s.HostCopy.VT = 0 Then
'        Exit Sub
'    Else
'        CopyMemByVal ByVal VarPtr(s.Host), ByVal VarPtr(s.HostCopy), 16
'    End If

End Sub


'@Description("Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer")
Public Function Count(Optional ByRef ipItem As Variant) As Long
Attribute Count.VB_Description = "Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer"

    If VBA.IsMissing(ipItem) Then
        Count = s.LastIndex
        Exit Function
    End If
    
    Dim myCount As Long
    myCount = 0
    
    Dim myIndex As Long
    For myIndex = 1 To s.LastIndex
        If ComparerHelpers.Equals(s.Host(myIndex), ipItem) Then
            myCount = myCount + 1
        End If
    Next
    
    Count = IIf(myCount = 0, -1, myCount)
    
End Function

Public Function Items() As Variant

    ReDim Preserve s.Host(1 To s.LastIndex)
    Items = s.Host
    
End Function

'@Description("Returns a subset of the SeqA")
Public Function Slice _
( _
    Optional ByRef ipStart As Long = 1, _
    Optional ByRef ipRun As Long = -1, _
    Optional ByRef ipStep As Long = 1 _
) As SeqA
Attribute Slice.VB_Description = "Returns a subset of the SeqA"
    
    If s.LastIndex < 1 Then
        Set Slice = SeqA.Deb
        Exit Function
    End If
    
    GuardIndexOutOfBounds ipStart, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Sice"
    
    Dim myRun As Long
    myRun = ipRun
    If myRun = -1 Then
        myRun = s.LastIndex - ipStart + 1
    Else
        GuardIndexOutOfBounds myRun + ipStart, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Sice"
    End If

    Dim myS As SeqA
    Set myS = SeqA.Deb
   
    Dim mySeqIndex As Long
    'Debug.Print ipStart + myRun - 1
    For mySeqIndex = ipStart To ipStart + myRun - 1 Step ipStep
        '@Ignore FunctionReturnValueDiscarded
        myS.Add s.Host(mySeqIndex)
    Next

    Set Slice = myS

End Function

'@Description("Returns a shallow copy of the SeqA as a VBA collection")
Public Function ToCollection() As Collection
Attribute ToCollection.VB_Description = "Returns a shallow copy of the SeqA as a VBA collection"
    
    Dim myC As Collection
    Set myC = New Collection
    
    Dim myIndex As Long
    For myIndex = FIRST_INDEX To s.LastIndex
        myC.Add s.Host(myIndex)
    Next
    
    Set ToCollection = myC
    
End Function

'@Description("Returns a shallow copy of the SeqA as an Array.  The Lbound of the array is 1")
Public Function ToArray() As Variant
Attribute ToArray.VB_Description = "Returns a shallow copy of the SeqA as an Array.  The Lbound of the array is 1"
    ReDim Preserve s.Host(FIRST_INDEX To s.LastIndex)
    ToArray = s.Host
End Function

'@Description("Returns the Host of the first Index")
Public Function FirstIndex() As Long
Attribute FirstIndex.VB_Description = "Returns the Host of the first Index"

    If s.LastIndex < FIRST_INDEX Then
        FirstIndex = -1
    Else
        FirstIndex = FIRST_INDEX
    End If
    
End Function

'@Description("Returns the UBound of the SeqA or -1 if the SeqA is empty.  Equivalent to Count.")
Public Function LastIndex() As Long
Attribute LastIndex.VB_Description = "Returns the UBound of the SeqA or -1 if the SeqA is empty.  Equivalent to Count."

    If s.LastIndex < FIRST_INDEX Then
        LastIndex = -1
    Else
        LastIndex = s.LastIndex
    End If
   
End Function

'@Description("Returns the First but One index or error 9")
Public Function FBOIndex() As Long
Attribute FBOIndex.VB_Description = "Returns the First but One index or error 9"

    If FIRST_INDEX + 1 <= s.LastIndex Then
        FBOIndex = FirstIndex + 1
    Else
        FBOIndex = -1
    End If
    
End Function

 '@Description("Returns the last but One index or error 9")
Public Function LBOIndex() As Long
Attribute LBOIndex.VB_Description = "Returns the last but One index or error 9"
    If s.LastIndex - 1 >= FIRST_INDEX Then
        LBOIndex = s.LastIndex - 1
    Else
        LBOIndex = -1
    End If
End Function

Public Function TypeName() As String
    TypeName = MY_TYPENAME
End Function

'@Description("Add a single item.  Returns the index at which added.  For compatibility with ArrayList")
Public Function Add(ByRef ipItem As Variant) As Long
Attribute Add.VB_Description = "Add a single item.  Returns the index at which added.  For compatibility with ArrayList"

    Dim myIndex As Long
    myIndex = GetNextIndex

    If VBA.IsObject(ipItem) Then
        Set s.Host(myIndex) = ipItem
    Else
        s.Host(myIndex) = ipItem
    End If
    
    Add = myIndex
    
End Function


'@Description("Add Items in the paramarray to the  )
Public Function AddItems(ParamArray ipParamArray() As Variant) As SeqA

    If ArrayInfo.LacksItems(VBA.CVar(ipParamArray)) Then
        Set AddItems = Me
        Exit Function
    End If

    Dim myItem As Variant
    For Each myItem In ipParamArray
        If VBA.IsObject(myItem) Then
            Set s.Host(GetNextIndex) = myItem
        Else
            s.Host(GetNextIndex) = myItem
        End If
    Next

    Set AddItems = Me
    
End Function

'@Description("Add an array,  list type, dictionary type, or characters of a string")
Public Function AddRange(ByVal ipRange As Variant) As SeqA
Attribute AddRange.VB_Description = "Add an array,  list type, dictionary type, or characters of a string"

    Dim myGroupId As e_Group
    myGroupId = GroupInfo.Id(ipRange)
    GuardInvalidRangeObject myGroupId, ipRange, "VBALib.SeqA.AddRange"
    
    Select Case myGroupId
        Case e_Group.m_string:      AddRangeFromString VBA.CStr(ipRange)
        Case e_Group.m_array:       AddRangeUsingForEach ipRange
        Case e_Group.m_List:        AddRangeUsingForEach ipRange
        Case e_Group.m_Dictionary:  AddRangeFromDictionary ipRange
    End Select
    
    Set AddRange = Me

End Function

Private Sub AddRangeFromString(ByVal ipString As String)

    Dim myLen As Long
    myLen = VBA.Len(ipString)
    
    If myLen = 0 Then
        Exit Sub
    End If

    Dim myIndex As Long
    For myIndex = 1 To myLen
         s.Host(GetNextIndex) = VBA.Mid$(ipString, myIndex, 1)
    Next

End Sub

Private Sub AddRangeUsingForEach(ByVal ipForEach As Variant)

    If ArrayInfo.IsArray(ipForEach) Then
        If ArrayInfo.LacksItems(ipForEach) Then
            Exit Sub
        End If
    ElseIf ipForEach.Count < 1 Then
        Exit Sub
    End If
    
    Dim myItem As Variant
    For Each myItem In ipForEach
        If VBA.IsObject(myItem) Then
            Set s.Host(GetNextIndex) = myItem
        Else
           s.Host(GetNextIndex) = myItem
        End If
    Next

End Sub

Private Sub AddRangeFromDictionary(ByVal ipD As Variant)

    If ipD.Count < 1 Then
        Exit Sub
    End If

    Dim myKey As Variant
    For Each myKey In ipD.Keys
        s.Host(GetNextIndex) = Array(myKey, ipD.Item(myKey))
    Next

End Sub

'@Description("Get the index of the next item in the seq")
Private Function GetNextIndex() As Long
Attribute GetNextIndex.VB_Description = "Get the index of the next item in the seq"

    s.LastIndex = s.LastIndex + 1
    If s.LastIndex > s.Size Then

            s.Size = s.Size + DEFAULT_CHUNK
            Resize

    End If

   GetNextIndex = s.LastIndex

End Function


Public Property Get Item(ByVal ipIndex As Long) As Variant
    
    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Get_Item"
    
    Dim myItem As Variant
    myItem = Array(s.Host(ipIndex))
    
    If VBA.IsObject(myItem(0)) Then
        Set Item = myItem(0)
    Else
        Item = myItem(0)
    End If
   
End Property

Public Property Let Item(ByVal ipIndex As Long, ByVal ipItem As Variant)

    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Get_Item"
    
    s.Host(ipIndex) = ipItem
 
End Property

Public Property Set Item(ByVal ipIndex As Long, ByVal ipItem As Variant)
    
    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Get_Item"
    
    Set s.Host(ipIndex) = ipItem
    
End Property

Public Function Insert(ByVal ipIndex As Long, ByVal ipItem As Variant) As Long

    If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
        Insert = -1
        Exit Function
    End If

    MoveUp ipIndex, 1
    
    If VBA.IsObject(ipItem) Then
        Set s.Host(ipIndex) = ipItem
    Else
        s.Host(ipIndex) = ipItem
    End If
  
    Insert = ipIndex

End Function

Public Function InsertItems(ByVal ipIndex As Long, ParamArray ipParamArray() As Variant) As SeqA

    If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
        Set InsertItems = Me
        Exit Function
    End If
    
    If ArrayInfo.LacksItems(VBA.CVar(ipParamArray)) Then
        Set InsertItems = Me
        Exit Function
    End If
    
    Set InsertItems = InsertRange(ipIndex, VBA.CVar(ipParamArray))

End Function


Public Function InsertRange(ByVal ipIndex As Long, ByRef ipRange As Variant) As SeqA

    If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
        Set InsertRange = Me
        Exit Function
    End If

    Dim myGroupId As e_Group
    myGroupId = GroupInfo.Id(ipRange)
    GuardInvalidRangeObject myGroupId, ipRange, "VBALib.SeqA.InsertRange"
    
    Select Case myGroupId
        
        Case e_Group.m_string:         InsertRangeFromString ipIndex, VBA.CStr(ipRange)
        Case e_Group.m_array:          InsertRangeUsingForeach ipIndex, ipRange
        Case e_Group.m_List:           InsertRangeUsingForeach ipIndex, ipRange
        Case e_Group.m_Dictionary:      InsertRangeFromDictionary ipIndex, ipRange
        Case Else
        
    End Select

    Set InsertRange = Me
End Function


Private Sub InsertRangeFromString(ByRef ipIndex As Long, ByRef ipString As String)
    
    Dim myLen As Long
    myLen = VBA.Len(ipString)
    
    If myLen = 0 Then
        Exit Sub
    End If
    
    MoveUp ipIndex, myLen
     
    Dim myStrIndex As Long
    For myStrIndex = 1 To myLen
        s.Host(ipIndex + myStrIndex - 1) = VBA.Mid$(ipString, myStrIndex, 1)
    Next
    
End Sub


Private Sub InsertRangeUsingForeach(ByRef ipIndex As Long, ByRef ipForEach As Variant)
    
    Dim myLen As Long
    If ArrayInfo.IsArray(ipForEach) Then
        myLen = ArrayInfo.Count(ipForEach)
    Else
        myLen = ipForEach.Count
    End If
    
    If myLen < 1 Then
        Exit Sub
    End If
    
    Dim mySeqIndex As Long
    mySeqIndex = ipIndex
    
    MoveUp ipIndex, myLen
    
    Dim myItem As Variant
    For Each myItem In ipForEach
        If VBA.IsObject(myItem) Then
            Set s.Host(mySeqIndex) = myItem
        Else
            s.Host(mySeqIndex) = myItem
        End If
        mySeqIndex = mySeqIndex + 1
    Next
   
End Sub


Private Sub InsertRangeFromDictionary(ByRef ipIndex As Long, ByRef ipD As Variant)
    
    If ipD.Count < 1 Then
        Exit Sub
    End If
    
    Dim mySeqIndex As Long
    mySeqIndex = ipIndex
    
    MoveUp ipIndex, ipD.Count
    
    Dim myKey As Variant
    For Each myKey In ipD.Keys
        s.Host(mySeqIndex) = Array(myKey, ipD.Item(myKey))
        mySeqIndex = mySeqIndex + 1
    Next
    
End Sub


'@Description("Removes the first encountered item from the SeqA")
Public Function Remove(ParamArray ipParamArray() As Variant) As SeqA

    If s.LastIndex < 1 Then
        Set Remove = Me
        Exit Function
    End If
    
    If ArrayInfo.LacksItems(VBA.CVar(ipParamArray)) Then
        Set Remove = Me
        Exit Function
    End If
    
    Dim myItem As Variant
    For Each myItem In ipParamArray
    
        Dim myIndex As Long
        myIndex = IndexOf(myItem)
        
        If myIndex > 0 Then
            MoveDown myIndex, 1
        End If
        
   Next
   
    Set Remove = Me
    
End Function


'@Description("Removes the first encountered item from the SeqA")
Public Function RemoveAt(ParamArray ipParamArray() As Variant) As SeqA

    If s.LastIndex < 1 Then
        Set RemoveAt = Me
        Exit Function
    End If
    
     If ArrayInfo.LacksItems(VBA.CVar(ipParamArray)) Then
        Set RemoveAt = Me
        Exit Function
    End If
    
    Dim mySorted As Variant
    mySorted = VBA.CVar(ipParamArray)
    Sorters.ShakerSortArray mySorted
    
    Dim myIndex As Long
    For myIndex = UBound(mySorted) To LBound(mySorted) Step -1
        MoveDown VBA.CLng(mySorted(myIndex)), 1
    Next
  
    Set RemoveAt = Me
    
End Function


'@Description("Remove items in the specified range of Indexes")
Public Function RemoveRange(ByRef ipSeq As SeqA) As SeqA
  
    If s.LastIndex < 1 Then
        Set RemoveRange = Me
        Exit Function
    End If
  
    If ipSeq.Count < 1 Then
        Set RemoveRange = Me
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = ipSeq.FirstIndex To ipSeq.LastIndex
        MoveDown IndexOf(ipSeq.Item(myIndex)), 1
    Next
    
    Set RemoveRange = Me
        
End Function


'@Description("Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use")
Public Function RemoveAtRange(ByRef ipSeq As SeqA) As SeqA
  
    If s.LastIndex < 1 Then
        Set RemoveAtRange = Me
        Exit Function
    End If
    
    If ipSeq.Count < 1 Then
        Set RemoveAtRange = Me
        Exit Function
    End If

    ipSeq.Sort.Reverse
    
    Dim myIndex As Long
    For myIndex = ipSeq.FirstIndex To ipSeq.LastIndex
        MoveDown ipSeq.Item(myIndex), 1
    Next
    
    Set RemoveAtRange = Me
        
End Function


Public Function RemoveAll(ParamArray ipParamArray() As Variant) As SeqA

    If ArrayInfo.LacksItems(VBA.CVar(ipParamArray)) Then
        s.LastIndex = 0
        Resize
    Else
    
        Dim myItem As Variant
        For Each myItem In ipParamArray
            RemoveAllSingleItem myItem
        Next
        
    End If
   
    Set RemoveAll = Me
    
End Function


Private Sub RemoveAllSingleItem(ByRef ipItem As Variant)

    Dim myIndex As Long
    For myIndex = s.LastIndex To 1 Step -1
        If ComparerHelpers.Equals(s.Host(myIndex), ipItem) Then
            MoveDown myIndex, 1
        End If
    Next
    
End Sub

'@("Removes all Items from the SeqA")
Public Function Clear() As SeqA
    Set Clear = RemoveAll
End Function


'@("Removes all Items by replacing the Host collection with a new collection")
Public Function Reset() As SeqA
    ReDim s.Host(FIRST_INDEX To DEFAULT_CHUNK)
    s.LastIndex = 0
    Set Reset = Me
End Function


Public Function Fill(ByRef ipItem As Variant, Optional ByVal ipCount As Long = 1) As SeqA

    If ipCount < 1 Then
        Set Fill = Me
        Exit Function
    End If
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        If VBA.IsObject(ipItem) Then
            Set s.Host(GetNextIndex) = ipItem
        Else
            s.Host(GetNextIndex) = ipItem
        End If
    Next
    
    Set Fill = Me
    
End Function


'@Description("Returns the first N items of the SeqA, Default 1")
Public Function Head(Optional ByVal ipSplitAfter As Long = 1) As SeqA
    
    If s.LastIndex <= 1 Then
        Set Head = SeqA.Deb
        Exit Function
    End If

    If ipSplitAfter < 1 Then
        Set Head = SeqA.Deb
        Exit Function
    End If
    
    If ipSplitAfter >= s.LastIndex Then
        Set Head = Me.Clone
        Exit Function
    End If
    
    Set Head = Me.Slice(1, ipSplitAfter)

End Function


'@Description("Returns the Items after SplitAfter, Default is Index 2")
Public Function Tail(Optional ByVal ipSplitAfter As Long = 1) As SeqA

    If s.LastIndex < 1 Then
        Set Tail = SeqA.Deb
        Exit Function
    End If
    
    If ipSplitAfter < 1 Then
        Set Tail = Me.Clone
        Exit Function
    End If
    
    If ipSplitAfter >= s.LastIndex Then
        Set Tail = SeqA.Deb
        Exit Function
    End If
    
    Set Tail = Me.Slice(ipSplitAfter + 1)

End Function

Public Function HoldsItem(ByRef ipItem As Variant) As Boolean

    If s.LastIndex < 1 Then
        HoldsItem = False
    End If

    Dim myIndex As Long
    For myIndex = FIRST_INDEX To s.LastIndex
        If ComparerHelpers.Equals(s.Host(myIndex), ipItem) Then
            HoldsItem = True
            Exit Function
        End If
    Next

    HoldsItem = False
    
End Function

Public Function Contains(ByRef ipItem As Variant) As Boolean
    Contains = Me.HoldsItem(ipItem)
End Function

Public Function LacksItem(ByRef ipItem As Variant) As Boolean
    LacksItem = Not HoldsItem(ipItem)
End Function
'
'
''@Description("Makes a shallow copy of the SeqA to the provided array")
'Public Function CopyTo(ByRef ipArray As pArray) As SeqA
'
''    ' Dim myArray As Variant = ipoArr.Cargo
''     If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''     If Guard.LacksItems(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''     If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''     'If Guard.SizeMismatch(s.LastIndex > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
'    If Var.LacksItems(ipArray.Cargo) Then
'        Return Me
'    End If
'
'    Dim myIndex  As Long
'    For myIndex = FirstIndex To LastIndex
'
'        Dim myItem As Variant = s.Host(myIndex)
'
'        If VBA.IsObject(myItem) Then
'            Set ipArray.Cargo(myIndex) = myItem
'        Else
'            ipArray.Cargo(myIndex) = myItem
'        End If
'
'        If myIndex > Var.LastIndex(ipArray.Cargo) Then
'            Exit For
'        End If
'    Next
'
'    Return Me
'
'End Function
'
'
'Public Function CopyTo(ByRef ipArray As pArray, ByVal ipArrayStartIndex As Long) As SeqA
'
'    '  ' Dim myArray As Variant = ipoArr.Cargo
'    ' If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' If Guard.LacksItems(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' 'If Guard.SizeMismatch(s.LastIndex > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
'
'    Dim myArrayIndex  As Long = ipArrayStartIndex
'
'    Dim myHostIndex As Long
'    For myHostIndex = FirstIndex To LastIndex
'        Dim myItem As Variant = s.Host(myHostindex)
'
'        If VBA.IsObject(myItem) Then
'            Set ipArray.Cargo(myArrayIndex) = myItem
'        Else
'            ipArray.Cargo(myArrayIndex) = myItem
'        End If
'
'        myArrayIndex += 1
'        If myArrayIndex >= Var.LastIndex(ipArray.Cargo) Then
'            Exit For
'        End If
'    Next
'
'    Return Me
'
'End Function
'
'Public Function CopyTo _
'() '( _
'    ByVal ipSeqStartIndex As Long, _
'    ByRef ipArray As pArray, _
'    ByVal ipArrayStartIndex As Long, _
'    ByVal ipArrayCount As Long _
') As SeqA IMplements SeqA.CopyTo
'
'    '  ' Dim myArray As Variant = ipoArr.Cargo
'    ' If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' If Guard.LacksItems(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' 'If Guard.SizeMismatch(s.LastIndex > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
'
'    Dim myArrayIndex  As Long = ipArrayStartIndex
'
'    Dim myHostIndex As Long
'    For myHostIndex = ipSeqStartIndex - 1 To LastIndex
'        Dim myItem As Variant = s.Host.Item(myHostIndex)
'
'        If VBA.IsObject(myItem) Then
'            Set ipArray.Cargo(myArrayIndex) = myItem
'        Else
'            ipArray.Cargo(myArrayIndex) = myItem
'        End If
'
'        myArrayIndex += 1
'
'        If myArrayIndex > Var.LastIndex(ipArray.Cargo) Then
'            Exit For
'        End If
'
'    Next
'
'    Return Me
'
'End Function
'
'Public Function GetRange(ByVal ipStartIndex As Long, Optional ByVal ipRun As pNum = Nothing, ByVal ipEndIndex As pNum = Nothing) As SeqA Implements SeqA.GetRange
'    Return Slice(PN(ipStartIndex), ipRun, ipEndIndex)
'End Function
'
'
'
'
'
'
'
'
'
'
'
'
Public Property Get myTypename() As String
   myTypename = MY_TYPENAME
End Property
'
'
'
'
'Public Function SplitAt(ByVal ipIndex As Long, Optional ByVal ipSplitType As e_SeqSplit = e_SeqSplit.m_Before) As SeqA
'
'    Dim mySer As SER = Ranges.ResolveStartEndRun(FirstIndex, LastIndex, ipIndex)
'
'    Dim mySplit As SeqA
'    If ipSplitType = m_Before Then
'         Set mySplit = SeqA.Deb.AddItems(PL(Me.Slice(PN(1), PN(mySER.NativeStart - 1)), Me.Slice(PN(mySER.NativeStart))))
'    Else
'        Set mySplit = SeqA.Deb.AddItems(PL(Me.Slice(PN(1), PN(mySER.NativeStart)), Me.Slice(PN(mySER.NativeStart + 1))))
'
'    End If
'    Return mySplit
'
'
'End Function
'
''@DescriptiPN("Splits the SeqA at the first occurence of ipItem")
'Public Function SplitAtItem(ByVal ipItem As Variant, Optional ByVal ipSplitType As e_SeqSplit = e_SeqSplit.m_Before) As SeqA
'    Dim mySplit As SeqA
'    Dim myItems As IterItems = IterItems(Me)
'    Do
'
'        If myItems.GetItem = ipItem.Cargo Then
'            Dim myIndex As Long = myItems.Key(0).cargo
'            If ipSplitType = e_SeqSplit.m_Before Then
'                Set mySplit = SeqA.Deb.AddItems(PL(Me.Slice(PN(1), PN(myIndex - 1)), Me.Slice(PN(myIndex))))
'            Else
'                Set mySplit = SeqA.Deb.AddItems(PL(Me.Slice(PN(1), PN(myIndex)), Me.Slice(PN(myIndex + 1))))
'            End If
'        End If
'
'    Loop While myItems.MoveNext
'
'End Function
'

'

'
'@Description("Moves all elements from ipIndex to s.lastindex down by ipCount places")
Private Sub MoveDown(ByVal ipToIndex As Long, ByVal ipCount As Long)
Attribute MoveDown.VB_Description = "Moves all elements from ipIndex to s.lastindex down by ipCount places"

    If ipCount < 1 Then
        Exit Sub
    End If

    ' If ipIndex < FirstIndex Or ipIndex > s.LastIndex Then
    '     Exit Sub
    ' End If

    Dim myToIndex As Long
    myToIndex = ipToIndex

    Dim myFromIndex As Long
    For myFromIndex = ipToIndex + ipCount To s.LastIndex

        If VBA.IsObject(s.Host(myFromIndex)) Then
            Set s.Host(myToIndex) = s.Host(myFromIndex)
        Else
            s.Host(myToIndex) = s.Host(myFromIndex)
        End If
       ' s.host(myFromIndex) = Empty
        myToIndex = myToIndex + 1


    Next
    Dim myIndex As Long
    For myIndex = s.LastIndex - ipCount + 1 To s.LastIndex
        s.Host(myIndex) = Empty
    Next
    s.LastIndex = s.LastIndex - ipCount

End Sub
'
'@Description("Moves all elements from ipIndex to s.lastindex up by ipCount places")
Private Sub MoveUp(ByVal ipIndex As Long, Optional ByVal ipCount As Long = 1)
Attribute MoveUp.VB_Description = "Moves all elements from ipIndex to s.lastindex up by ipCount places"

    If ipCount < 1 Then
        Exit Sub
    End If

    If ipIndex < FirstIndex Or ipIndex > s.LastIndex Then
        Exit Sub
    End If


    Do While s.LastIndex + ipCount > s.Size
        DoEvents
        s.Size = s.Size + DEFAULT_CHUNK
        Resize

    Loop

    Dim myToIndex As Long
    myToIndex = s.LastIndex + ipCount
    Dim myFromIndex As Long
    myFromIndex = s.LastIndex

    Dim myIterations As Long
    For myIterations = 0 To s.LastIndex - ipIndex

        Swap myToIndex - myIterations, myFromIndex - myIterations

    Next

    s.LastIndex = s.LastIndex + ipCount

End Sub


Public Function MapIt(ByVal ipMapper As IMapper) As SeqA

    Dim myS As SeqA
    Set myS = SeqA.Deb

    Dim myIndex As Long
    For myIndex = FIRST_INDEX To s.LastIndex
        myS.Add ipMapper.ExecMapper(s.Host(myIndex))(0)
    Next

    Set MapIt = myS

End Function

Public Function FilterIt(ByVal ipComparer As IComparer) As SeqA

    Dim myS As SeqA
    Set myS = SeqA.Deb

    Dim myIndex As Long
    For myIndex = FIRST_INDEX To s.LastIndex
    
        If ipComparer.ExecCmp(s.Host(myIndex)) Then
            myS.Add s.Host(myIndex)
        End If
        
    Next

    Set FilterIt = myS

End Function

' Does not generate an interim SeqA as would filterIt followed by Count.
Public Function CountIt(ByVal ipComparer As IComparer) As Long

    Dim myCount As Long
    myCount = 0

    Dim myIndex As Long
    For myIndex = FIRST_INDEX To s.LastIndex
    
        If ipComparer.ExecCmp(s.Host(myIndex)) Then
            myCount = myCount + 1
        End If
        
    Next

    CountIt = myCount

End Function

'@DescriptiPN("Returns a single Host based on the Reducer").
Public Function ReduceIt(ByRef ipReducer As IReducer) As Variant
    'ReduceIt = ipReducer.ExecReduction(Me)
    Dim myItem As Variant
    myItem = Array(ipReducer.ExecReduction(Me))
    
    If VBA.IsObject(myItem(0)) Then
       Set ReduceIt = myItem(0)
    Else
        ReduceIt = myItem(0)
    End If
    
End Function
'
'@DescriptiPN("Returns the item at FirstIndex")
Public Property Get First() As Variant

    GuardInvalidIndex 1, s.LastIndex, "VBALib.SeqA.Get_First"
    
    If VBA.IsObject(s.Host(FIRST_INDEX)) Then
        Set First = s.Host(FIRST_INDEX)
    Else
        First = s.Host(FIRST_INDEX)
    End If
    
End Property

'@Description("Assigns to the Item at FirstIndex")
Public Property Let First(ByRef ipItem As Variant)

    GuardInvalidIndex 1, s.LastIndex, "VBALib.SeqA.Let_First"
    
    s.Host(FIRST_INDEX) = ipItem
    
End Property

'@Description("Assigns to the Item at FirstIndex")
Public Property Set First(ByRef ipItem As Variant)

    GuardInvalidIndex 1, s.LastIndex, "VBALib.SeqA.Set_First"
    
    Set s.Host(FIRST_INDEX) = ipItem
    
End Property

'@Description("Returns the Item at LastIndex")
Public Property Get Last() As Variant

    GuardInvalidIndex s.LastIndex, s.LastIndex, "VBALib.SeqA.Set_Last"

    If VBA.IsObject(s.Host(s.LastIndex)) Then
        Set Last = s.Host(s.LastIndex)
    Else
        Last = s.Host(s.LastIndex)
    End If
    
End Property

'@Description("Assigns to the Item at LastIndex")
Public Property Let Last(ByRef ipItem As Variant)

    GuardInvalidIndex s.LastIndex, s.LastIndex, "VBALib.SeqA.Let_Last"

    s.Host(s.LastIndex) = ipItem
    
End Property

'@Descriotion("Assigns to the item at LastIndex")
Public Property Set Last(ByRef ipItem As Variant)

    GuardInvalidIndex s.LastIndex, s.LastIndex, "VBALib.SeqA.Set_Last"

    Set s.Host(s.LastIndex) = ipItem
    
End Property

'@Description("Returns the item at First but one Index")
Public Property Get FBO() As Variant

   GuardInvalidIndex 2, s.LastIndex, "VBALib.SeqA.Get_FBO"
   
   Dim FBOIndex As Long
   FBOIndex = FIRST_INDEX + 1
   
   If VBA.IsObject(s.Host(FBOIndex)) Then
       Set FBO = s.Host(FBOIndex)
   Else
       FBO = s.Host(FBOIndex)
   End If
   
End Property

'@Description("Assigns to the Item at First but one Index")
Public Property Let FBO(ByVal ipItem As Variant)

   GuardInvalidIndex 2, s.LastIndex, "VBALib.SeqA.Let_FBO"
       
   Set Me.Item(FIRST_INDEX + 1) = ipItem
   
End Property

'@Description("Assigns to the Item at First but one Index")
Public Property Set FBO(ByVal ipItem As Variant)

   GuardInvalidIndex 2, s.LastIndex, "VBALib.SeqA.Set_FBO"
   
   Set Me.Item(FirstIndex + 1) = ipItem
   
End Property

'@Description("Returns the Item at Lastbut one Index")
Public Property Get LBO() As Variant

   GuardInvalidIndex 2, s.LastIndex, "VBALib.SeqA.Let_FBO"
   
   Dim myLBOIndex As Long
   myLBOIndex = s.LastIndex - 1
   
    If VBA.IsObject(s.Host(myLBOIndex)) Then
       Set LBO = s.Host(myLBOIndex)
   Else
       LBO = s.Host(myLBOIndex)
   End If
   
End Property


'@Description("Assigns to the Item at Last but one Index")
Public Property Let LBO(ByVal ipItem As Variant)

   GuardInvalidIndex 2, s.LastIndex, "VBALib.SeqA.Let_FBO"
   
   Me.Item(s.LastIndex - 1) = ipItem
   
End Property


'@Description("Assigns to the item at Last but one Index")
Public Property Set LBO(ByVal ipItem As Variant)

   GuardInvalidIndex 2, s.LastIndex, "VBALib.SeqA.Let_FBO"

   Set Me.Item(s.LastIndex - 1) = ipItem
    
End Property

''Public Property Get Capacity() As Long
''    Capacity = s.Size
''End Property
''
'''@("Resizes the host array to the specifies capacity, existing Hosts in the capacity range are preserved")
''Public Property Let Capacity(ByVal ipCapacity As Long)
''    s.Size = ipCapacity
''    Resize
''End Property
'
'
'@DescriptiPN("Returns the index of the Item")
Public Function IndexOf _
( _
    ByVal ipItem As Variant, _
    Optional ByVal ipStart As Long = 1, _
    Optional ByVal ipRun As Long = -1 _
) As Long
    
    If s.LastIndex < 1 Then
        IndexOf = -1
        Exit Function
    End If
    
    GuardIndexOutOfBounds ipStart, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.IndexOf"
    
    Dim myRun As Long
    myRun = ipRun
    If myRun = -1 Then
        myRun = s.LastIndex - ipStart + 1
    Else
        GuardIndexOutOfBounds myRun, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.IndexOf"
    End If
    
    Dim myIndex As Long
    For myIndex = ipStart To ipStart + myRun - 1
        If ComparerHelpers.Equals(s.Host(myIndex), ipItem) Then
            IndexOf = myIndex
            Exit Function
        End If
    Next
    
    IndexOf = -1
End Function

Public Function LastIndexOf _
( _
    ByVal ipItem As Variant, _
    Optional ByVal ipStart As Long = 1, _
    Optional ByVal ipRun As Long = -1 _
) As Long
    
    If s.LastIndex < 1 Then
        LastIndexOf = -1
        Exit Function
    End If
    
    GuardIndexOutOfBounds ipStart, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.LastIndexOf"
    
    Dim myRun As Long
    myRun = ipRun
    If myRun = -1 Then
        myRun = s.LastIndex - ipStart + 1
    Else
        GuardIndexOutOfBounds myRun, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.LastIndexOf"
    End If
    
    Dim myIndex As Long
    For myIndex = ipStart + myRun - 1 To ipStart Step -1
        If s.Host(myIndex) = ipItem Then
            LastIndexOf = myIndex
            Exit Function
        End If
    Next
    
    LastIndexOf = -1
    
End Function

'Public Function Join(ByVal ipSeparator As String) As String
'
'    On Error Resume Next
'    Dim myString As String = VBA.Join(Me.ToArray, ipSeparator)
'    On Error GoTo 0
'    Return myString
'
'End Function
'
'Public Function Join() As String IMplements SeqA.JOin
'
'    On Error Resume Next
'    Dim myString As String = VBA.Join(Me.ToArray, chars.twcomma)
'    On Error GoTo 0
'    Return myString
'
'End Function
'
'Private Function TrimToSize() As SeqA
'    If s.LastIndex > 0 Then
'        ReDim Preserve s.Host(FirstIndex To s.LastIndex)
'    End If
'    Return Me
'End Function
'
'
Private Sub Resize()
    If s.Size < 1 Then
        ReDim Preserve s.Host(FIRST_INDEX To DEFAULT_CHUNK)
    Else
        ReDim Preserve s.Host(FIRST_INDEX To s.Size)
    End If

    ' The last index is not set here because it depends on the context where
    ' resize was called
    ' Last index should be adjusted at the calling site.
End Sub


Public Function Push(ParamArray ipParamArray() As Variant) As SeqA
     Set Push = AddRange(VBA.CVar(ipParamArray))
End Function


Public Function PushRange(ByRef ipRange As Variant) As SeqA
    Set PushRange = AddRange(ipRange)
End Function


Public Function Pop() As Variant

    Dim myLastIndex As Long
    myLastIndex = s.LastIndex
    
    Dim myItem As Variant
    myItem = Array(s.Host(myLastIndex))
    
    If VBA.IsObject(myItem(0)) Then
        Set Pop = myItem(0)
    Else
        Pop = myItem(0)
    End If
    
    MoveDown myLastIndex, 1
    
End Function

Public Function PopRange(Optional ByVal ipCount As Long = 1) As SeqA

    If ipCount < 0 Then
        Set PopRange = SeqA.Deb
        Exit Function
    End If
    
    If ipCount > s.LastIndex Then
        Set PopRange = Me.Reversed
        Me.RemoveAll
        Exit Function
    End If
    
    Dim myS As SeqA
    Set myS = SeqA.Deb
    
    Dim myIndex As Long
    For myIndex = s.LastIndex To s.LastIndex - ipCount + 1 Step -1
        myS.Add s.Host(myIndex)
    Next
    
    MoveDown myIndex + 1, ipCount
    
    Set PopRange = myS
    
End Function


Public Function enQueue(ParamArray ipParamArray() As Variant) As SeqA
   Set enQueue = AddRange(VBA.CVar(ipParamArray))
End Function


Public Function EnqueueRange(ByRef ipRange As Variant) As SeqA
   Set EnqueueRange = AddRange(ipRange)
End Function

Public Function Dequeue() As Variant
    
    Dim myItem As Variant
    myItem = Array(s.Host(FIRST_INDEX))
    
    If VBA.IsObject(myItem(0)) Then
        Set Dequeue = myItem(0)
    Else
        Dequeue = myItem(0)
    End If
    
    MoveDown FIRST_INDEX, 1
    
End Function


Public Function DequeueRange(Optional ByVal ipCount As Long = 1) As SeqA

    If ipCount < 0 Then
        Set DequeueRange = SeqA.Deb
        Exit Function
    End If
    
    If ipCount > s.LastIndex Then
        Set DequeueRange = Me.Clone
        Me.RemoveAll
        Exit Function
    End If
    
    Dim myS As SeqA
    Set myS = SeqA.Deb
    
    Dim myIndex As Long
    For myIndex = FIRST_INDEX To ipCount
        myS.Add s.Host(myIndex)
    Next
    
    MoveDown FIRST_INDEX, ipCount
    
    Set DequeueRange = myS
    
End Function
'Public Function RotL(Optional ByVal ipCount As Long = 1) As SeqA
'    Dim myCount As Long
'    For myCount = 1 To ipCount
'        AddItems Dequeue
'    Next
'    Return Me
'End Function
'
'Public Function RotR(Optional ByVal ipCount As Long = 1) As SeqA
'    Dim myCount As Long
'    For myCount = 1 To ipCount
'        Insert 1, Pop
'    Next
'    Return Me
'End Function
'

'Public Function Sort() As SeqA
'     Sorters.ShakerSortSeq Me
'     Set Sort = Me
' End Function
''
'Public Function Sorted() As SeqA
'    Dim myS As SeqA
'    Set myS = Me.Clone
'    Sorters.ShakerSortSeq myS
'    Set Sorted = myS
'End Function
'
'Private Sub QuickSort1(ByRef iopSortable As Variant, Optional ByVal ipLeft As Long, Optional ByVal ipRight As Long)
'
'    Dim myFirst As Long
'    Dim myLast As Long
'    Dim myMid As Variant
'    Dim mySwap As Variant
'
'    'Dim iopSortable.Cargo As Meta = Meta.Deb(iopSortable)
'    'Dim myReversible As Meta = Meta.Deb(iopSortable)
'
'    ' Dim iopSortable.Cargo As Variant
'    ' If ArrayInfo.IsArray(iopSortable) Then
'    '     Set iopSortable.Cargo = ListArray.Deb(iopSortable)
'    ' Else
'    '     Set iopSortable.Cargo = iopSortable
'    ' End If
'
'
'    If ipRight = 0 Then
'        ipLeft = iopSortable.Cargo.FirstIndex(1) 'LBound(iopSortable)
'        ipRight = iopSortable.Cargo.LastIndex(1) 'UBound(iopSortable)
'    End If
'    myFirst = ipLeft
'    myLast = ipRight
'    myMid = iopSortable.Cargo.Item((ipLeft + ipRight) \ 2)
'    Do
'        Do While iopSortable.Cargo.Item(myFirst) < myMid And myFirst < ipRight
'            myFirst += 1
'        Loop
'        Do While myMid < iopSortable.Cargo.Item(myLast) And myLast > ipLeft
'            myLast -= 1
'        Loop
'
'        If myFirst <= myLast Then
'
'            If VBA.IsObject(iopSortable.Cargo.Item(myFirst)) Then
'                Set mySwap = iopSortable.Cargo.Item(myFirst)
'                Set iopSortable.Cargo.Item(myFirst) = iopSortable.Cargo.Item(myLast)
'                Set iopSortable.Cargo.Item(myLast) = mySwap
'            Else
'                mySwap = iopSortable.Cargo.Item(myFirst)
'                iopSortable.Cargo.Item(myFirst) = iopSortable.Cargo.Item(myLast)
'                iopSortable.Cargo.Item(myLast) = mySwap
'            End If
'            myFirst += 1
'            myLast -= 1
'        End If
'    Loop Until myFirst > myLast
'    If ipLeft < myLast Then
'        QuickSort1 iopSortable.Cargo, ipLeft, myLast
'    End If
'    If myFirst < ipRight Then
'        QuickSort1 iopSortable, myFirst, ipRight
'    End If
'End Sub
'
'Public Function Swap(ByRef ipLHS As Long, ByVal ipRHS As Long) As SeqA
'    Dim myTmp As Variant
'    If VBA.IsObject(s.Host(ipLHS)) Then
'        Set myTmp = s.Host(ipLHS)
'    Else
'        myTmp = s.Host(ipLHS)
'    End If
'
'    If VBA.IsObject(s.Host(ipRHS)) Then
'        Set s.Host(ipLHS) = s.Host(ipRHS)
'    Else
'        s.Host(ipLHS) = s.Host(ipRHS)
'    End If
'    If VBA.IsObject(myTmp) Then
'        Set s.Host(ipRHS) = myTmp
'    Else
'        s.Host(ipRHS) = myTmp
'    End If
'
'    Return Me
'End Function
'
'Public Function Reverse() As SeqA
'
'    ' we need to reverse in place
'
'    Dim myArray As Variant
'    ReDim myArray(LBound(s.Host, 1) To UBound(s.Host, 1))
'
'
'    Dim myindex As Long = 1
'    Dim myReverseIndex As Long
'    For myReverseIndex = LastIndex To FirstIndex Step -1
'
'        myArray(myReverseIndex) = s.Host(myIndex)
'        myindex += 1
'    Next
'
'    s.Host = myArray
'    ' Dim myReversed As SeqA = SeqA.Deb
'    ' Dim myItems As IterItems = IterItems.Deb(Me).MoveToEnd
'    ' Do
'    '   myReversed.Add myItems(0)
'    ' Loop While myItems.MovePrev
'     Return Me
'
'End Function
'
'' Public Function Set(ByVal ipSet As SetOf, ipParam As SeqA) As SeqA
''     Return Cops.Set(ipSet, Me, ipParam)
'' End Function
'
' Public Function SetOf(ByVal ipSet As e_Set, ipLHS As SeqA, ByRef ipRHS As oContainer) As SeqA
'
'        ' Dim myLHS As SeqA = SeqA.Deb(ipLHS)
'        ' Dim myRHS As SeqA = SeqA.Deb(ipRHS)
'
'        Select Case ipSet
'
'            Case e_Set.m_Both:              Return Both(ipLHS, ipRHS)
'            Case e_Set.m_HostOnly:          Return LHSOnly(ipLHS, ipRHS)
'            Case e_Set.m_ParamOnly:         Return LHSOnly(ipRHS, ipLHS) ' note reversal of params
'            Case e_Set.m_NotInBoth:           Return NotBoth(ipLHS, ipRHS)
'            Case e_Set.m_Unique:              Return MergeUnique(ipLHS, ipRHS)
'
'        End Select
'
'End Function
'
'
'
'
'Private Function LHSOnly(ByRef ipLHS As oContainer, ByRef ipRHS As oContainer) As SeqA
'    ' Dim myLHSIsKvp As Boolean = Var.IsItemByKey(ipLHS)
'    ' Dim myRHSIsKvp As Boolean = Var.IsItemByKey(ipRHS)
'    ' Dim myResult As SeqA = SeqA.Deb
'    ' Dim myH As IterItems = IterItems(ipLHs.host)
'    ' Do
'    '     If myLHSIsKvp Then
'
'
'    '     Dim myItem As Variant = myH.GetItem
'    '     If ipRHs.host.LacksItem(myItem) And myResult.LacksItem(myItem) Then
'    '         myResult.Add myItem
'    '     End If
'
'    ' Loop While myH.MoveNext
'
'    ' Return myResult
'
'End Function
'
'Private Function Both(ByRef ipLHS As SeqA, ByRef ipRHS As oContainer) As SeqA
'
'    Dim myResult As SeqA = SeqA.Deb
'
'    Dim myLHS As IterItems = IterItems(ipLHS)
'    Do
'        Dim myItem As Variant = myLHS.GetItem
'        If ipRHS.Cargo.HoldsItem(myItem) Then
'            myresult.Add Variant(myItem)
'        End If
'    Loop While myLHS.MoveNext
'
'    Return myResult
'
'End Function
'
'
'Private Function NotBoth(ByRef ipLHS As SeqA, ByRef ipRHS As oContainer) As SeqA
'
'    Return SeqA.Deb(PC(Me.LHSOnly(ipLHS, ipRHS))).Merge(PC(LHSOnly(ipRHS, ipLHS))) ' note the reversal of the parameters
'
'End Function
'
'Private Function MergeUnique(ByRef ipLHS As oContainer, ByRef ipRHS As oContainer) As SeqA
'
'    Dim myresult As SeqA = SeqA.Deb(ipLHS)
'    Dim myI As IterItems = IterItems(SeqA.Deb(ipRHS))
'    Do
'        Dim myItem As Variant = myI.GetItem
'        DoEvents
'        If myresult.Count = 0 Then
'            myresult.Add PV(myItem)
'        ElseIf myresult.LacksItem(PV(myItem)) Then
'            myresult.Add PV(myItem)
'        End If
'    Loop While myI.MoveNext
'    Return myresult
'End Function
'
'Public Function Merge(ByRef ioContainer As oContainer) As SeqA
'    Return Me.AddRange(ioContainer)
'End Function
'
'Public Function Host() As Variant Implements SeqA.Host
'    Return Items
'End Function
'
'Public Function IsUnique() As Boolean Implements SeqA.IsUnique
'
'    Dim myFreqs As KvpA = Me.Freq
'    Dim myIter As IterItems = IterItems(myFreqs)
'    Do
'
'        If myIter.GetItem > 1 Then
'
'            Return False
'
'        End If
'
'    Loop While myIter.MoveNext
'
'    Return True
'
'End Function
'
'Public Function IsNotUnique() As Boolean
'    Return Not IsUnique
'End Function
'
'
'Public Function Freq() As IKvp
'
'    Dim myKvp As IKvp = KvpA.Deb
'
'    Dim myIter As IterItems = IterItems(Me)
'    Do
'
'        If myKvp.HoldsKey(myIter.GetItem) Then
'
'            myKvp.Item(myIter.GetItem) += 1
'
'
'        Else
'
'            myKvp.Add PV(myIter.GetItem), PV(1)
'
'
'        End If
'
'    Loop While myIter.MoveNext
'
'    Return myKvp
'
'End Function
'
''@DescriptiPN(creates an KvpH of collections items where the items in the collection are bucketed based on the Host at an Index)
'Public Function Freq(ByVal ipIndex As Long) As IKvp
'
'    Dim myKvpH As IKvp = KvpA.Deb
'
'        Dim myIter As IterItems = IterItems(Me)
'        Do
'            Dim myItem As Variant = myIter.GetItem
'            If myKvpH.HoldsKey(myItem.Item(ipIndex)) Then
'
'                myKvpH.Item(myItem.Item(ipIndex)).Add myIter.GetItem
'
'
'            Else
'
'                myKvpH.Add PV(myItem.GetItem), PV(SeqA.Deb)
'
'
'            End If
'
'        Loop While myIter.MoveNext
'
'    Return myKvpH
'
'End Function

 Public Function Sort() As SeqA
 'first
     Sorters.ShakerSortSeq Me
     Set Sort = Me
 End Function
'
Public Function Sorted() As SeqA
    Dim myS As SeqA
    Set myS = Me.Clone
    Sorters.ShakerSortSeq myS
    Set Sorted = myS
End Function

' Private Sub ShakerSortUsingArray(ByRef iopArray As Variant)
'    ' from https://www.vbforums.com/showthread.php?473677-VB6-Sorting-algorithms-(sort-array-sorting-arrays)&p=2912324#post2912324
'    ' The shaker sort is used because it is the highest rated sort which is stable and inplace and which does not use recursion
'    Dim i As Long
'    Dim j As Long
'    Dim k As Long
'    Dim iMin As Long
'    Dim iMax As Long
'    Dim varSwap As Variant
'    Dim blnSwapped As Boolean
'
'    iMin = LBound(iopArray)
'    iMax = UBound(iopArray)
'    i = (iMax - iMin) \ 2 + iMin
'    Do While i > iMin
'        j = i
'        Do While j > iMin
'            For k = iMin To i - j
'                If iopArray(k) > iopArray(k + j) Then
'                    If VBA.IsObject(iopArray(k)) Then
'                        Set varSwap = iopArray(k)
'                    Else
'                        varSwap = iopArray(k)
'                    End If
'                    If VBA.IsObject(iopArray(k + j)) Then
'                        Set iopArray(k) = iopArray(k + j)
'                    Else
'                        iopArray(k) = iopArray(k + j)
'                    End If
'                    If VBA.IsObject(varSwap) Then
'                        Set iopArray(k + j) = varSwap
'                    Else
'                        iopArray(k + j) = varSwap
'                    End If
'                End If
'            Next
'            j = j \ 2
'        Loop
'        i = i \ 2
'    Loop
'    iMax = iMax - 1
'    Do
'        blnSwapped = False
'        For i = iMin To iMax
'            If iopArray(i) > iopArray(i + 1) Then
'                If VBA.IsObject(iopArray(i)) Then
'                    Set varSwap = iopArray(i)
'                Else
'                    varSwap = iopArray(i)
'                End If
'                If VBA.IsObject(iopArray(i + 1)) Then
'                    Set iopArray(i) = iopArray(i + 1)
'                Else
'                    iopArray(i) = iopArray(i + 1)
'                End If
'                If VBA.IsObject(varSwap) Then
'                    Set iopArray(i + 1) = varSwap
'                Else
'                    iopArray(i + 1) = varSwap
'                End If
'                blnSwapped = True
'            End If
'        Next i
'        If blnSwapped Then
'            blnSwapped = False
'            iMax = iMax - 1
'            For i = iMax To iMin Step -1
'                If iopArray(i) > iopArray(i + 1) Then
'                    If VBA.IsObject(iopArray(i)) Then
'                    Set varSwap = iopArray(i)
'                Else
'                    varSwap = iopArray(i)
'                End If
'                If VBA.IsObject(iopArray(i + 1)) Then
'                    Set iopArray(i) = iopArray(i + 1)
'                Else
'                    iopArray(i) = iopArray(i + 1)
'                End If
'                If VBA.IsObject(varSwap) Then
'                    Set iopArray(i + 1) = varSwap
'                Else
'                    iopArray(i + 1) = varSwap
'                End If
'                    blnSwapped = True
'                End If
'            Next i
'            iMin = iMin + 1
'        End If
'    Loop Until Not blnSwapped
'End Sub
'
'Private Sub ShakerSortUsingSeq(ByRef iopS As SeqA)
'    ' from https://www.vbforums.com/showthread.php?473677-VB6-Sorting-algorithms-(sort-array-sorting-arrays)&p=2912324#post2912324
'    ' The shaker sort is used because it is the highest rated sort which is stable and inplace and which does not use recursion
'    Dim i As Long
'    Dim j As Long
'    Dim k As Long
'    Dim iMin As Long
'    Dim iMax As Long
'    Dim varSwap As Variant
'    Dim blnSwapped As Boolean
'
'    iMin = iopS.FirstIndex
'    iMax = iopS.LastIndex
'    i = (iMax - iMin) \ 2 + iMin
'    Do While i > iMin
'        j = i
'        Do While j > iMin
'            For k = iMin To i - j
'                If iopS.Item(k) > iopS.Item(k + j) Then
'                    If VBA.IsObject(iopS.Item(k)) Then
'                        Set varSwap = iopS.Item(k)
'                    Else
'                        varSwap = iopS.Item(k)
'                    End If
'                    If VBA.IsObject(iopS.Item(k + j)) Then
'                        Set iopS.Item(k) = iopS.Item(k + j)
'                    Else
'                        iopS.Item(k) = iopS.Item(k + j)
'                    End If
'                    If VBA.IsObject(varSwap) Then
'                        Set iopS.Item(k + j) = varSwap
'                    Else
'                        iopS.Item(k + j) = varSwap
'                    End If
'                End If
'            Next
'            j = j \ 2
'        Loop
'        i = i \ 2
'    Loop
'    iMax = iMax - 1
'    Do
'        blnSwapped = False
'        For i = iMin To iMax
'            If iopS.Item(i) > iopS.Item(i + 1) Then
'                If VBA.IsObject(iopS.Item(i)) Then
'                    Set varSwap = iopS.Item(i)
'                Else
'                    varSwap = iopS.Item(i)
'                End If
'                If VBA.IsObject(iopS.Item(i + 1)) Then
'                    Set iopS.Item(i) = iopS.Item(i + 1)
'                Else
'                    iopS.Item(i) = iopS.Item(i + 1)
'                End If
'                If VBA.IsObject(varSwap) Then
'                    Set iopS.Item(i + 1) = varSwap
'                Else
'                    iopS.Item(i + 1) = varSwap
'                End If
'                blnSwapped = True
'            End If
'        Next i
'        If blnSwapped Then
'            blnSwapped = False
'            iMax = iMax - 1
'            For i = iMax To iMin Step -1
'                If iopS.Item(i) > iopS.Item(i + 1) Then
'                    If VBA.IsObject(iopS.Item(i)) Then
'                    Set varSwap = iopS.Item(i)
'                Else
'                    varSwap = iopS.Item(i)
'                End If
'                If VBA.IsObject(iopS.Item(i + 1)) Then
'                    Set iopS.Item(i) = iopS.Item(i + 1)
'                Else
'                    iopS.Item(i) = iopS.Item(i + 1)
'                End If
'                If VBA.IsObject(varSwap) Then
'                    Set iopS.Item(i + 1) = varSwap
'                Else
'                    iopS.Item(i + 1) = varSwap
'                End If
'                    blnSwapped = True
'                End If
'            Next i
'            iMin = iMin + 1
'        End If
'    Loop Until Not blnSwapped
'End Sub
'

'@Description("Swaps the Items at the specified indexes")
Public Function Swap(ByRef ipLHSIndex As Long, ByRef ipRHSIndex As Long) As SeqA

    Dim myTemp As Variant
    
    If VBA.IsObject(s.Host(ipLHSIndex)) Then
        Set myTemp = s.Host(ipLHSIndex)
    Else
        myTemp = s.Host(ipLHSIndex)
    End If
    
    If VBA.IsObject(s.Host(ipRHSIndex)) Then
        Set s.Host(ipLHSIndex) = s.Host(ipRHSIndex)
    Else
        s.Host(ipLHSIndex) = s.Host(ipRHSIndex)
    End If
    
    If VBA.IsObject(myTemp) Then
        Set s.Host(ipRHSIndex) = myTemp
    Else
        s.Host(ipRHSIndex) = myTemp
    End If

End Function



Public Function Reverse() As SeqA

    Dim myFirst As Long
    myFirst = 1
    
    Dim myLast As Long
    myLast = s.LastIndex
    
    Dim mySwap As Variant

    Do While myFirst < myLast
     
        If VBA.IsObject(s.Host(myFirst)) Then
            Set mySwap = s.Host(myFirst)
        Else
            mySwap = s.Host(myFirst)
        End If
        
        If VBA.IsObject(s.Host(myLast)) Then
            Set s.Host(myFirst) = s.Host(myLast)
        Else
            s.Host(myFirst) = s.Host(myLast)
        End If
        
        If VBA.IsObject(mySwap) Then
            Set s.Host(myLast) = mySwap
        Else
            s.Host(myLast) = mySwap
        End If
        
         myFirst = myFirst + 1
         myLast = myLast - 1
         
     Loop

     
    Set Reverse = Me

 End Function

 Public Function Reversed() As SeqA

     Dim myS As SeqA
     Set myS = SeqA.Deb
     
     Dim myIndex As Long
     For myIndex = s.LastIndex To 1 Step -1
        myS.Add s.Host(myIndex)
    Next
     
    Set Reversed = myS

 End Function
 
 '@Description("Returns the unique subset of the host SeqA")
Public Function Unique() As SeqA

    Dim myS As SeqA
    Set myS = SeqA.Deb
    
    Select Case s.LastIndex
    
        Case Is < 1:        Set Unique = myS
            
        Case 1:             Set Unique = Me.Clone

        Case Else

            Dim myIndex As Long
            For myIndex = FIRST_INDEX To s.LastIndex
                If myS.LacksItem(s.Host(myIndex)) Then
                    myS.Add s.Host(myIndex)
                End If
            Next
    
            Set Unique = myS
            
    End Select
    
End Function


Public Function SetOf(ByRef ipSet As e_SetoF, ByRef ipRangeItem As SeqA) As SeqA

    Select Case ipSet

        Case e_SetoF.m_Common:           Set SetOf = SetOfCommon(ipRangeItem)
        Case e_SetoF.m_HostOnly:         Set SetOf = SetOfHostOnly(ipRangeItem)
        Case e_SetoF.m_ParamOnly:        Set SetOf = SetOfParamOnly(ipRangeItem)
        Case e_SetoF.m_NotCommon:        Set SetOf = SetOfNotCommon(ipRangeItem)
        Case e_SetoF.m_Unique:           Set SetOf = SetofUnique(ipRangeItem)
        Case Else
            Err.Raise 17 + vbObjectError, _
                "VBALib.Seq.SetOf", _
                Fmt.Text("Invalid e_set member. Expecting {0} to {1}. Got {2}", e_SetoF.m_First, e_SetoF.m_Last, ipSet)
                
    End Select

 End Function


'Private Function ResolveSetOfRangeItem(ByRef ipRangeItem As Variant) As Variant
'
'    Dim myRangeItem As Variant
'
'    Select Case GroupInfo.Id(ipRangeItem)
'        Case e_Group.m_string:              myRangeItem = Array(SeqA.Deb(ipRangeItem))
'        Case e_Group.m_array:               myRangeItem = Array(ipRangeItem)
'        Case e_Group.m_List:                myRangeItem = Array(ipRangeItem)
'        Case e_Group.m_Dictionary:          myRangeItem = Array(SeqA.Deb(ipRangeItem))
'    End Select
'
'    ResolveSetOfRangeItem = myRangeItem
'
'End Function

Private Function SetOfCommon(ByRef ipRangeItem As SeqA) As SeqA

    Dim myS As SeqA
    Set myS = SeqA.Deb
    
    Dim myIndex As Long
    For myIndex = ipRangeItem.FirstIndex To ipRangeItem.LastIndex
        If myS.LacksItem(ipRangeItem.Item(myIndex)) Then
            If Me.HoldsItem(ipRangeItem.Item(myIndex)) Then
                myS.Add ipRangeItem.Item(myIndex)
            End If
        End If
    Next
    
    Set SetOfCommon = myS

End Function


    
Private Function SetOfHostOnly(ByRef ipRangeItem As SeqA) As SeqA

    Dim myS As SeqA
    Set myS = Me.Unique
    
    Dim myIndex As Long
    For myIndex = ipRangeItem.FirstIndex To ipRangeItem.LastIndex
    
        If myS.HoldsItem(ipRangeItem.Item(myIndex)) Then
            myS.Remove ipRangeItem.Item(myIndex)
        End If
        
    Next
    
    Set SetOfHostOnly = myS
    
    
End Function

Private Function SetOfParamOnly(ByRef ipRangeItem As SeqA) As SeqA
 
    Dim myS As SeqA
    Set myS = SeqA.Deb
    
    Dim myIndex As Long
    For myIndex = ipRangeItem.FirstIndex To ipRangeItem.LastIndex
    
        If Me.LacksItem(ipRangeItem.Item(myIndex)) Then
            myS.Add ipRangeItem.Item(myIndex)
        End If
        
    Next
    
    Set SetOfParamOnly = myS
    

End Function

Private Function SetOfNotCommon(ByRef ipRangeItem As SeqA) As SeqA

    Dim myS As SeqA
    Set myS = Me.Unique
    
    Dim myIndex As Long
    For myIndex = ipRangeItem.FirstIndex To ipRangeItem.LastIndex
    
        If myS.HoldsItem(ipRangeItem.Item(myIndex)) Then
            myS.RemoveAll ipRangeItem.Item(myIndex)
        Else
            myS.Add ipRangeItem.Item(myIndex)
        End If
        
    Next
    
    Set SetOfNotCommon = myS
    
End Function

Private Function SetofUnique(ByRef ipRangeItem As SeqA) As SeqA

    Dim myS As SeqA
    Set myS = Me.Unique
    
    Dim myIndex As Long
    For myIndex = ipRangeItem.FirstIndex To ipRangeItem.LastIndex
        If myS.LacksItem(ipRangeItem.Item(myIndex)) Then
            myS.Add ipRangeItem.Item(myIndex)
        End If
    Next

    Set SetofUnique = myS
    
End Function



 Public Function Freq() As KvpC

     Dim myKvp As KvpC
     Set myKvp = KvpC.Deb

    Dim myIndex As Long
    For myIndex = FIRST_INDEX To s.LastIndex
         If myKvp.Exists(s.Host(myIndex)) Then
             myKvp.Item(s.Host(myIndex)) = myKvp.Item(s.Host(myIndex)) + 1
         Else
             myKvp.Add s.Host(myIndex), 1
         End If

     Next

     Set Freq = myKvp

 End Function
'

