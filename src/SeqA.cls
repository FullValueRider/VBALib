VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "SeqA"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_Description = "SeqA is a Collection/ArrayList replacement. Items are stored in an Array.  Indexing is 1 based. Order of addition is preserved. Keys are not supported (See Kvp classes)"
'@PredeclaredId
'@Exposed
'@Folder("Seq")
'@ModuleDescription("SeqA is a Collection/ArrayList replacement. Items are stored in an Array.  Indexing is 1 based. Order of addition is preserved. Keys are not supported (See Kvp classes)")
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' Items are accessed using 1 based indexing
' Not enumerable via NewEnum (See Iteritems)
' Keys are not suportes (see Kvp classes)
' Preserves order of addition.
' Insertion at a defined position is supported
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
Option Explicit
' constants common to all seq classes
Private Const MY_TYPENAME                       As String = "SeqA"
Private Const FIRST_INDEX                       As Long = 1
Private Const WHOLE_SEQ                         As Long = -1
Private Const TO_LAST_INDEX                     As Long = 0
Private Const DEFAULT_STEP                      As Long = 1
Private Const LACKS_ITEMS                       As Long = -1
Private Const INDEX_OUT_OF_BOUNDS               As Long = -1
Private Const NOT_FOUND                         As Long = -1

' constants specific to class
Private Const DEFAULT_CHUNK                     As Long = 16&

Private Type State

    ' an array for the items
    Host()                                      As Variant
    ' The number of elements in the enderlying array
    ' when count exceed size, size is increase by DEFAULT_CHUNK
End Type

Private s                                       As State


Private Type Properties
    FirstIndex                                  As Long
    ' number of elements used in Host
    Count                                       As Long
    ' current maximum index for an element
    Size                                        As Long
End Type

Private p                                       As Properties

' Deb is a Factory method of the PredeclaredId which returns a new instance of SeqA
'=================================================================================
' The input for Deb is a ParamArray.
' The ParamArray is interpreted according to the folowing rules
' If the ParamArray contains no Items
' - An empty sequence (count = 0)
' If the ParamArray has 2 or more items
' - A SeqA of size equal to the ParamArray, items as generated by for each over the ParamArray
' If the ParamArray has a single Item
' - Number: Overrides the initial size (16) of the underlying Array.  Used to minimise the extent of redimming'
' - String: A SeqA whose capacity is the length of the string with one character per Item
' - Array: SeqA of items as provided by For Each over the array.  Multidimension arrays are flattened but the position in the original array can be calculated by the user if required. See also Bind
' - Dictionaries: a SeqA of key/value arrays as generated from for each on the Keys array.
' - Collection: The collection is copied to the Host collection.  There is no refererence link to the original collection (See Host Property)
' - Seq: A shallow copy of the input sequence
' - mscorlib Arraylist: Items as generated by for each on the arrylist
' - mscorlib Stack: Items as generated by for each on the stack
' - mscorlib Queue: Items as generated by for eac on the queue

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'Setup and reinitialisation methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

'@DefaultMember
Public Function Deb(ParamArray ipParamarray() As Variant) As SeqA
Attribute Deb.VB_UserMemId = 0
    With New SeqA
        Set Deb = .ConstructInstance(VBA.CVar(ipParamarray))
    End With
End Function

Friend Function ConstructInstance(ByRef ipFPA As Variant) As SeqA
    
    p.Count = 0
    p.FirstIndex = FIRST_INDEX
    p.Size = DEFAULT_CHUNK
    ReSize
        
    ' Check to see if we return a default 'empty' seq
    If ArrayOp.LacksItems(ipFPA) Then
        Set ConstructInstance = Me
        Exit Function
    End If
    
    ' ipParamArray contains one or more items depending on the input type.
    ' if the input contains only a single item we want to use that item
    ' else we want to treat the forwrded paramarray as a single array item
    
    Dim myItem As Variant
    If ArrayOp.HoldsOneItem(ipFPA) Then
        If VBA.IsObject(ipFPA(0)) Then
            Set myItem = ipFPA(0)
        Else
            myItem = ipFPA(0)
        End If
    Else
        myItem = ipFPA
    End If
    
    If GroupInfo.IsNumber(myItem) Then
        Set ConstructInstance = ConstructInstanceByNumber(myItem)
        Exit Function
    End If
    
    ' See the Bind method if mutability of an input array is required
    
    ' Resolve the items in the forwarded paramarray using the rules
    ' described above.
    Select Case True
    
        Case VBA.IsArray(myItem):               Set ConstructInstance = AddRange(ArrayOp.Linearise(myItem))
        Case GroupInfo.IsContainer(myItem):     Set ConstructInstance = AddRange(myItem)
        Case GroupInfo.IsString(myItem):        Set ConstructInstance = AddRange(myItem)
        Case Else:                              Set ConstructInstance = AddItems(myItem)
    End Select
    
End Function


Private Function ConstructInstanceByNumber(ByVal ipSize As Long) As SeqA
        
    If ipSize < DEFAULT_CHUNK Then
        p.Size = DEFAULT_CHUNK
    Else
        p.Size = ipSize
    End If
    
    ReSize
    Set ConstructInstanceByNumber = Me
    
End Function


'ToDo: Update to necessary memory jiggery pokery
'@Ignore EmptyMethod
Private Sub Class_Terminate()

    '    If s.HostCopy.VT = 0 Then
    '        Exit Sub
    '    Else
    '        CopyMemByVal ByVal VarPtr(s.Host), ByVal VarPtr(s.HostCopy), 16
    '    End If

End Sub

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Core methods - essential for making the class work and status of the object
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'@Description("Add a single item.  Returns the index at which the item was added for compatibility with the mscorlib ArrayList.")
Public Function Add(ByRef ipItem As Variant) As Long
Attribute Add.VB_Description = "Add a single item.  Returns the index at which the item was added for compatibility with the mscorlib ArrayList."

    Dim myIndex As Long: myIndex = GetNextIndex

    VariantCopy s.Host(myIndex), ipItem
'    If VBA.IsObject(ipItem) Then
'        Set s.Host(myIndex) = ipItem
'    Else
'        s.Host(myIndex) = ipItem
'    End If
    
    Add = myIndex
    
End Function


'@Description("Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer")
Public Function Count(Optional ByRef ipItem As Variant) As Long
Attribute Count.VB_Description = "Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer"

    Count = LACKS_ITEMS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If VBA.IsMissing(ipItem) Then
        Count = p.Count
        Exit Function
    End If
    
    Dim myCount As Long: myCount = 0
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
        If Comparers.EQ(s.Host(myIndex), ipItem) Then
            myCount = myCount + 1
        End If
    Next
    
    Count = myCount
    
End Function


'@Description("Inserts one or more items starting at ipIndex. Returns the index of the inserted item")
Public Function InsertAt(ByVal ipIndex As Long, ByVal ipItem As Variant) As Long
Attribute InsertAt.VB_Description = "Inserts one or more items starting at ipIndex. Returns the index of the inserted item"

    InsertAt = INDEX_OUT_OF_BOUNDS
    
    If Guard.IndexOutOfBounds(ipIndex, Me, "InsertAt", Guard.REPORT_BACK) Then
        Exit Function
    End If

    MoveUp ipIndex, 1
    
    If VBA.IsObject(ipItem) Then
        Set s.Host(ipIndex) = ipItem
    Else
        s.Host(ipIndex) = ipItem
    End If
  
    InsertAt = ipIndex

End Function

Public Property Get Item(ByVal ipIndex As Long) As Variant
    
    Item = Null
    
    If Guard.IndexOutOfBounds(ipIndex, Me, "Get Item", Guard.REPORT_BACK) Then
        Exit Property
    End If
    
    Dim myItem As Variant: myItem = Array(s.Host(ipIndex))
    
    If VBA.IsObject(myItem(0)) Then
        Set Item = myItem(0)
    Else
        Item = myItem(0)
    End If
   
End Property


Public Property Let Item(ByVal ipIndex As Long, ByVal ipItem As Variant)

    Guard.IndexOutOfBounds ipIndex, Me, "Let Item"
    
    VariantCopy s.Host(ipIndex), ipItem
 
End Property


Public Property Set Item(ByVal ipIndex As Long, ByVal ipItem As Variant)
    
    Guard.IndexOutOfBounds ipIndex, Me, "Set Item"
'    'assigning using s.host(index) does not work
'    ' but the variant copy method is successful
    VariantCopy s.Host(ipIndex), ipItem
'    '    Dim myArray As Variant
'    '    myArray = s.Host
'    '
'    '
'    '    Set myArray(ipIndex) = ipItem
'    '    s.Host = myArray
    
    'Set s.Host(ipIndex) = ipItem
    
End Property

'@Description("Removes the first encountered item from the Seq")
Public Function Remove(ByRef ipItem As Variant) As Long
Attribute Remove.VB_Description = "Removes the first encountered item from the Seq"

    Remove = NOT_FOUND

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long: myIndex = IndexOf(ipItem)
    
    If NotFound(myIndex) Then
        Exit Function
    End If
    
    MoveDown myIndex, 1

    Remove = myIndex
    
End Function


'@Description("Removes the item at the specified index")
Public Function RemoveAt(ByRef ipIndex As Long) As Long
Attribute RemoveAt.VB_Description = "Removes the item at the specified index"

    RemoveAt = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If Guard.IndexOutOfBounds(ipIndex, Me, "RemoveAt", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    MoveDown ipIndex, 1
        
    RemoveAt = ipIndex
    
End Function


'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Sugar methods' Add to the flexibility of the seq class using the above methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

'@Description("allows an external array to be substituted for the internal array")
'ToDo: update BInd to do the necessary memorty copying jiggery pokery
'@Ignore NonReturningFunction, EmptyMethod, ParameterNotUsed
Public Function Bind(ByRef ipArray As Variant) As SeqA
Attribute Bind.VB_Description = "allows an external array to be substituted for the internal array"
    
    '    GuardArrayNotFound ipArray, "SeqA.Bind"
    '
    '    'ToDO: his code requires updating I think
    '     ' make a copy of the content of s.host
    '    CopyMemoryToAny ByVal VarPtr(s.HostCopy), ByVal VarPtr(s.Host), 16
    '   ' transplant the structure of ipoATable to s.host
    '    CopyMemoryToAny ByVal VarPtr(s.Host), ByVal VarPtr(ipArray.Cargo), 16
    '
    '    Set Bind = Me

End Function

'@Description("Makes a shallow copy of the seq")
Public Function Clone() As SeqA
Attribute Clone.VB_Description = "Makes a shallow copy of the seq"

    Dim myS As SeqA: Set myS = SeqA.Deb
    Set Clone = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    ReDim Preserve s.Host(FIRST_INDEX To p.Count)
    Set Clone = SeqA(s.Host)
    
End Function

'@Description("Returns the Items in the seq as an Array() of variants")
Public Function Items() As Variant
Attribute Items.VB_Description = "Returns the Items in the seq as an Array() of variants"

    Items = Array()

    If Me.LacksItems Then
        Exit Function
    End If
    
    Items = Me.ToArray
    
End Function


'@Description("Returns a subset of the SeqA")
Public Function Slice _
( _
Optional ByRef ipStart As Long = FIRST_INDEX, _
Optional ByRef ipRun As Long = WHOLE_SEQ, _
Optional ByRef ipStep As Long = DEFAULT_STEP _
) As SeqA
Attribute Slice.VB_Description = "Returns a subset of the SeqA"
    
    ' ToDo: Should all Seq return a SeqA for SLice?
    Set Slice = SeqA.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Guard.IndexOutOfBounds ipStart, Me, "Slice"
    
    Dim myEnd As Long
    If ipRun < Me.FirstIndex Then
        myEnd = Me.LastIndex
    Else
        myEnd = ipStart + ipRun - 1
        If myEnd > Me.LastIndex Then
            myEnd = Me.LastIndex
        End If
    End If

    
    Dim myS As SeqA: Set myS = SeqA.Deb
   
    Dim mySeqIndex As Long
    For mySeqIndex = ipStart To myEnd Step ipStep
        myS.Add s.Host(mySeqIndex)
    Next

    Set Slice = myS

End Function


'@Description("Returns a shallow copy of the SeqA as an Array.  The Lbound of the array is 1")
Public Function ToArray() As Variant
Attribute ToArray.VB_Description = "Returns a shallow copy of the SeqA as an Array.  The Lbound of the array is 1"
    
    ToArray = Array()
    
    ' ToDo: Code currently only works for Linear Arrays
    If Me.LacksItems Then
        Exit Function
    End If

    ReDim Preserve s.Host(Me.FirstIndex To Me.LastIndex)
    
    ToArray = s.Host
    
End Function


'@Description("Returns a shallow copy of the SeqA as a VBA collection")
Public Function ToCollection() As Collection
Attribute ToCollection.VB_Description = "Returns a shallow copy of the SeqA as a VBA collection"
    
    Dim myC As Collection: Set myC = New Collection
    Set ToCollection = myC
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long
    ' Don't use foreach because the host array is larger than lastindex
    For myIndex = Me.FirstIndex To Me.LastIndex
        myC.Add s.Host(myIndex)
    Next
    
    Set ToCollection = myC
    
End Function


'@Description("Returns the predefined firstindex")
Public Function FirstIndex() As Long
Attribute FirstIndex.VB_Description = "Returns the predefined firstindex"
    FirstIndex = p.FirstIndex
End Function


'@Description("Returns the LastIndex of the Seq or -1 if the Seq is empty.  Equivalent to Count.")
Public Function LastIndex() As Long
Attribute LastIndex.VB_Description = "Returns the LastIndex of the Seq or -1 if the Seq is empty.  Equivalent to Count."

    If Me.Count < Me.FirstIndex Then
        LastIndex = LACKS_ITEMS
    Else
        LastIndex = Me.Count
    End If
   
End Function


'@Description("Returns the predefined First but One index")
Public Function FBOIndex() As Long
Attribute FBOIndex.VB_Description = "Returns the predefined First but One index"
    FBOIndex = Me.FirstIndex + 1
End Function


'@Description("Returns the last but One index or error 9")
Public Function LBOIndex() As Long
Attribute LBOIndex.VB_Description = "Returns the last but One index or error 9"

    If Me.LastIndex < Me.FBOIndex Then
        LBOIndex = LACKS_ITEMS
    Else
        LBOIndex = Me.LastIndex - 1
    End If
    
End Function


'@Description("Returns the item at FirstIndex")
Public Property Get First() As Variant
Attribute First.VB_Description = "Returns the item at FirstIndex"

    First = Null
    
    If Me.LacksItems Then
        Exit Property
    End If
    
    If VBA.IsObject(s.Host(Me.FirstIndex)) Then
        Set First = s.Host(Me.FirstIndex)
    Else
        First = s.Host(Me.FirstIndex)
    End If
    
End Property


'@Description("Assigns to the Item at FirstIndex")
Public Property Let First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    ' ToDo: review if the add action is better as an error
    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If
    
    s.Host(Me.FirstIndex) = ipItem
    
End Property


'@Description("Assigns to the Item at FirstIndex")
Public Property Set First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If
    
    Set s.Host(FIRST_INDEX) = ipItem
    
End Property


'@Description("Returns the Item at LastIndex")
Public Property Get Last() As Variant
Attribute Last.VB_Description = "Returns the Item at LastIndex"

    Last = Null

    If Me.LacksItems Then
        Exit Property
    End If

    If VBA.IsObject(s.Host(p.Count)) Then
        Set Last = s.Host(p.Count)
    Else
        Last = s.Host(p.Count)
    End If
    
End Property


'@Description("Assigns to the Item at LastIndex")
Public Property Let Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the Item at LastIndex"

    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If

    s.Host(p.Count) = ipItem
    
    
End Property


'@Description("Assigns to the item at LastIndex")
Public Property Set Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the item at LastIndex"

    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If

    Set s.Host(p.Count) = ipItem
    
End Property


'@Description("Returns the item at First but one Index")
Public Property Get FBO() As Variant
Attribute FBO.VB_Description = "Returns the item at First but one Index"

    FBO = Null
    
    If Guard.IndexNotFound(FBOIndex, Me, "Get FBO", Guard.REPORT_BACK) Then
        Exit Property
    End If
    
    If VBA.IsObject(s.Host(Me.FBOIndex)) Then
        Set FBO = s.Host(Me.FBOIndex)
    Else
        FBO = s.Host(Me.FBOIndex)
    End If

End Property


'@Description("Assigns to the Item at First but one Index")
Public Property Let FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at First but one Index"

    Guard.IndexNotFound Me.FBOIndex, Me, "Let LBO"

    s.Host(Me.FBOIndex) = ipItem

End Property


'@Description("Assigns to the Item at First but one Index")
Public Property Set FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at First but one Index"

    Guard.IndexNotFound Me.FBOIndex, Me, "Set LBO"
    
    Set Me.Item(Me.FBOIndex) = ipItem
    
End Property


'@Description("Returns the Item at Lastbut one Index")
Public Property Get LBO() As Variant
Attribute LBO.VB_Description = "Returns the Item at Lastbut one Index"

    LBO = Null
    
    If Guard.IndexNotFound(Me.LBOIndex, Me, "Get LBO", Guard.REPORT_BACK) Then
        Exit Property
    End If
    
    If VBA.IsObject(s.Host(LBOIndex)) Then
        Set LBO = s.Host(LBOIndex)
    Else
        LBO = s.Host(LBOIndex)
    End If

End Property


'@Description("Assigns to the Item at Last but one Index")
Public Property Let LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the Item at Last but one Index"

    Guard.IndexNotFound Me.LBOIndex, Me, "Let LBO"

    Me.Item(Me.LBOIndex) = ipItem
   
End Property


'@Description("Assigns to the item at Last but one Index")
Public Property Set LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the item at Last but one Index"

     Guard.IndexNotFound Me.LBOIndex, Me, "Set LBO"

     Set Me.Item(Me.LBOIndex) = ipItem

End Property


'@Description("Returns the index of the first Item found or -1.  Search range may be specified")
Public Function IndexOf _
( _
    ByVal ipItem As Variant, _
    Optional ByVal ipStart As Long = FIRST_INDEX, _
    Optional ByVal ipRun As Long = TO_LAST_INDEX _
) As Long
Attribute IndexOf.VB_Description = "Returns the index of the first Item found or -1.  Search range may be specified"

    IndexOf = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If Guard.IndexOutOfBounds(ipStart, Me, "IndexOf", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    ' No quick check for lacksitem as its too expensive
    
    ' ensure that ipstart+iprun only goes to the end of the seq
    Dim myEnd As Long
    If ipRun = TO_LAST_INDEX Then
        myEnd = Me.LastIndex
    ElseIf ipRun > 0 Then
        myEnd = ipStart + ipRun - 1
        If myEnd > Me.LastIndex Then
            myEnd = Me.LastIndex
        End If
    Else
        Exit Function
    End If
    
    ' we only need to search in the range defined by ipStart, myEnd
    Dim myIndex As Long
    For myIndex = ipStart To myEnd
   
        If Comparers.EQ(s.Host(myIndex), ipItem) Then
            IndexOf = myIndex
            Exit Function
        End If
    
    Next
    
End Function


Public Function LastIndexOf _
( _
ByVal ipItem As Variant, _
Optional ByVal ipStart As Long = FIRST_INDEX, _
Optional ByVal ipRun As Long = TO_LAST_INDEX _
) As Long
    
    LastIndexOf = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If Guard.IndexOutOfBounds(ipStart, Me, "LastIndexOf", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    ' No quick check for lacksitem as its too expensive
    
    Dim myEnd As Long
    If ipRun = TO_LAST_INDEX Then
        myEnd = Me.LastIndex
    ElseIf ipRun > 0 Then
        myEnd = ipStart + ipRun - 1
        If myEnd > Me.LastIndex Then
            myEnd = Me.LastIndex
        End If
    Else
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = myEnd To ipStart Step -1
    
        If Comparers.EQ(s.Host(myIndex), ipItem) Then
            LastIndexOf = myIndex
            Exit Function
        End If
    
    Next
    
    LastIndexOf = NOT_FOUND
    
End Function




'@Description("Adds the one or more Items in the paramarray to the  seq.  Support the ArrayOp.Splat method for forwarded paramarrays)
Public Function AddItems(ParamArray ipParamarray() As Variant) As SeqA

    If ArrayOp.LacksItems(VBA.CVar(ipParamarray)) Then
        Set AddItems = Me
        Exit Function
    End If
    
    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))

    AddRange myParamarray

    Set AddItems = Me
    
End Function


'@Description("Add an array,  list type, dictionary type, or characters of a string")
Public Function AddRange(ByVal ipRange As Variant) As SeqA
Attribute AddRange.VB_Description = "Add an array,  list type, dictionary type, or characters of a string"

    Set AddRange = Me
    
    Guard.InvalidRangeItem ipRange, MY_TYPENAME & ".AddRange", Guard.REPORT_BACK
    
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        If GroupInfo.IsDictionary(ipRange) Then
            Me.Add Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            Me.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set AddRange = Me

End Function


'@Description("Inserts one or more items starting at ipIndex")
Public Function InsertAtItems(ByVal ipIndex As Long, ParamArray ipParamarray() As Variant) As SeqA
Attribute InsertAtItems.VB_Description = "Inserts one or more items starting at ipIndex"
    
    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set InsertAtItems = InsertAtRange(ipIndex, myParamarray)
    
End Function

'@Description("Inserts items in a cotainer starting at ipIndex")
Public Function InsertAtRange(ByVal ipIndex As Long, ByRef ipRange As Variant) As SeqA
Attribute InsertAtRange.VB_Description = "Inserts items in a cotainer starting at ipIndex"

    Set InsertAtRange = Me
    
    If Guard.IndexOutOfBounds(ipIndex, Me, "InsertAtRange", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    Guard.InvalidRangeItem ipRange, MY_TYPENAME & ".InsertAtRange"

    ' insert in reverse order so we don't have to increment ipIndex
    Dim myItems As IterItems:  Set myItems = IterItems(ipRange).MoveToEndIndex
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
    
        If GroupInfo.IsDictionary(ipRange) Then
            InsertAt ipIndex, Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            InsertAt ipIndex, myItems.CurItem(0)
        End If
   
    Loop While myItems.MovePrev
    
    Set InsertAtRange = Me
    
End Function


'@Description "Removes the first encountered item for each item in the paramarray"
Public Function RemoveItems(ParamArray ipParamarray() As Variant) As SeqA
Attribute RemoveItems.VB_Description = "Removes the first encountered item for each item in the paramarray"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set RemoveItems = RemoveRange(myParamarray)
    
    Set RemoveItems = Me
    
End Function

'@Description("Remove items in the specified range of Indexes")
Public Function RemoveRange(ByRef ipRange As Variant) As SeqA
Attribute RemoveRange.VB_Description = "Remove items in the specified range of Indexes"
  
    Set RemoveRange = Me
    
    If Me.LacksItems Then
        Exit Function
    End If
  
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        MoveDown IndexOf(myItems.CurItem(0)), 1
    Loop While myItems.MoveNext
            
End Function

'@Description("Remove all of each item in the Paramarray. If no paramarray, remove all items")
Public Function RemoveAll(ParamArray ipParamarray() As Variant) As SeqA
Attribute RemoveAll.VB_Description = "Remove all of each item in the Paramarray. If no paramarray, remove all items"

    Set RemoveAll = Me
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    If ArrayOp.LacksItems(myParamarray) Then
        p.Count = 0
        p.Size = DEFAULT_CHUNK
        ReSize
        Exit Function
    End If
    
    Dim myItem As Variant
    For Each myItem In myParamarray
        RemoveAllSingleItem myItem
    Next
    
End Function

'Description@("Removes all Items from the SeqA")
Public Function Clear() As SeqA
    Set Clear = RemoveAll
End Function


'@Description("Removes all Items by replacing the Host collection with a new collection")
Public Function Reset() As SeqA
Attribute Reset.VB_Description = "Removes all Items by replacing the Host collection with a new collection"
    Set Reset = Me
    ReDim s.Host(FIRST_INDEX To DEFAULT_CHUNK)
    p.Count = 0
End Function


'@Description("Removes the first encountered item from the SeqA")
Public Function RemoveIndexes(ParamArray ipParamarray() As Variant) As SeqA
Attribute RemoveIndexes.VB_Description = "Removes the first encountered item from the SeqA"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set RemoveIndexes = RemoveIndexesRange(myParamarray)
    
    Set RemoveIndexes = Me
    
End Function


'@Description("Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use")
Public Function RemoveIndexesRange(ByRef ipRange As Variant) As SeqA
Attribute RemoveIndexesRange.VB_Description = "Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use"
  
    Set RemoveIndexesRange = Me
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    ' We cannot use iteritems on ipRange directly because
    ' we need to ensure that the indexes are removed in reverse
    ' order to avoid indexes being disconnected from thier original positions
    Dim myS As SeqA:
    ' SeqA will combine keys and items to a an array
    ' if ipRange is a dictionary
    ' so we choose to select the Items as the indexes
    If GroupInfo.IsDictionary(ipRange) Then
        Set myS = SeqA(ipRange.Items)
    Else
        Set myS = SeqA(ipRange)
    End If
    
    If myS.LacksItems Then
        Exit Function
    End If
        
    myS.Sorted
    
    '@Ignore AssignmentNotUsed
    'Remove the sorted indexes in reverse order
    Dim myItems As IterItems: Set myItems = IterItems(myS).MoveToEndIndex
    Do
        MoveDown myItems.CurItem(0), 1
    Loop While myItems.MovePrev
    
    Set RemoveIndexesRange = Me
        
End Function


Public Function Fill(ByRef ipItem As Variant, Optional ByVal ipCount As Long = 1) As SeqA

    Set Fill = Me
        
    Dim myCount As Long
    For myCount = 1 To ipCount
        Me.Add ipItem
    Next
    
End Function


'@Description("Returns the first N items of the SeqA, Default 1")
Public Function Head(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As SeqA
Attribute Head.VB_Description = "Returns the first N items of the SeqA, Default 1"
    
    Set Head = SeqA.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If

    If ipSplitAfter < Me.FirstIndex Then
        Exit Function
    End If
    
    If ipSplitAfter >= Me.LastIndex Then
        Set Head = Me.Clone
        Exit Function
    End If
    
    Set Head = Me.Slice(Me.FirstIndex, ipSplitAfter)

End Function


'@Description("Returns the Items after SplitAfter, Default is Index 2")
Public Function Tail(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As SeqA
Attribute Tail.VB_Description = "Returns the Items after SplitAfter, Default is Index 2"

    Set Tail = SeqA.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipSplitAfter >= Me.LastIndex Then
        Exit Function
    End If
    
    If ipSplitAfter < Me.FirstIndex Then
        Set Tail = Me.Clone
        Exit Function
    End If
    
    Set Tail = Me.Slice(ipSplitAfter + 1)

End Function


Public Function RotLeft(Optional ByVal ipCount As Long = 1) As SeqA
    
    Set RotLeft = Me
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount = 0 Then
        Exit Function
    End If
    
    If ipCount < 0 Then
        Set RotLeft = RotRight(VBA.Abs(ipCount))
        Exit Function
    End If
    
    Me.AddRange Me.DequeueRange(ipCount)
    
End Function


Public Function RotRight(Optional ByVal ipCount As Long = 1) As SeqA
    
    Set RotRight = Me
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount = 0 Then
        Exit Function
    End If
    
    If ipCount < 0 Then
        Set RotRight = RotLeft(VBA.Abs(ipCount))
        Exit Function
    End If
    
    Me.InsertAtRange 1, Me.PopRange(ipCount).Reverse
    
End Function
Public Function HoldsItem(ByRef ipItem As Variant) As Boolean

    HoldsItem = False
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex ' remember Lastindex < Size
        If Comparers.EQ(s.Host(myIndex), ipItem) Then
            HoldsItem = True
            Exit Function
        End If
    Next

End Function


Public Function Contains(ByRef ipItem As Variant) As Boolean
    Contains = Me.HoldsItem(ipItem)
End Function


Public Function LacksItem(ByRef ipItem As Variant) As Boolean
    LacksItem = Not HoldsItem(ipItem)
End Function


Public Function HoldsItems() As Boolean
    HoldsItems = p.Count >= Me.FirstIndex
End Function


Public Function LacksItems() As Boolean
    LacksItems = Not Me.HoldsItems
End Function


Public Property Get TypeName() As String
    TypeName = MY_TYPENAME
End Property

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' An attempt as  providing some 'lambda' functionality - see IMapper and mp/cmp/rd classes
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
'@Description("Mutates the Seq in place by applying the function in IMapper to each item")
Public Function MappedIt(ByRef ipMapper As IMapper) As SeqA
Attribute MappedIt.VB_Description = "Mutates the Seq in place by applying the function in IMapper to each item"
    
    Set MappedIt = Me
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
        ' execmapper returns a single value array
        Dim myA() As Variant: myA = ipMapper.ExecMapper(s.Host(myIndex))
        
        If VBA.IsObject(myA(0)) Then
            Set s.Host(myIndex) = myA(0)
        Else
            s.Host(myIndex) = myA(0)
        End If
        
    Next
    
End Function


'@Description("Returns a new Seq where each item in the Host has been mutated by the function provided by IMapper")
Public Function MapIt(ByVal ipMapper As IMapper) As SeqA
Attribute MapIt.VB_Description = "Returns a new Seq where each item in the Host has been mutated by the function provided by IMapper"

    Dim myS As SeqA: Set myS = SeqA.Deb
    Set MapIt = myS
    
    If Me.LacksItems Then
        Exit Function
    End If

    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
        ' Execmapper returns a single item array
        myS.Add ipMapper.ExecMapper(s.Host(myIndex))(0)
    Next
    
    Set MapIt = myS

End Function


'@Description("Returns a new Seq where each item returns true from the IComparer")
Public Function FilterIt(ByVal ipComparer As IComparer) As SeqA
Attribute FilterIt.VB_Description = "Returns a new Seq where each item returns true from the IComparer"

    Dim myS As SeqA: Set myS = SeqA.Deb
    Set FilterIt = myS
    
    If Me.LacksItems Then
        Exit Function
    End If

    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
        If ipComparer.ExecCmp(s.Host(myIndex)) Then
            myS.Add s.Host(myIndex)
        End If
        
    Next

    Set FilterIt = myS

End Function


'@Description("Returns the count the number of items where IComparer returns true")
Public Function CountIt(ByVal ipComparer As IComparer) As Long
Attribute CountIt.VB_Description = "Returns the count the number of items where IComparer returns true"

    CountIt = -1
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myCount As Long: myCount = 0
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
        If ipComparer.ExecCmp(s.Host(myIndex)) Then
            myCount = myCount + 1
        End If
        
    Next

    CountIt = myCount

End Function


'@Description("Returns the single value computed by the IReducer").
Public Function ReduceIt(ByRef ipReducer As IReducer) As Variant
    
    ReduceIt = Null

    If Me.LacksItems Then
        Exit Function
    End If
    'ToDo: Update reducers to use iteritems rather than an array
    Dim myA() As Variant: myA = ipReducer.ExecReduction(Me)
    'VariantCopy ReduceIt, myItem(0)
    If VBA.IsObject(myA(0)) Then
        Set ReduceIt = VBA.CVar(myA(0))
    Else
        ReduceIt = VBA.CVar(myA(0))
    End If
    
End Function

'@Description("Adds items to the seq at the end of the seq")
Public Function Push(ParamArray ipParamarray() As Variant) As SeqA
Attribute Push.VB_Description = "Adds items to the seq at the end of the seq"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set Push = AddRange(myParamarray)
    
End Function


' Enqueue - add at end
' Dequeue - removes from position 1

' Push = add at end
' Pop remove from end
'
'@Description("Add the Items in ipRange to the end of the Seq")
Public Function PushRange(ByRef ipRange As Variant) As SeqA
Attribute PushRange.VB_Description = "Add the Items in ipRange to the end of the Seq"
    Set PushRange = AddRange(ipRange)
End Function

'@Description("Removes the last item from the seq and returns it")
Public Function Pop() As Variant
Attribute Pop.VB_Description = "Removes the last item from the seq and returns it"

    Pop = Null

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItem As Variant: myItem = Array(s.Host(p.Count))
    
    If VBA.IsObject(myItem(0)) Then
        Set Pop = myItem(0)
    Else
        Pop = myItem(0)
    End If
    
    MoveDown p.Count, 1
    
End Function

'@Description("Removes ipCount Items from the end of the Seq. Returns a SeqA of the items in order of removal"
Public Function PopRange(Optional ByVal ipCount As Long = 1) As SeqA

    Set PopRange = SeqA.Deb
    
    If ipCount < Me.FirstIndex Then
        Exit Function
    End If
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount > Me.LastIndex Then
        Set PopRange = Me.Reverse
        Me.RemoveAll
        Exit Function
    End If
        
    Dim myS As SeqA: Set myS = SeqA.Deb
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        myS.Add Me.Pop
    Next
    
    Set PopRange = myS
    
End Function

'@Description("Adds items to the seq at the end of the seq")
Public Function enQueue(ParamArray ipParamarray() As Variant) As SeqA
Attribute enQueue.VB_Description = "Adds items to the seq at the end of the seq"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set enQueue = AddRange(myParamarray)
    
End Function


Public Function EnqueueRange(ByRef ipRange As Variant) As SeqA
    Set EnqueueRange = AddRange(ipRange)
End Function


Public Function Dequeue() As Variant

    Dequeue = Null

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItem As Variant: myItem = Array(s.Host(Me.FirstIndex))
    
    If VBA.IsObject(myItem(0)) Then
        Set Dequeue = myItem(0)
    Else
        Dequeue = myItem(0)
    End If
    
    MoveDown Me.FirstIndex, 1
    
End Function


Public Function DequeueRange(Optional ByVal ipCount As Long = 1) As SeqA

    Set DequeueRange = SeqA.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If

    If ipCount < 1 Then
        Exit Function
    End If
    
    If ipCount > Me.LastIndex Then
        Set DequeueRange = SeqA(Me.Clone)
        Me.RemoveAll
        Exit Function
    End If
    
    Dim myS As SeqA: Set myS = SeqA.Deb
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        myS.Add Me.Dequeue
    Next
    
    Set DequeueRange = myS
    
End Function


'@Description("Returns a new sequence sorted in 'Ascending' order"
Public Function Sort() As SeqA
    
    Dim myS As SeqA: Set myS = SeqA.Deb
    
    If Me.LacksItems Then
        Set Sort = myS
        Exit Function
    End If
    
    '@Ignore AssignmentNotUsed
    Set myS = Me.Clone
    Sorters.ShakerSortByItem myS
    Set Sort = myS
     
End Function


'@Description("Sorts the seq in place in 'Ascending' order ")
Public Function Sorted() As SeqA
Attribute Sorted.VB_Description = "Sorts the seq in place in 'Ascending' order "

    Set Sorted = Me

    If Me.LacksItems Then
        Exit Function
    End If
    
    Sorters.ShakerSortByItem Me
    Set Sorted = Me
    
End Function


'@Description("Swaps the Items at the specified indexes")
Public Function Swap(ByRef ipLHSIndex As Long, ByRef ipRHSIndex As Long) As SeqA
Attribute Swap.VB_Description = "Swaps the Items at the specified indexes"

    Dim myTemp As Variant
    
    If VBA.IsObject(s.Host(ipLHSIndex)) Then
        Set myTemp = s.Host(ipLHSIndex)
    Else
        myTemp = s.Host(ipLHSIndex)
    End If
    
    If VBA.IsObject(s.Host(ipRHSIndex)) Then
        Set s.Host(ipLHSIndex) = s.Host(ipRHSIndex)
    Else
        s.Host(ipLHSIndex) = s.Host(ipRHSIndex)
    End If
    
    If VBA.IsObject(myTemp) Then
        Set s.Host(ipRHSIndex) = myTemp
    Else
        s.Host(ipRHSIndex) = myTemp
    End If

    Set Swap = Me
    
End Function

'@Description("Returns a new seq with Items in reverse order")
Public Function Reverse() As SeqA
Attribute Reverse.VB_Description = "Returns a new seq with Items in reverse order"

    Dim myS As SeqA: Set myS = SeqA.Deb
    Set Reverse = myS
    
    If Me.LacksItems Then
        Exit Function
    End If

    Dim myIndex As Long
    For myIndex = Me.LastIndex To Me.FirstIndex Step -1
        myS.Add s.Host(myIndex)
    Next
     
    Set Reverse = myS

End Function

'@Description("Reverses the order of items in place")
Public Function Reversed() As SeqA
Attribute Reversed.VB_Description = "Reverses the order of items in place"
    
    If Me.LacksItems Or p.Count = 1 Then
        Set Reversed = Me
        Exit Function
    End If
     
    Dim myFirstIndex As Long: myFirstIndex = Me.FirstIndex
    Dim myLastIndex As Long: myLastIndex = Me.LastIndex
    
    Do
    
        Me.Swap myFirstIndex, myLastIndex
        myFirstIndex = myFirstIndex + 1
        myLastIndex = myLastIndex - 1
    
    Loop Until myFirstIndex >= myLastIndex

    Set Reversed = Me

End Function

'@Description("Returns true if there are no duplicate items")
Public Function IsUnique() As Boolean
Attribute IsUnique.VB_Description = "Returns true if there are no duplicate items"

    If LacksItems Then
        IsUnique = False
        Exit Function
    End If
    
    Dim myH As cHashC: Set myH = New cHashC
    
    Dim myIndex As Long
    For myIndex = p.FirstIndex To p.Count
        If myH.Exists(s.Host(myIndex)) Then
            IsUnique = False
            Exit Function
        Else
            myH.Add s.Host(myIndex)
        End If
    Next

    IsUnique = True

End Function


Public Function IsNotUnique() As Boolean
    IsNotUnique = Not IsUnique
End Function


'@Description("Returns the a new seq with the unique subset of the host Seq")
Public Function Dedup() As SeqA
Attribute Dedup.VB_Description = "Returns the a new seq with the unique subset of the host Seq"

    Dim myS As SeqA: Set myS = SeqA.Deb
    Set Dedup = myS
    
    If Me.LacksItems Then
        Exit Function
    End If

    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
        If myS.LacksItem(s.Host(myIndex)) Then
            myS.Add s.Host(myIndex)
        End If
    Next

    Set Dedup = myS
            
End Function


'@Description("Removes duplicate items from the seq")
Public Function Deduped() As SeqA
Attribute Deduped.VB_Description = "Removes duplicate items from the seq"

    Set Deduped = Me
    
    If LacksItems Then
        Exit Function
    End If
    
    Dim myS As SeqA: Set myS = SeqA.Deb
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
    
        If myS.HoldsItem(s.Host(myIndex)) Then
            MoveDown myIndex, 1
        Else
            myS.Add s.Host(myIndex)
        End If
        
    Next
    
    Set Deduped = Me
    
End Function


Public Function Freq() As KvpA

    Dim myK As KvpA: Set myK = KvpA.Deb
    Set Freq = myK
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
    
        If myK.LacksKey(s.Host(myIndex)) Then
            myK.Add s.Host(myIndex), 1
        Else
            myK.Item(s.Host(myIndex)) = myK.Item(s.Host(myIndex)) + 1
        End If
        
    Next
    
     Set Freq = myK
    
End Function


Public Function SetOf(ByRef ipSet As e_SetoF, ByRef ipRangeItem As SeqA) As SeqA

    Select Case ipSet

        Case e_SetoF.m_Common:           Set SetOf = SetOfCommon(ipRangeItem)
        Case e_SetoF.m_HostOnly:         Set SetOf = SetOfHostOnly(ipRangeItem)
        Case e_SetoF.m_ParamOnly:        Set SetOf = SetOfParamOnly(ipRangeItem)
        Case e_SetoF.m_NotCommon:        Set SetOf = SetOfNotCommon(ipRangeItem)
        Case e_SetoF.m_Unique:           Set SetOf = SetofUnique(ipRangeItem)
        Case Else
            Err.Raise 17 + vbObjectError, _
            "vbaLib.SeA.Seq.SetOf", _
            Fmt.Text("Invalid e_set member. Expecting {0} to {1}. Got {2}", e_SetoF.m_First, e_SetoF.m_Last, ipSet)
                
    End Select

End Function





'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' Private methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
Private Function SetOfCommon(ByRef ipSeq As SeqA) As SeqA

    Dim myS As SeqA: Set myS = SeqA.Deb
    Set SetOfCommon = myS
    
    If Me.LacksItems Or ipSeq.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(ipSeq)
    Do
    
        Dim myItem As Variant: myItem = Array(myItems.CurItem(0))
        
        If Me.HoldsItem(myItem(0)) Then
            myS.Add myItem(0)
        End If
        
    Loop While myItems.MoveNext
 
End Function


Private Function SetOfHostOnly(ByRef ipSeq As SeqA) As SeqA

    Dim myS As SeqA: Set myS = SeqA.Deb
    Set SetOfHostOnly = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    If ipSeq.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(ipSeq)
    Do
    
        If myS.HoldsItem(myItems.CurItem(0)) Then
            myS.Remove myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetOfHostOnly = myS
    
End Function


Private Function SetOfParamOnly(ByRef ipSeq As SeqA) As SeqA
 
    Dim myS As SeqA: Set myS = SeqA.Deb
    Set SetOfParamOnly = myS
    
    If ipSeq.LacksItems Then
        Exit Function
    End If
    
    Set myS = ipSeq.Dedup
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=Me.LastIndex)
    Do
    
        If myS.HoldsItem(myItems.CurItem(0)) Then
            myS.Remove myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext

    Set SetOfParamOnly = myS
    
End Function


Private Function SetOfNotCommon(ByRef ipSeq As SeqA) As SeqA

    Dim myS As SeqA: Set myS = SeqA.Deb
    Set SetOfNotCommon = myS
    
    If LacksItems And ipSeq.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=Me.LastIndex)
    Do
    
        If ipSeq.LacksItem(myItems.CurItem(0)) Then
            If myS.LacksItem(myItems.CurItem(0)) Then
                myS.Add myItems.CurItem(0)
            End If
        End If
        
    Loop While myItems.MoveNext
    
    '@Ignore AssignmentNotUsed
    Set myItems = IterItems(ipSeq)
    Do
    
        If Me.LacksItem(myItems.CurItem(0)) Then
            If myS.LacksItem(myItems.CurItem(0)) Then
                myS.Add myItems.CurItem(0)
            End If
        End If
        
    Loop While myItems.MoveNext
    
End Function


Private Function SetofUnique(ByRef ipSeq As SeqA) As SeqA

    Dim myS As SeqA: Set myS = SeqA.Deb
    Set SetofUnique = myS
    
    If Me.LacksItems And ipSeq.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    Dim myItems As IterItems: Set myItems = IterItems(ipSeq)
    Do
    
        If myS.LacksItem(myItems.CurItem(0)) Then
            myS.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetofUnique = myS

End Function

'@Description("Get the index of the next item in the seq")
Private Function GetNextIndex() As Long
Attribute GetNextIndex.VB_Description = "Get the index of the next item in the seq"

    p.Count = p.Count + 1
    If p.Count > p.Size Then

        p.Size = p.Size + DEFAULT_CHUNK
        ReSize

    End If

    GetNextIndex = p.Count

End Function


'@Description("Moves all elements from ipIndex to s.lastindex down by ipCount places")
Private Sub MoveDown(ByVal ipToIndex As Long, ByVal ipCount As Long)
Attribute MoveDown.VB_Description = "Moves all elements from ipIndex to s.lastindex down by ipCount places"

    If ipCount < FIRST_INDEX Then
        Exit Sub
    End If

    ' If ipIndex < FirstIndex Or ipIndex > s.lastindex Then
    '     Exit Sub
    ' End If

    Dim myToIndex As Long
    myToIndex = ipToIndex

    Dim myFromIndex As Long
    For myFromIndex = ipToIndex + ipCount To p.Count

        If VBA.IsObject(s.Host(myFromIndex)) Then
            Set s.Host(myToIndex) = s.Host(myFromIndex)
        Else
            s.Host(myToIndex) = s.Host(myFromIndex)
        End If
        ' s.host(myFromIndex) = Empty
        myToIndex = myToIndex + 1


    Next
    Dim myIndex As Long
    For myIndex = p.Count - ipCount + 1 To p.Count
        s.Host(myIndex) = Empty
    Next
    p.Count = p.Count - ipCount

End Sub


'
'@Description("Moves all elements from ipIndex to s.lastindex up by ipCount places")
Private Sub MoveUp(ByVal ipIndex As Long, Optional ByVal ipCount As Long = 1)
Attribute MoveUp.VB_Description = "Moves all elements from ipIndex to s.lastindex up by ipCount places"

    If ipCount < FIRST_INDEX Then
        Exit Sub
    End If

    If ipIndex < FIRST_INDEX Or ipIndex > p.Count Then
        Exit Sub
    End If


    Do While p.Count + ipCount > p.Size
        DoEvents
        p.Size = p.Size + DEFAULT_CHUNK
        ReSize

    Loop

    Dim myToIndex As Long
    myToIndex = p.Count + ipCount
    Dim myFromIndex As Long
    myFromIndex = p.Count

    Dim myIterations As Long
    For myIterations = 0 To p.Count - ipIndex

        Swap myToIndex - myIterations, myFromIndex - myIterations

    Next

    p.Count = p.Count + ipCount

End Sub


Private Sub ReSize()
    If p.Size < FIRST_INDEX Then
        ReDim s.Host(FIRST_INDEX To DEFAULT_CHUNK)
    Else
        ReDim Preserve s.Host(FIRST_INDEX To p.Size)
    End If

    ' The count is not set here because it depends on the context where
    ' resize was called
    ' Last index should be adjusted at the calling site.
End Sub

Private Sub RemoveAllSingleItem(ByRef ipItem As Variant)

    'ReDim Preserve s.Host(FIRST_INDEX, s.LastIndex)
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=p.Count).MoveToEndIndex
    Do
        If Comparers.EQ(myItems.CurItem(0), ipItem) Then
            MoveDown myItems.CurKey(0), 1
        End If
    Loop While myItems.MovePrev
    
End Sub

Private Function NotFound(ByRef ipItem As Variant) As Boolean

    If VBA.IsObject(ipItem) Then
        NotFound = ipItem Is Nothing
    ElseIf GroupInfo.IsNumber(ipItem) Then
        NotFound = ipItem = -1
    Else
        NotFound -VBA.IsEmpty(ipItem)
    End If
        
End Function
