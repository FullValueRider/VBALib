VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "SeqA"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_Description = "SeqA is a multipurpose Collection/ArrayList replacement.  It uses a one dimensional array to store the items.  Items are access using a single 1 based index. Multi dimensions addressing can be converted to linrear addressing using ArrayInfo.GetIndex. For a Keyed collection, use one of the Kvp classes"
'@PredeclaredId
'@Exposed
'@Folder("Seq")
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C

'@ModuleDescription("SeqA is a multipurpose Collection/ArrayList replacement.  It uses a one dimensional array to store the items.  Items are access using a single 1 based index. Multi dimensions addressing can be converted to linrear addressing using ArrayInfo.GetIndex. For a Keyed collection, use one of the Kvp classes")
' SeqA uses the VBA Collection class as a host for the items
' Other versions of SeqA are available (SeqA, SeqAL, SeqAH, SeqAT)

' Instantiating using IterItems rather than having specific code to deal with different types is about twice as fast
' e.g. Testing show IterItems version completes testing in 0.54 seconds vs 0.82 seconds

' Seq classes do not implement NewEnum because not all classes support such a method.
' Instead the use of the iteritems class is promoted for a superior for each experiece.

Option Explicit
'Implements SeqA

Private Const MY_TYPENAME                       As String = "SeqA"
Private Const DEFAULT_CHUNK                     As Long = 16&
Private Const FIRST_INDEX                       As Long = 1

Private Type State

   ' HostCopy                                    As variantudt
    Host()                                      As Variant ' an array
    LastIndex                                   As Long
    Size                                        As Long
    
    
End Type

Private s                                       As State

' Deb is a Factory method of the PredeclaredId which returns a new instance of SeqA
'=================================================================================
' The input for Deb is a ParamArray.
' The ParamArray is interpreted according to the folowing rules
' If the ParamArray contains no Items
' - A empty SeqAuence (count = 0)
' If the ParamArray has 2 or more items
' - A SeqA of size equal to the ParamArray, items as generated by for each over the ParamArray
' If the ParamArray has a single Item
' - Number: SeqA with specified capacity with each Item being the Value 'Empty'
' - String: A SeqA whose capacity is the length of the string with one character per Item
' - Array: SeqA of items as provided by For Each over the array.  Multidimension arrays are flattened but the position in the original array can be calculated by the user if required. See also Bind
' - Dictionaries: a SeqA of key/value arrays as generated from for each on the Keys array.
' - Collection: The collection is copied to the Host collection.  There is no refererence link to the original collection (See Host Property)
' - SeqA: Items as generated by for each on the SeqA
' - mscorlib Arraylist: Items as generated by for each on the arrylist
' - mscorlib Stack: Items as generated by for each on the stack
' - mscorlib Queue: Items as generated by for eac on the queue

'@DefaultMember
Public Function Deb(ParamArray ipParamarray() As Variant) As SeqA
Attribute Deb.VB_UserMemId = 0
    With New SeqA
        Set Deb = .ConstructInstance(VBA.CVar(ipParamarray))
    End With
End Function

Friend Function ConstructInstance(ByRef ipFPA As Variant) As SeqA
    
    s.LastIndex = 0
    s.Size = DEFAULT_CHUNK
    Resize
        
    ' Check to see if we return a default 'empty' seq
    If ArrayInfo.LacksItems(ipFPA) Then
        Set ConstructInstance = Me
        Exit Function
    End If
    
    ' ipParamArray contains one or more items so return a Seq containing a copy
    ' of the item(s) in the forwarded paramarray.
    ' See the Bind method if mutability of an input array required
    ' Resolve the items in the forwarded paramarray using the rules for
    ' instantiation as described above.
    
    Sys.ResolveParamArray ipFPA
    
    Select Case True
    
        Case VBA.IsArray(ipFPA):                Set ConstructInstance = AddRange(LineariseArray(ipFPA))
        Case GroupInfo.IsContainer(ipFPA):      Set ConstructInstance = AddRange(ipFPA)
        Case GroupInfo.IsString(ipFPA):         Set ConstructInstance = AddRange(ipFPA)
        Case GroupInfo.IsNumber(ipFPA):         Set ConstructInstance = ConstructInstanceByCount(VBA.CLng(ipFPA))
        Case Else:                              Set ConstructInstance = AddItems(ipFPA)
    End Select
    
End Function

Private Function ConstructInstanceByCount(ByRef ipSize As Long) As SeqA
    
    If ipSize < FIRST_INDEX Then
        Set ConstructInstanceByCount = Me
        Exit Function
    End If
    
    s.Size = ipSize
    Resize
    s.LastIndex = ipSize
    Set ConstructInstanceByCount = Me
    
End Function

'@Description("allows and external array to be inserted into s.Host")
'ToDo: update BInd to do the necessary memorty copying jiggery pokery
'@Ignore NonReturningFunction, EmptyMethod, ParameterNotUsed
Public Function Bind(ByRef ipArray As Variant) As SeqA
Attribute Bind.VB_Description = "allows and external array to be inserted into s.Host"
    
'    GuardExpectingArray ipArray, "VBALib.SeqA.Bind"
'
'    'ToDO: his code requires updating I think
'     ' make a copy of the content of s.host
'    CopyMemoryToAny ByVal VarPtr(s.HostCopy), ByVal VarPtr(s.Host), 16
'   ' transplant the structure of ipoATable to s.host
'    CopyMemoryToAny ByVal VarPtr(s.Host), ByVal VarPtr(ipArray.Cargo), 16
'
'    Set Bind = Me

End Function

Public Function Clone() As SeqA
    ReDim Preserve s.Host(FIRST_INDEX To s.LastIndex)
    Set Clone = SeqA(s.Host)
End Function

'

'ToDo: Update to necessary memory jiggery pokery
'@Ignore EmptyMethod
Private Sub Class_Terminate()

'    If s.HostCopy.VT = 0 Then
'        Exit Sub
'    Else
'        CopyMemByVal ByVal VarPtr(s.Host), ByVal VarPtr(s.HostCopy), 16
'    End If

End Sub



'@Description("Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer")
Public Function Count(Optional ByRef ipItem As Variant) As Long
Attribute Count.VB_Description = "Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer"

    If VBA.IsMissing(ipItem) Then
        Count = s.LastIndex
        Exit Function
    End If
    
    If s.LastIndex < 1 Then
        Count = -1
        Exit Function
    End If
    
    Dim myCount As Long
    myCount = 0
    
    Dim myIndex As Long
    For myIndex = FirstIndex To s.LastIndex
        If ComparerHelpers.Equals(s.Host(myIndex), ipItem) Then
            myCount = myCount + 1
        End If
    Next
    
    Count = myCount
    
End Function


Public Function Items() As Variant

    ReDim Preserve s.Host(1 To s.LastIndex)
    Items = s.Host
    
End Function


'@Description("Returns a subset of the SeqA")
Public Function Slice _
( _
    Optional ByRef ipStart As Long = 1, _
    Optional ByRef ipRun As Long = -1, _
    Optional ByRef ipStep As Long = 1 _
) As SeqA
Attribute Slice.VB_Description = "Returns a subset of the SeqA"
    
    If s.LastIndex < 1 Then
        Set Slice = SeqA.Deb
        Exit Function
    End If
    
    GuardIndexOutOfBounds ipStart, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Sice"
    
    Dim myRun As Long
    myRun = ipRun
    If myRun = -1 Then
        myRun = s.LastIndex - ipStart + 1
    Else
        GuardIndexOutOfBounds myRun + ipStart, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Sice"
    End If

    Dim myS As SeqA
    Set myS = SeqA.Deb
   
    Dim mySeqIndex As Long
    For mySeqIndex = ipStart To ipStart + myRun - 1 Step ipStep
        myS.Add s.Host(mySeqIndex)
    Next

    Set Slice = myS

End Function


'@Description("Returns a shallow copy of the SeqA as an Array.  The Lbound of the array is 1")
Public Function ToArray() As Variant
Attribute ToArray.VB_Description = "Returns a shallow copy of the SeqA as an Array.  The Lbound of the array is 1"
    
    If s.LastIndex <= 1 Then
        ToArray = Array()
        Exit Function
    End If

    ReDim Preserve s.Host(FIRST_INDEX To s.LastIndex)
    
    ToArray = s.Host
    
End Function

'@Description("Returns a shallow copy of the SeqA as a VBA collection")
Public Function ToCollection() As Collection
Attribute ToCollection.VB_Description = "Returns a shallow copy of the SeqA as a VBA collection"
    
    Dim myC As Collection
    Set myC = New Collection
    
    If s.LastIndex < 1 Then
        Set ToCollection = myC
        Exit Function
    End If
    
    Dim myIndex As Long
    ' DOn't use foreach because the host array is larger than lastindex
    For myIndex = FIRST_INDEX To s.LastIndex
        myC.Add s.Host(myIndex)
    Next
    
    Set ToCollection = myC
    
End Function



'@Description("Returns the Host of the first Index")
Public Function FirstIndex() As Long
Attribute FirstIndex.VB_Description = "Returns the Host of the first Index"

    If s.LastIndex < FIRST_INDEX Then
        FirstIndex = -1
    Else
        FirstIndex = FIRST_INDEX
    End If
    
End Function

'@Description("Returns the UBound of the SeqA or -1 if the SeqA is empty.  Equivalent to Count.")
Public Function LastIndex() As Long
Attribute LastIndex.VB_Description = "Returns the UBound of the SeqA or -1 if the SeqA is empty.  Equivalent to Count."

    If s.LastIndex < FIRST_INDEX Then
        LastIndex = -1
    Else
        LastIndex = s.LastIndex
    End If
   
End Function

'@Description("Returns the First but One index or error 9")
Public Function FBOIndex() As Long
Attribute FBOIndex.VB_Description = "Returns the First but One index or error 9"

    If s.LastIndex < FIRST_INDEX + 1 Then
        FBOIndex = -1
    Else
        FBOIndex = FIRST_INDEX + 1
    End If
    
End Function

 '@Description("Returns the last but One index or error 9")
Public Function LBOIndex() As Long
Attribute LBOIndex.VB_Description = "Returns the last but One index or error 9"
    If s.LastIndex < FIRST_INDEX + 1 Then
        LBOIndex = -1
    Else
        LBOIndex = s.LastIndex - 1
    End If
End Function

Public Function TypeName() As String
    TypeName = MY_TYPENAME
End Function

'@Description("Returns the item at FirstIndex")
Public Property Get First() As Variant
Attribute First.VB_Description = "Returns the item at FirstIndex"

    If s.LastIndex < 1 Then
        First = Null
        Exit Property
    End If
    
    If VBA.IsObject(s.Host(FIRST_INDEX)) Then
        Set First = s.Host(FIRST_INDEX)
    Else
        First = s.Host(FIRST_INDEX)
    End If
    
End Property

'@Description("Assigns to the Item at FirstIndex")
Public Property Let First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    'GuardInvalidIndex First_Index, s.lastindex, "VBALib.SeqA.Let_First"
    If s.LastIndex < 1 Then
        Me.Add ipItem
        Exit Property
    End If
    
    s.Host(FIRST_INDEX) = ipItem
    
End Property

'@Description("Assigns to the Item at FirstIndex")
Public Property Set First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    If s.LastIndex < 1 Then
        Me.Add ipItem
        Exit Property
    End If
    
    Set s.Host(FIRST_INDEX) = ipItem
    
End Property

'@Description("Returns the Item at LastIndex")
Public Property Get Last() As Variant
Attribute Last.VB_Description = "Returns the Item at LastIndex"

    If s.LastIndex < 1 Then
        Last = Null
        Exit Property
    End If

    If VBA.IsObject(s.Host(s.LastIndex)) Then
        Set Last = s.Host(s.LastIndex)
    Else
        Last = s.Host(s.LastIndex)
    End If
    
End Property

'@Description("Assigns to the Item at LastIndex")
Public Property Let Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the Item at LastIndex"

    If s.LastIndex < FIRST_INDEX Then
        Me.Add ipItem
        Exit Property
    End If

    s.Host(s.LastIndex) = ipItem
    
    
End Property

'@Description("Assigns to the item at LastIndex")
Public Property Set Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the item at LastIndex"

    If s.LastIndex < FIRST_INDEX Then
        Me.Add ipItem
        Exit Property
    End If

    Set s.Host(s.LastIndex) = ipItem
    
End Property

'@Description("Returns the item at First but one Index")
Public Property Get FBO() As Variant
Attribute FBO.VB_Description = "Returns the item at First but one Index"

    Dim FBOIndex As Long
    FBOIndex = FIRST_INDEX + 1

    If s.LastIndex < FBOIndex Then
         FBO = Null
         Exit Property
     End If
    
    If VBA.IsObject(s.Host(FBOIndex)) Then
        Set FBO = s.Host(FBOIndex)
    Else
        FBO = s.Host(FBOIndex)
    End If

End Property

'@Description("Assigns to the Item at First but one Index")
Public Property Let FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at First but one Index"

    If s.LastIndex < FIRST_INDEX Then
        Err.Raise 17 + vbObjectError, _
            "VBALib.SeqA.Let_FBO", _
            Fmt.Text("Index {0} not avaiable", FirstIndex + 1)
    ElseIf s.LastIndex = FIRST_INDEX Then
        Me.Add ipItem
    Else
        Me.Item(FIRST_INDEX + 1) = ipItem
    End If

End Property

'@Description("Assigns to the Item at First but one Index")
Public Property Set FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at First but one Index"

   If s.LastIndex < FIRST_INDEX Then
        Err.Raise 17 + vbObjectError, _
            "VBALib.SeqA.Let_FBO", _
            Fmt.Text("Index {0} not avaiable", FirstIndex + 1)
    ElseIf s.LastIndex = FIRST_INDEX Then
        Me.Add ipItem
    Else
       Set Me.Item(FIRST_INDEX + 1) = ipItem
    End If

End Property

'@Description("Returns the Item at Lastbut one Index")
Public Property Get LBO() As Variant
Attribute LBO.VB_Description = "Returns the Item at Lastbut one Index"

    Dim LBOIndex As Long
    LBOIndex = s.LastIndex - 1

    If LBOIndex < FIRST_INDEX Then
         LBO = Null
         Exit Property
     End If
    
    If VBA.IsObject(s.Host(LBOIndex)) Then
        Set LBO = s.Host(LBOIndex)
    Else
        LBO = s.Host(LBOIndex)
    End If

End Property


'@Description("Assigns to the Item at Last but one Index")
Public Property Let LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the Item at Last but one Index"

    If s.LastIndex < FIRST_INDEX Then
        Err.Raise 17 + vbObjectError, _
            "VBALib.SeqA.Let_FBO", _
            Fmt.Text("Index {0} not avaiable", s.LastIndex - 1)
    ElseIf s.LastIndex = FIRST_INDEX Then
        Me.Insert ipItem, FIRST_INDEX
    Else
        Me.Item(s.LastIndex - 1) = ipItem
    End If
    
End Property


'@Description("Assigns to the item at Last but one Index")
Public Property Set LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the item at Last but one Index"

   If s.LastIndex < FIRST_INDEX Then
        Err.Raise 17 + vbObjectError, _
            "VBALib.SeqA.Let_FBO", _
            Fmt.Text("Index {0} not avaiable", s.LastIndex - 1)
    ElseIf s.LastIndex = FIRST_INDEX Then
        Me.Insert ipItem, FIRST_INDEX
    Else
        Set Me.Item(s.LastIndex - 1) = ipItem
    End If
    

End Property

''Public Property Get Capacity() As Long
''    Capacity = s.Size
''End Property
''
'''@("Resizes the host array to the specifies capacity, existing Hosts in the capacity range are preserved")
''Public Property Let Capacity(ByVal ipCapacity As Long)
''    s.Size = ipCapacity
''    Resize
''End Property
'
'
'@Description("Returns the index of the Item")
Public Function IndexOf _
( _
    ByVal ipItem As Variant, _
    Optional ByVal ipStart As Long = 1, _
    Optional ByVal ipRun As Long = 0 _
) As Long
Attribute IndexOf.VB_Description = "Returns the index of the Item"
    IndexOf = -1
    
    If s.LastIndex < 1 Then
        Exit Function
    End If
    
    If ipStart < 1 Or ipStart > s.LastIndex Then
        Exit Function
    End If
    
    Dim myEnd As Long
    If ipRun = 0 Then
        myEnd = s.LastIndex
    Else
        myEnd = ipStart + ipRun - 1
        If myEnd > s.LastIndex Then
            myEnd = s.LastIndex
        End If
    End If
    
    Dim myItems As IterItems
    Set myItems = IterItems(s.Host).FTS(ipStart, myEnd)
    Do
        If ComparerHelpers.Equals(myItems.CurItem(0), ipItem) Then
            IndexOf = myItems.CurKey(0)
            Exit Function
        End If
    
    Loop While myItems.MoveNext
    
    
End Function

Public Function LastIndexOf _
( _
    ByVal ipItem As Variant, _
    Optional ByVal ipStart As Long = 1, _
    Optional ByVal ipRun As Long = 0 _
) As Long
    
   If s.LastIndex < 1 Then
        LastIndexOf = -1
        Exit Function
    End If
    
    If ipStart < 1 Or ipStart > s.LastIndex Then
        LastIndexOf = -1
        Exit Function
    End If
    
    Dim myEnd As Long
    If ipRun = 0 Then
        myEnd = s.LastIndex
    Else
        myEnd = ipStart + ipRun - 1
        If myEnd > s.LastIndex Then
            myEnd = s.LastIndex
        End If
    End If
    
    Dim myItems As IterItems
    Set myItems = IterItems(s.Host).FTS(ipStart, myEnd).MoveToEndIndex
    Do
        If ComparerHelpers.Equals(myItems.CurItem(0), ipItem) Then
            LastIndexOf = myItems.CurKey(0)
            Exit Function
        End If
    
    Loop While myItems.MovePrev
    
    LastIndexOf = -1
    
End Function


'@Description("Add a single item.  Returns the index at which added.  For compatibility with ArrayList")
Public Function Add(ByRef ipItem As Variant) As Long
Attribute Add.VB_Description = "Add a single item.  Returns the index at which added.  For compatibility with ArrayList"

    Dim myIndex As Long
    myIndex = GetNextIndex

    If VBA.IsObject(ipItem) Then
        Set s.Host(myIndex) = ipItem
    Else
        s.Host(myIndex) = ipItem
    End If
    
    Add = myIndex
    
End Function


'@Description("Add Items in the paramarray to the  )
Public Function AddItems(ParamArray ipParamarray() As Variant) As SeqA

    If ArrayInfo.LacksItems(VBA.CVar(ipParamarray)) Then
        Set AddItems = Me
        Exit Function
    End If

    AddRange VBA.CVar(ipParamarray)

    Set AddItems = Me
    
End Function

'@Description("Add an array,  list type, dictionary type, or characters of a string")
Public Function AddRange(ByVal ipRange As Variant) As SeqA
Attribute AddRange.VB_Description = "Add an array,  list type, dictionary type, or characters of a string"

    Set AddRange = Me
    
    Dim myItems As IterItems
    Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        If GroupInfo.IsDictionary(ipRange) Then
            Me.Add Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            Me.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext

End Function


Public Property Get Item(ByVal ipIndex As Long) As Variant
    
    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Get_Item"
    
    Dim myItem As Variant
    myItem = Array(s.Host(ipIndex))
    
    If VBA.IsObject(myItem(0)) Then
        Set Item = myItem(0)
    Else
        Item = myItem(0)
    End If
   
End Property

Public Property Let Item(ByVal ipIndex As Long, ByVal ipItem As Variant)

    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Get_Item"
    
    s.Host(ipIndex) = ipItem
 
End Property

Public Property Set Item(ByVal ipIndex As Long, ByVal ipItem As Variant)
    
    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.LastIndex, "VBALib.SeqA.Get_Item"
    'assigning using s.host(index) does not work
    ' but the variant copy method is successful
    VariantCopy s.Host(ipIndex), ipItem
'    Dim myArray As Variant
'    myArray = s.Host
'
'
'    Set myArray(ipIndex) = ipItem
'    s.Host = myArray
    
End Property


Public Function Insert(ByVal ipIndex As Long, ByVal ipItem As Variant) As Long

    If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
        Insert = -1
        Exit Function
    End If

    MoveUp ipIndex, 1
    
    If VBA.IsObject(ipItem) Then
        Set s.Host(ipIndex) = ipItem
    Else
        s.Host(ipIndex) = ipItem
    End If
  
    Insert = ipIndex

End Function

Public Function InsertItems(ByVal ipIndex As Long, ParamArray ipParamarray() As Variant) As SeqA
    Set InsertItems = InsertRange(ipIndex, VBA.CVar(ipParamarray))
End Function


Public Function InsertRange(ByVal ipIndex As Long, ByRef ipRange As Variant) As SeqA

    If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
        Set InsertRange = Me
        Exit Function
    End If

    GuardInvalidRangeItem ipRange, "VBALib.SeqA.InsertRange"
    
    Dim myItems As IterItems
    Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Set InsertRange = Me
        Exit Function
    End If
    
    Dim myIndex As Long
    myIndex = ipIndex
    Do
        If GroupInfo.IsDictionary(ipRange) Then
            Insert myIndex, Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            Insert myIndex, Array(myItems.CurKey(0), myItems.CurItem(0))
        End If
    Loop While myItems.MoveNext
    
    Set InsertRange = Me
    
End Function

'@Description("Removes the first encountered item from the Seq")
Public Function Remove(ByRef ipItem As Variant) As Long
Attribute Remove.VB_Description = "Removes the first encountered item from the Seq"

    Remove = -1
    
    If s.LastIndex < FIRST_INDEX Then
        Exit Function
    End If
    
    Dim myIndex As Long
    myIndex = IndexOf(ipItem)
    
    If myIndex = -1 Then
        Exit Function
    End If
    
    MoveDown myIndex, 1

    Remove = myIndex
    
End Function

'@Description("Removes the first encountered item from the Seq")
Public Function RemoveAt(ByRef ipIndex As Long) As Long
Attribute RemoveAt.VB_Description = "Removes the first encountered item from the Seq"

    RemoveAt = -1
    
    If s.LastIndex < FIRST_INDEX Then
        Exit Function
    End If
    
    If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
        Exit Function
    End If
    
    MoveDown ipIndex, 1
        
    RemoveAt = ipIndex
    
End Function

'@Description "Removes the first encountered item for each item in the paramarray"
Public Function RemoveItems(ParamArray ipParamarray() As Variant) As SeqA
Attribute RemoveItems.VB_Description = "Removes the first encountered item for each item in the paramarray"

    If s.LastIndex < 1 Then
        Set RemoveItems = Me
        Exit Function
    End If
    
    If ArrayInfo.LacksItems(VBA.CVar(ipParamarray)) Then
        Set RemoveItems = Me
        Exit Function
    End If
    
    Dim myItem As Variant
    For Each myItem In ipParamarray
    
        Dim myIndex As Long
        myIndex = IndexOf(myItem)
        
        If myIndex > 0 Then
            MoveDown myIndex, 1
        End If
        
   Next
   
    Set RemoveItems = Me
    
End Function


'@Description("Removes the first encountered item from the SeqA")
Public Function RemoveItemsAt(ParamArray ipParamarray() As Variant) As SeqA
Attribute RemoveItemsAt.VB_Description = "Removes the first encountered item from the SeqA"

    Set RemoveItemsAt = Me
    
    If s.LastIndex < 1 Then
        Exit Function
    End If
    
    Dim myParams As Variant
    myParams = ipParamarray
    
    If ArrayInfo.LacksItems(myParams) Then
        Exit Function
    End If
    
    ' The indexes may be in any order so need sorting
    Sorters.ShakerSortArray myParams
    
    Dim myItems As IterItems: Set myItems = IterItems(myParams)
    Do
        MoveDown myItems.CurOffset(0) + 1, 1
    Loop While myItems.MoveNext
    
    
End Function


'@Description("Remove items in the specified range of Indexes")
Public Function RemoveRange(ByRef ipRange As Variant) As SeqA
Attribute RemoveRange.VB_Description = "Remove items in the specified range of Indexes"
  
    Set RemoveRange = Me
    
    If s.LastIndex < FirstIndex Then
        Exit Function
    End If
  
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        MoveDown IndexOf(myItems.CurItem(0)), 1
    Loop While myItems.MoveNext
            
End Function


'@Description("Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use")
Public Function RemoveAtRange(ByRef ipRange As Variant) As SeqA
Attribute RemoveAtRange.VB_Description = "Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use"
  
    Set RemoveAtRange = Me
    
    If s.LastIndex < FIRST_INDEX Then
        Exit Function
    End If
    
    ' We need to utilise Iteritems twice
    ' because we need to sort the values in ipRange

    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Dim myA As Variant
    ReDim myA(1 To myItems.Size)
    
    Do
        Dim myItem As Variant
        myItem = Array(myItems.CurItem(0))
        If VBA.IsObject(myItem(0)) Then
            Set myA(myItems.CurOffset(0)) = myItem(0)
        Else
            myA(myItems.CurOffset(0)) = myItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Sorters.ShakerSortArray myA
    
    '@Ignore AssignmentNotUsed
    Set myItems = IterItems(myA)
    
    Do
        MoveDown myItems.CurOffset(0), 1
    Loop While myItems.MoveNext
        
End Function


Public Function RemoveAll(ParamArray ipParamarray() As Variant) As SeqA

    Set RemoveAll = Me
    
    If s.LastIndex < FIRST_INDEX Then
        Exit Function
    End If
    
    If ArrayInfo.LacksItems(VBA.CVar(ipParamarray)) Then
        s.LastIndex = 0
        s.Size = DEFAULT_CHUNK
        Resize
        Exit Function
    End If
    
    Dim myItem As Variant
    For Each myItem In ipParamarray
        RemoveAllSingleItem myItem
    Next
    
End Function


Private Sub RemoveAllSingleItem(ByRef ipItem As Variant)

    'ReDim Preserve s.Host(FIRST_INDEX, s.LastIndex)
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=s.LastIndex).MoveToEndIndex
    Do
        If ComparerHelpers.Equals(myItems.CurItem(0), ipItem) Then
            MoveDown myItems.CurKey(0), 1
        End If
    Loop While myItems.MovePrev
    
End Sub

'Description@("Removes all Items from the SeqA")
Public Function Clear() As SeqA
    Set Clear = RemoveAll
End Function


'@Description("Removes all Items by replacing the Host collection with a new collection")
Public Function Reset() As SeqA
Attribute Reset.VB_Description = "Removes all Items by replacing the Host collection with a new collection"
    ReDim s.Host(FIRST_INDEX To DEFAULT_CHUNK)
    s.LastIndex = 0
    Set Reset = Me
End Function


Public Function Fill(ByRef ipItem As Variant, Optional ByVal ipCount As Long = 1) As SeqA

    Set Fill = Me
    
    If ipCount < FIRST_INDEX Then
        Exit Function
    End If
    
    Dim myCount As Long
    For myCount = FIRST_INDEX To ipCount
        Me.Add ipItem
    Next
    
End Function


'@Description("Returns the first N items of the SeqA, Default 1")
Public Function Head(Optional ByVal ipSplitAfter As Long = 1) As SeqA
Attribute Head.VB_Description = "Returns the first N items of the SeqA, Default 1"
    
    Set Head = SeqA.Deb
    
    If s.LastIndex <= FIRST_INDEX Then
        Exit Function
    End If

    If ipSplitAfter < FIRST_INDEX Then
        Exit Function
    End If
    
    If ipSplitAfter >= s.LastIndex Then
        Set Head = Me.Clone
        Exit Function
    End If
    
    Set Head = Me.Slice(FIRST_INDEX, ipSplitAfter)

End Function


'@Description("Returns the Items after SplitAfter, Default is Index 2")
Public Function Tail(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As SeqA
Attribute Tail.VB_Description = "Returns the Items after SplitAfter, Default is Index 2"

    Set Tail = SeqA.Deb
    
    If s.LastIndex < FIRST_INDEX Then
        Exit Function
    End If
    
    If ipSplitAfter >= s.LastIndex Then
        Exit Function
    End If
    
    If ipSplitAfter < FirstIndex Then
        Set Tail = Me.Clone
        Exit Function
    End If
    
    Set Tail = Me.Slice(ipSplitAfter + FIRST_INDEX)

End Function

Public Function HoldsItem(ByRef ipItem As Variant) As Boolean

    HoldsItem = False
    
    If s.LastIndex < FIRST_INDEX Then
        Exit Function
    End If

    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=s.LastIndex)
    Do
        If ComparerHelpers.Equals(myItems.CurItem(0), ipItem) Then
            HoldsItem = True
            Exit Function
        End If
    Loop While myItems.MoveNext

End Function

Public Function Contains(ByRef ipItem As Variant) As Boolean
    Contains = Me.HoldsItem(ipItem)
End Function

Public Function LacksItem(ByRef ipItem As Variant) As Boolean
    LacksItem = Not HoldsItem(ipItem)
End Function

Public Function HoldsItems() As Boolean
    HoldsItems = s.LastIndex >= FIRST_INDEX
End Function

Public Function LacksItems() As Boolean
    LacksItems = s.LastIndex < FIRST_INDEX
End Function
'
'
''@Description("Makes a shallow copy of the SeqA to the provided array")
'Public Function CopyTo(ByRef ipArray As pArray) As SeqA
'
''    ' Dim myArray As Variant = ipoArr.Cargo
''     If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''     If Guard.LacksItems(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''     If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''     'If Guard.SizeMismatch(s.lastindex > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
'    If Var.LacksItems(ipArray.Cargo) Then
'        Return Me
'    End If
'
'    Dim myIndex  As Long
'    For myIndex = FirstIndex To LastIndex
'
'        Dim myItem As Variant = s.Host(myIndex)
'
'        If VBA.IsObject(myItem) Then
'            Set ipArray.Cargo(myIndex) = myItem
'        Else
'            ipArray.Cargo(myIndex) = myItem
'        End If
'
'        If myIndex > Var.LastIndex(ipArray.Cargo) Then
'            Exit For
'        End If
'    Next
'
'    Return Me
'
'End Function
'
'
'Public Function CopyTo(ByRef ipArray As pArray, ByVal ipArrayStartIndex As Long) As SeqA
'
'    '  ' Dim myArray As Variant = ipoArr.Cargo
'    ' If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' If Guard.LacksItems(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' 'If Guard.SizeMismatch(s.lastindex > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
'
'    Dim myArrayIndex  As Long = ipArrayStartIndex
'
'    Dim myHostIndex As Long
'    For myHostIndex = FirstIndex To LastIndex
'        Dim myItem As Variant = s.Host(myHostindex)
'
'        If VBA.IsObject(myItem) Then
'            Set ipArray.Cargo(myArrayIndex) = myItem
'        Else
'            ipArray.Cargo(myArrayIndex) = myItem
'        End If
'
'        myArrayIndex += 1
'        If myArrayIndex >= Var.LastIndex(ipArray.Cargo) Then
'            Exit For
'        End If
'    Next
'
'    Return Me
'
'End Function
'
'Public Function CopyTo _
'() '( _
'    ByVal ipSeqStartIndex As Long, _
'    ByRef ipArray As pArray, _
'    ByVal ipArrayStartIndex As Long, _
'    ByVal ipArrayCount As Long _
') As SeqA IMplements SeqA.CopyTo
'
'    '  ' Dim myArray As Variant = ipoArr.Cargo
'    ' If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' If Guard.LacksItems(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'    ' 'If Guard.SizeMismatch(s.lastindex > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
'
'    Dim myArrayIndex  As Long = ipArrayStartIndex
'
'    Dim myHostIndex As Long
'    For myHostIndex = ipSeqStartIndex - 1 To LastIndex
'        Dim myItem As Variant = s.Host.Item(myHostIndex)
'
'        If VBA.IsObject(myItem) Then
'            Set ipArray.Cargo(myArrayIndex) = myItem
'        Else
'            ipArray.Cargo(myArrayIndex) = myItem
'        End If
'
'        myArrayIndex += 1
'
'        If myArrayIndex > Var.LastIndex(ipArray.Cargo) Then
'            Exit For
'        End If
'
'    Next
'
'    Return Me
'
'End Function
'
'Public Function GetRange(ByVal ipStartIndex As Long, Optional ByVal ipRun As pNum = Nothing, ByVal ipEndIndex As pNum = Nothing) As SeqA Implements SeqA.GetRange
'    Return Slice(PN(ipStartIndex), ipRun, ipEndIndex)
'End Function
'
'
'Public Function SplitAt(ByVal ipIndex As Long, Optional ByVal ipSplitType As e_SeqSplit = e_SeqSplit.m_Before) As SeqA
'
'    Dim mySer As SER = Ranges.ResolveStartEndRun(FirstIndex, LastIndex, ipIndex)
'
'    Dim mySplit As SeqA
'    If ipSplitType = m_Before Then
'         Set mySplit = SeqA.Deb.AddItems(PL(Me.Slice(PN(1), PN(mySER.NativeStart - 1)), Me.Slice(PN(mySER.NativeStart))))
'    Else
'        Set mySplit = SeqA.Deb.AddItems(PL(Me.Slice(PN(1), PN(mySER.NativeStart)), Me.Slice(PN(mySER.NativeStart + 1))))
'
'    End If
'    Return mySplit
'
'
'End Function
'
''@Description("Splits the SeqA at the first occurence of ipItem")
'Public Function SplitAtItem(ByVal ipItem As Variant, Optional ByVal ipSplitType As e_SeqSplit = e_SeqSplit.m_Before) As SeqA
'    Dim mySplit As SeqA
'    Dim myItems As IterItems = IterItems(Me)
'    Do
'
'        If myItems.GetItem = ipItem.Cargo Then
'            Dim myIndex As Long = myItems.Key(0).cargo
'            If ipSplitType = e_SeqSplit.m_Before Then
'                Set mySplit = SeqA.Deb.AddItems(PL(Me.Slice(PN(1), PN(myIndex - 1)), Me.Slice(PN(myIndex))))
'            Else
'                Set mySplit = SeqA.Deb.AddItems(PL(Me.Slice(PN(1), PN(myIndex)), Me.Slice(PN(myIndex + 1))))
'            End If
'        End If
'
'    Loop While myItems.MoveNext
'
'End Function
'



'@Description("Returns a new Seq where each item in the Host has been mutated by the function provided by IMapper")
Public Function MapIt(ByVal ipMapper As IMapper) As SeqA
Attribute MapIt.VB_Description = "Returns a new Seq where each item in the Host has been mutated by the function provided by IMapper"

    Dim myS As SeqA
    Set myS = SeqA.Deb
    Set MapIt = myS
    
    If s.LastIndex < FirstIndex Then
        Exit Function
    End If

    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=Me.LastIndex)
    Do
        myS.Add ipMapper.ExecMapper(myItems.CurItem(0))(0)
    Loop While myItems.MoveNext

End Function

'@Description("Mutates the SeqC in place by applying the function in IMapper to each item")
Public Function MappedIt(ByRef ipMapper As IMapper) As SeqA
Attribute MappedIt.VB_Description = "Mutates the SeqC in place by applying the function in IMapper to each item"
    
    Set MappedIt = Me
    
    If s.LastIndex < FIRST_INDEX Then
        Exit Function
    End If
    
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=Me.LastIndex)
    Do
   
        Dim myItem As Variant
        myItem = ipMapper.ExecMapper(myItems.CurItem(0))
        
        If VBA.IsObject(myItem(0)) Then
            Me.Item(myItems.CurKey(0)) = myItem(0)
        Else
            Me.Item(myItems.CurKey(0)) = myItem(0)
        End If
        
    Loop While myItems.MoveNext

End Function


Public Function FilterIt(ByVal ipComparer As IComparer) As SeqA

    Dim myS As SeqA
    Set myS = SeqA.Deb
    Set FilterIt = myS
    
    If s.LastIndex < FIRST_INDEX Then
        Exit Function
    End If

    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=Me.LastIndex)
    Do
    
        If ipComparer.ExecCmp(myItems.CurItem(0)) Then
            myS.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext

    Set FilterIt = myS

End Function

' Does not generate an interim SeqA as would filterIt followed by Count.
Public Function CountIt(ByVal ipComparer As IComparer) As Long

    If s.LastIndex < FIRST_INDEX Then
        CountIt = -1
        Exit Function
    End If
    
    Dim myCount As Long
    myCount = 0
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=Me.LastIndex)
    Do
    
        If ipComparer.ExecCmp(myItems.CurItem(0)) Then
            myCount = myCount + 1
        End If
        
    Loop While myItems.MoveNext

    CountIt = myCount

End Function

'@Description("Returns a single Host based on the Reducer").
Public Function ReduceIt(ByRef ipReducer As IReducer) As Variant
    'ReduceIt = ipReducer.ExecReduction(Me)
    
    If s.LastIndex < FIRST_INDEX Then
        ReduceIt = Null
        Exit Function
    End If
    
    Dim myItem As Variant
    myItem = Array(ipReducer.ExecReduction(Me))
    
    If VBA.IsObject(myItem(0)) Then
       Set ReduceIt = myItem(0)
    Else
        ReduceIt = myItem(0)
    End If
    
End Function


Public Property Get myTypename() As String
   myTypename = MY_TYPENAME
End Property


'@Description("Adds one or more items")
Public Function Push(ParamArray ipParamarray() As Variant) As SeqA
Attribute Push.VB_Description = "Adds one or more items"
     Set Push = AddRange(VBA.CVar(ipParamarray))
End Function

' Enqueue - add at end
' Dequeue - removes from position 1

' Push = add at end
' Pop remove from end
'
Public Function PushRange(ByRef ipRange As Variant) As SeqA
    Set PushRange = AddRange(ipRange)
End Function


Public Function Pop() As Variant

    If s.LastIndex < FIRST_INDEX Then
        Pop = Null
        Exit Function
    End If
    
    Dim myItem As Variant
    myItem = Array(s.Host(s.LastIndex))
    
    If VBA.IsObject(myItem(0)) Then
        Set Pop = myItem(0)
    Else
        Pop = myItem(0)
    End If
    
    MoveDown s.LastIndex, 1
    
End Function

Public Function PopRange(Optional ByVal ipCount As Long = 1) As SeqA

    If ipCount < 0 Then
        Set PopRange = SeqA.Deb
        Exit Function
    End If
    
    If ipCount > s.LastIndex Then
        Set PopRange = Me.Reversed
        Me.RemoveAll
        Exit Function
    End If
    
    Dim myS As SeqA
    Set myS = SeqA.Deb
    
    Dim myIndex As Long
    For myIndex = s.LastIndex To s.LastIndex - ipCount + 1 Step -1
        myS.Add s.Host(myIndex)
    Next
    
    MoveDown myIndex + 1, ipCount
    
    Set PopRange = myS
    
End Function


Public Function enQueue(ParamArray ipParamarray() As Variant) As SeqA
   Set enQueue = AddRange(VBA.CVar(ipParamarray))
End Function


Public Function EnqueueRange(ByRef ipRange As Variant) As SeqA
   Set EnqueueRange = AddRange(ipRange)
End Function

Public Function Dequeue() As Variant

    If s.LastIndex < FIRST_INDEX Then
        Dequeue = Null
        Exit Function
    End If
    
    Dim myItem As Variant
    myItem = Array(s.Host(FIRST_INDEX))
    
    If VBA.IsObject(myItem(0)) Then
        Set Dequeue = myItem(0)
    Else
        Dequeue = myItem(0)
    End If
    
    MoveDown FIRST_INDEX, 1
    
End Function


Public Function DequeueRange(Optional ByVal ipCount As Long = 1) As SeqA

    Set DequeueRange = SeqA.Deb
    
    If s.LastIndex < FIRST_INDEX Then
        Exit Function
    End If

    If ipCount < 0 Then
        Exit Function
    End If
    
    If ipCount > s.LastIndex Then
        Set DequeueRange = Me.Clone
        Me.RemoveAll
        Exit Function
    End If
    
    Dim myS As SeqA
    Set myS = SeqA.Deb
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(FIRST_INDEX, ipCount)
    Do
        myS.Add myItems.CurItem(0)
    Loop While myItems.MoveNext
    
    MoveDown FIRST_INDEX, ipCount
    
    Set DequeueRange = myS
    
End Function

'@Description("Returns a new sequence sorted in 'Ascending' order"
 Public Function Sort() As SeqA
 'first
 Dim myS As SeqA
    Set myS = Me.Clone
    Sorters.ShakerSortSeq myS
    Set Sort = myS
     
 End Function


'@description("Sorts the seq in place")
Public Function Sorted() As SeqA
Attribute Sorted.VB_Description = "Sorts the seq in place"
    Sorters.ShakerSortSeq Me
     Set Sorted = Me
End Function


'@Description("Swaps the Items at the specified indexes")
Public Function Swap(ByRef ipLHSIndex As Long, ByRef ipRHSIndex As Long) As SeqA
Attribute Swap.VB_Description = "Swaps the Items at the specified indexes"

    Dim myTemp As Variant
    
    If VBA.IsObject(s.Host(ipLHSIndex)) Then
        Set myTemp = s.Host(ipLHSIndex)
    Else
        myTemp = s.Host(ipLHSIndex)
    End If
    
    If VBA.IsObject(s.Host(ipRHSIndex)) Then
        Set s.Host(ipLHSIndex) = s.Host(ipRHSIndex)
    Else
        s.Host(ipLHSIndex) = s.Host(ipRHSIndex)
    End If
    
    If VBA.IsObject(myTemp) Then
        Set s.Host(ipRHSIndex) = myTemp
    Else
        s.Host(ipRHSIndex) = myTemp
    End If

    Set Swap = Me
    
End Function


Public Function Reverse() As SeqA

    Dim myFirst As Long
    myFirst = FIRST_INDEX
    
    Dim myLast As Long
    myLast = s.LastIndex
    
    Dim mySwap As Variant

    Do While myFirst < myLast
     
        If VBA.IsObject(s.Host(myFirst)) Then
            Set mySwap = s.Host(myFirst)
        Else
            mySwap = s.Host(myFirst)
        End If
        
        If VBA.IsObject(s.Host(myLast)) Then
            Set s.Host(myFirst) = s.Host(myLast)
        Else
            s.Host(myFirst) = s.Host(myLast)
        End If
        
        If VBA.IsObject(mySwap) Then
            Set s.Host(myLast) = mySwap
        Else
            s.Host(myLast) = mySwap
        End If
        
         myFirst = myFirst + 1
         myLast = myLast - 1
         
     Loop

     
    Set Reverse = Me

 End Function

 Public Function Reversed() As SeqA

     Dim myS As SeqA
     Set myS = SeqA.Deb
     
     If s.LastIndex < FIRST_INDEX Then
        Set Reversed = myS
        Exit Function
    End If
     
     Dim myIndex As Long
     For myIndex = s.LastIndex To FIRST_INDEX Step -1
        myS.Add s.Host(myIndex)
    Next
     
    Set Reversed = myS

 End Function
 
 Public Function IsUnique() As Boolean

    If LacksItems Then
        IsUnique = False
        Exit Function
    End If
    
    Dim myH As cHashC
    Set myH = New cHashC
    
    Dim myIndex As Long
    For myIndex = FIRST_INDEX To s.LastIndex
        If myH.Exists(s.Host(myIndex)) Then
            IsUnique = False
            Exit Function
        Else
            myH.Add s.Host(myIndex)
        End If
    Next

    IsUnique = True

End Function


Public Function IsNotUnique() As Boolean
    IsNotUnique = Not IsUnique
End Function

'@Description("Returns the a new seq with the unique subset of the host Seq")
Public Function Dedup() As SeqA
Attribute Dedup.VB_Description = "Returns the a new seq with the unique subset of the host Seq"

    Dim myS As SeqA
    Set myS = SeqA.Deb
    
    Select Case s.LastIndex
    
        Case Is < FIRST_INDEX:        Set Dedup = myS
            
        Case FIRST_INDEX:             Set Dedup = Me.Clone

        Case Else

            Dim myIndex As Long
            For myIndex = FIRST_INDEX To s.LastIndex
                If myS.LacksItem(s.Host(myIndex)) Then
                    myS.Add s.Host(myIndex)
                End If
            Next
    
            Set Dedup = myS
            
    End Select
    
End Function


'@Description("Removes duplicate items from the seq")
Public Function Deduped() As SeqA
Attribute Deduped.VB_Description = "Removes duplicate items from the seq"

    If LacksItems Then
        Set Deduped = Me
        Exit Function
    End If
    
    Dim myH As cHashC
    Set myH = New cHashC
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=Me.LastIndex).MoveToEndIndex
    Do
        If myH.Exists(myItems.CurItem(0)) Then
            MoveDown myItems.CurKey(0), 1
        Else
            myH.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MovePrev
    
End Function


Public Function Freq() As KvpC

    Dim myK As KvpC
    Set myK = KvpC.Deb
    Set Freq = myK
    If LacksItems Then
        Set Freq = myK
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=Me.LastIndex)
    Do
        If myK.LacksKey(myItems.CurItem(0)) Then
            myK.Add myItems.CurItem(0), 1
        Else
            myK.Item(myItems.CurItem(0)) = myK.Item(myItems.CurItem(0)) + 1
        End If
        
    Loop While myItems.MoveNext
    
End Function


Public Function SetOf(ByRef ipSet As e_SetoF, ByRef ipRangeItem As SeqA) As SeqA

    Select Case ipSet

        Case e_SetoF.m_Common:           Set SetOf = SetOfCommon(ipRangeItem)
        Case e_SetoF.m_HostOnly:         Set SetOf = SetOfHostOnly(ipRangeItem)
        Case e_SetoF.m_ParamOnly:        Set SetOf = SetOfParamOnly(ipRangeItem)
        Case e_SetoF.m_NotCommon:        Set SetOf = SetOfNotCommon(ipRangeItem)
        Case e_SetoF.m_Unique:           Set SetOf = SetofUnique(ipRangeItem)
        Case Else
            Err.Raise 17 + vbObjectError, _
                "VBALib.Seq.SetOf", _
                Fmt.Text("Invalid e_set member. Expecting {0} to {1}. Got {2}", e_SetoF.m_First, e_SetoF.m_Last, ipSet)
                
    End Select

 End Function


Private Function SetOfCommon(ByRef ipseq As SeqA) As SeqA

    Dim myS As SeqA
    Set myS = SeqA.Deb
    Set SetOfCommon = myS
    
    If LacksItems Or ipseq.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    Dim myItems As IterItems: Set myItems = IterItems(ipseq)
    Do
        If myS.LacksItem(myItems.CurItem(0)) Then
            myS.RemoveAt myItems.CurKey(0)
        End If
    Loop While myItems.MoveNext
 
End Function


Private Function SetOfHostOnly(ByRef ipseq As SeqA) As SeqA

    Dim myS As SeqA
    Set myS = SeqA.Deb
    Set SetOfHostOnly = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    If ipseq.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(ipseq)
    Do
        If myS.HoldsItem(myItems.CurItem(0)) Then
            myS.Remove myItems.CurItem(0)
        End If
    Loop While myItems.MoveNext
    
End Function

Private Function SetOfParamOnly(ByRef ipseq As SeqA) As SeqA
 
    Dim myS As SeqA
    Set myS = SeqA.Deb
    Set SetOfParamOnly = myS
    
    If ipseq.LacksItems Then
        Exit Function
    End If
    
    Set myS = ipseq.Dedup
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=Me.LastIndex)
    Do
        If myS.HoldsItem(myItems.CurItem(0)) Then
            myS.Remove myItems.CurItem(0)
        End If
    Loop While myItems.MoveNext

End Function

Private Function SetOfNotCommon(ByRef ipseq As SeqA) As SeqA

    Dim myS As SeqA
    Set myS = SeqA.Deb
    Set SetOfNotCommon = myS
    
    If LacksItems And ipseq.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipEndIndex:=Me.LastIndex)
    Do
    
        If ipseq.LacksItem(myItems.CurItem(0)) Then
            If myS.LacksItem(myItems.CurItem(0)) Then
                myS.Add myItems.CurItem(0)
            End If
        End If
        
    Loop While myItems.MoveNext
    
    '@Ignore AssignmentNotUsed
    Set myItems = IterItems(ipseq)
    Do
    
        If Me.LacksItem(myItems.CurItem(0)) Then
            If myS.LacksItem(myItems.CurItem(0)) Then
                myS.Add myItems.CurItem(0)
            End If
        End If
        
    Loop While myItems.MoveNext
    
End Function

Private Function SetofUnique(ByRef ipseq As SeqA) As SeqA

    Dim myS As SeqA
    Set myS = SeqA.Deb
    Set SetofUnique = myS
    
    If Me.LacksItems And ipseq.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    Dim myItems As IterItems: Set myItems = IterItems(ipseq)
    Do
        Dim myItem As Variant
        myItem = Array(myItems.CurItem(0))
        
        If myS.LacksItem(myItem(0)) Then
            myS.Add myItem(0)
        End If
    Loop While myItems.MoveNext

End Function


'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' Private methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
'@Description("Get the index of the next item in the seq")
Private Function GetNextIndex() As Long
Attribute GetNextIndex.VB_Description = "Get the index of the next item in the seq"

    s.LastIndex = s.LastIndex + 1
    If s.LastIndex > s.Size Then

            s.Size = s.Size + DEFAULT_CHUNK
            Resize

    End If

   GetNextIndex = s.LastIndex

End Function

'@Description("Moves all elements from ipIndex to s.lastindex down by ipCount places")
Private Sub MoveDown(ByVal ipToIndex As Long, ByVal ipCount As Long)
Attribute MoveDown.VB_Description = "Moves all elements from ipIndex to s.lastindex down by ipCount places"

    If ipCount < FIRST_INDEX Then
        Exit Sub
    End If

    ' If ipIndex < FirstIndex Or ipIndex > s.lastindex Then
    '     Exit Sub
    ' End If

    Dim myToIndex As Long
    myToIndex = ipToIndex

    Dim myFromIndex As Long
    For myFromIndex = ipToIndex + ipCount To s.LastIndex

        If VBA.IsObject(s.Host(myFromIndex)) Then
            Set s.Host(myToIndex) = s.Host(myFromIndex)
        Else
            s.Host(myToIndex) = s.Host(myFromIndex)
        End If
       ' s.host(myFromIndex) = Empty
        myToIndex = myToIndex + 1


    Next
    Dim myIndex As Long
    For myIndex = s.LastIndex - ipCount + 1 To s.LastIndex
        s.Host(myIndex) = Empty
    Next
    s.LastIndex = s.LastIndex - ipCount

End Sub
'
'@Description("Moves all elements from ipIndex to s.lastindex up by ipCount places")
Private Sub MoveUp(ByVal ipIndex As Long, Optional ByVal ipCount As Long = 1)
Attribute MoveUp.VB_Description = "Moves all elements from ipIndex to s.lastindex up by ipCount places"

    If ipCount < FIRST_INDEX Then
        Exit Sub
    End If

    If ipIndex < FIRST_INDEX Or ipIndex > s.LastIndex Then
        Exit Sub
    End If


    Do While s.LastIndex + ipCount > s.Size
        DoEvents
        s.Size = s.Size + DEFAULT_CHUNK
        Resize

    Loop

    Dim myToIndex As Long
    myToIndex = s.LastIndex + ipCount
    Dim myFromIndex As Long
    myFromIndex = s.LastIndex

    Dim myIterations As Long
    For myIterations = 0 To s.LastIndex - ipIndex

        Swap myToIndex - myIterations, myFromIndex - myIterations

    Next

    s.LastIndex = s.LastIndex + ipCount

End Sub

Private Sub Resize()
    If s.Size < FIRST_INDEX Then
        ReDim s.Host(FIRST_INDEX To DEFAULT_CHUNK)
    Else
        ReDim Preserve s.Host(FIRST_INDEX To s.Size)
    End If

    ' The last index is not set here because it depends on the context where
    ' resize was called
    ' Last index should be adjusted at the calling site.
End Sub
