VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "SeqL"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_Description = "SeqL is a multipurpose Collection/ArrayList replacement.  It uses a double linked list to store the items.  Items are access using a single 1 based index. Multi dimensions addressing can be converted to linrear addressing using ArrayInfo.GetIndex. For a Keyed collection, use one of the Kvp classes"
'@PredeclaredId
'@Exposed
'@Folder("Seq")
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C

'@ModuleDescription("SeqL is a multipurpose Collection/ArrayList replacement.  It uses a double linked list to store the items.  Items are access using a single 1 based index. Multi dimensions addressing can be converted to linrear addressing using ArrayInfo.GetIndex. For a Keyed collection, use one of the Kvp classes")
' SeqL uses the VBA Collection class as a host for the items
' Other versions of SeqL are available (SeqL, SeqLL, SeqLH, SeqLT)

Option Explicit
'Implements SeqL


Private Type Host
    Count                                       As Long
End Type
Private Const MY_TYPENAME                       As String = "SeqL"
Private Const FIRST_INDEX                       As Long = 1

Private Type State

    Root                                        As SeqLNode
    Last                                        As SeqLNode
    Host                                        As Host ' emulates the Host object in other seQ
   
    
End Type

Private s                                       As State

' Deb is a Factory method of the PredeclaredId which returns a new instance of SeqL
'=================================================================================
' The input for Deb is a ParamArray.
' The ParamArray is interpreted according to the folowing rules
' If the ParamArray contains no Items
' - A empty SeqLuence (count = 0)
' If the ParamArray has 2 or more items
' - A SeqL of size equal to the ParamArray, items as generated by for each over the ParamArray
' If the ParamArray has a single Item
' - Number: SeqL with specified capacity with each Item being the Value 'Empty'
' - String: A SeqL whose capacity is the length of the string with one character per Item
' - Array: SeqL of items as provided by For Each over the array.  Multidimension arrays are flattened but the position in the original array can be calculated by the user if required. See also Bind
' - Dictionaries: a SeqL of key/value arrays as generated from for each on the Keys array.
' - Collection: The collection is copied to the Host collection.  There is no refererence link to the original collection (See Host Property)
' - SeqL: Items as generated by for each on the SeqL
' - mscorlib Arraylist: Items as generated by for each on the arrylist
' - mscorlib Stack: Items as generated by for each on the stack
' - mscorlib Queue: Items as generated by for eac on the queue


'@DefaultMember
Public Function Deb(ParamArray ipParamarray() As Variant) As SeqL
Attribute Deb.VB_UserMemId = 0
    
    With New SeqL
        Set Deb = .ConstructInstance(VBA.CVar(ipParamarray))
    End With
   
End Function

Friend Function ConstructInstance(ByRef ipFPA As Variant) As SeqL
      
    Set s.Root = Nothing
    Set s.Last = s.Root
    
    ' Check to see if we return a default 'empty' seq
    If ArrayInfo.LacksItems(ipFPA) Then
        
        Set ConstructInstance = Me
        Exit Function
    End If

    ' ipParamArray contains one or more items so return a Seq containing a copy
    ' of the item(s) in the forwarded paramarray.
    ' The nature of the host (s.root and s.last) means
    ' that there is no bind method for SeqL
    ' Resolve the items in the forwarded paramarray using the rules for
    ' instantiation as described above.
    
    Sys.ResolveParamArray ipFPA
    
    If VBA.IsArray(ipFPA) Or GroupInfo.IsContainer(ipFPA) Then
        Set ConstructInstance = AddRange(ipFPA)
    Else
        Set ConstructInstance = AddItems(ipFPA)
    End If

End Function

' There is no bind method for SeqL as such action
' is not supported by the Host item s.root
' i.e. Bind only exists to avoid having to make a copy of
' the input as the host item

Public Function Clone() As SeqL

    Dim myS As SeqL
    Set myS = SeqL.Deb

    If s.Root Is Nothing Then
        Set Clone = myS
        Exit Function
    End If

    Dim myNode As SeqLNode
    Set myNode = s.Root

    Do
        myS.Add myNode.Item
        Set myNode = myNode.Succ
    Loop Until myNode Is Nothing

    Set Clone = myS

End Function
'
''@Enumerator
'Public Function NewEnum() As IUnknown
'    Err.Raise 17 + vbObjectError, _
'        "VBALib.SeqL.NewEnum", _
'        "Not implemented for SeqL"
'End Function
'
'
'@Description("Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer")
Public Function Count(Optional ByRef ipItem As Variant) As Long
Attribute Count.VB_Description = "Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer"

    If VBA.IsMissing(ipItem) Then
        Count = s.Host.Count
        Exit Function
    End If

    If s.Root Is Nothing Then
        Count = -1
        Exit Function
    End If

    Dim myCount As Long
    myCount = 0

    Dim myNode As SeqLNode
    Set myNode = s.Root

    Do
        If ComparerHelpers.Equals(myNode.Item, ipItem) Then
            myCount = myCount + 1
        End If
        Set myNode = myNode.Succ
    Loop Until myNode Is Nothing

    Count = myCount

End Function

Public Function Items() As Variant
    Items = ToArray
End Function

'@Description("Returns a subset of the SeqL")
Public Function Slice _
( _
    Optional ByRef ipStart As Long = 1, _
    Optional ByRef ipRun As Long = -1, _
    Optional ByRef ipStep As Long = 1 _
) As SeqL
Attribute Slice.VB_Description = "Returns a subset of the SeqL"

    If s.Root Is Nothing Then
        Set Slice = SeqL.Deb
        Exit Function
    End If

    GuardIndexOutOfBounds ipStart, FIRST_INDEX, s.Host.Count, "VBALib.SeqL.Sice"

    Dim myRun As Long
    myRun = ipRun
    If myRun = -1 Then
        myRun = s.Host.Count - ipStart + 1
    Else
        GuardIndexOutOfBounds myRun + ipStart - 1, FIRST_INDEX, s.Host.Count, "VBALib.SeqL.Sice"
    End If

    Dim myS As SeqL
    Set myS = SeqL.Deb

    Dim mySeqIndex As Long
    For mySeqIndex = ipStart To ipStart + myRun - 1 Step ipStep
        myS.Add Me.Item(mySeqIndex)
    Next

    Set Slice = myS

End Function


'@Description("Returns a shallow copy of the SeqL as an Array.  The Lbound of the array is 1")
Public Function ToArray() As Variant
Attribute ToArray.VB_Description = "Returns a shallow copy of the SeqL as an Array.  The Lbound of the array is 1"

    If s.Root Is Nothing Then
        ToArray = Array()
        Exit Function
    End If

    Dim myA As Variant
    ReDim myA(1 To s.Host.Count)

    Dim myNode As SeqLNode
    Set myNode = s.Root

    Dim myIndex As Long
    myIndex = 1
    Do
       
         If VBA.IsObject(myNode.Item) Then
            Set myA(myIndex) = myNode.Item
        Else
            myA(myIndex) = myNode.Item
        End If

        Set myNode = myNode.Succ
        myIndex = myIndex + 1
        
    Loop Until myNode Is Nothing

    ToArray = myA

End Function


'@Description("Returns a shallow copy of the SeqL as a VBA collection")
Public Function ToCollection() As Collection
Attribute ToCollection.VB_Description = "Returns a shallow copy of the SeqL as a VBA collection"

    Dim myC As Collection
    Set myC = New Collection
    
    If s.Root Is Nothing Then
        Set ToCollection = myC
        Exit Function
    End If

    Dim myNode As SeqLNode
    Set myNode = s.Root

    Do
        myC.Add myNode.Item
        Set myNode = myNode.Succ
    Loop Until myNode Is Nothing

    Set ToCollection = myC

End Function

'@Description("Returns the Host of the first Index")
Public Function FirstIndex() As Long
Attribute FirstIndex.VB_Description = "Returns the Host of the first Index"

    If s.Host.Count < FIRST_INDEX Then
        FirstIndex = -1
    Else
        FirstIndex = FIRST_INDEX
    End If

End Function

'@Description("Returns the UBound of the SeqL or -1 if the SeqL is empty.  Equivalent to Count.")
Public Function LastIndex() As Long
Attribute LastIndex.VB_Description = "Returns the UBound of the SeqL or -1 if the SeqL is empty.  Equivalent to Count."

    If s.Host.Count < FIRST_INDEX Then
        LastIndex = -1
    Else
        LastIndex = s.Host.Count
    End If

End Function

'@Description("Returns the index of the second item in the SeqL or -1  if the SeqL has less than 2 Items")
Public Function FBOIndex() As Long
Attribute FBOIndex.VB_Description = "Returns the index of the second item in the SeqL or -1  if the SeqL has less than 2 Items"

    If s.Host.Count < FIRST_INDEX + 1 Then
       FBOIndex = -1
    Else
        FBOIndex = FIRST_INDEX + 1
    End If
    
End Function

'Description("Returns the index of the second to last item in the SeqL, or -1 if the SeqL has lees than 2 items")
Public Function LBOIndex() As Long

    If s.Host.Count < FIRST_INDEX + 1 Then
        LBOIndex = -1
    Else
        LBOIndex = s.Host.Count - 1
    End If
   
End Function

Public Property Get TypeName() As String
    TypeName = MY_TYPENAME
End Property


'@Description("Returns the item at FirstIndex")
Public Property Get First() As Variant
Attribute First.VB_Description = "Returns the item at FirstIndex"

    If s.Root Is Nothing Then
        First = Null
        Exit Property
    End If

    If VBA.IsObject(s.Root.Item) Then
        Set First = s.Root.Item
    Else
        First = s.Root.Item
    End If

End Property

'@Description("Assigns to the Item at FirstIndex")
Public Property Let First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    If s.Root Is Nothing Then
        Me.Add ipItem
        Exit Property
    End If

    s.Root.Item = ipItem

End Property

'@Description("Assigns to the Item at FirstIndex")
Public Property Set First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    If s.Root Is Nothing Then
        Me.Add ipItem
        Exit Property
    End If

    Set s.Root.Item = ipItem

End Property

'@Description("Returns the Item at LastIndex")
Public Property Get Last() As Variant
Attribute Last.VB_Description = "Returns the Item at LastIndex"

    If s.Last Is Nothing Then
        Last = Null
        Exit Property
    End If
    
    If VBA.IsObject(s.Last.Item) Then
        Set Last = s.Last.Item
    Else
        Last = s.Last.Item
    End If

End Property

'@Description("Assigns to the Item at LastIndex")
Public Property Let Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the Item at LastIndex"

    If s.Last Is Nothing Then
        Me.Add ipItem
        Exit Property
    End If

    s.Last.Item = ipItem

End Property

'@Description("Assigns to the item at LastIndex")
Public Property Set Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the item at LastIndex"

    If s.Last Is Nothing Then
        Me.Add ipItem
        Exit Property
    End If

    Set s.Last.Item = ipItem
   
End Property

'@Description("Returns the item at First but one Index")
Public Property Get FBO() As Variant
Attribute FBO.VB_Description = "Returns the item at First but one Index"

    If s.Root.Succ Is Nothing Then
        FBO = Null
        Exit Property
    End If
    
   If VBA.IsObject(s.Root.Succ.Item) Then
       Set FBO = s.Root.Succ.Item
   Else
       FBO = s.Root.Succ.Item
   End If

End Property

'@Description("Assigns to the Item at First but one Index")
Public Property Let FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at First but one Index"

   If s.Root Is Nothing Then
        Err.Raise 17 + vbObjectError, _
            "VBALib.SeqA.Let_FBO", _
            Fmt.Text("Index {0} not avaiable", FirstIndex + 1)
    ElseIf s.Host.Count = FIRST_INDEX Then
        Me.Add ipItem
    Else
        s.Root.Succ.Item = ipItem
    End If

End Property

'@Description("Assigns to the Item at First but one Index")
Public Property Set FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at First but one Index"

   If s.Root Is Nothing Then
        Err.Raise 17 + vbObjectError, _
            "VBALib.SeqA.Let_FBO", _
            Fmt.Text("Index {0} not avaiable", FirstIndex + 1)
    End If
    
    If s.Host.Count = FIRST_INDEX Then
        Me.Add ipItem
    Else
        Set s.Root.Succ.Item = ipItem
    End If

End Property

'@Description("Returns the Item at Lastbut one Index")
Public Property Get LBO() As Variant
Attribute LBO.VB_Description = "Returns the Item at Lastbut one Index"

   If s.Last.Pred Is Nothing Then
        LBO = Null
        Exit Function
    End If
    
    If VBA.IsObject(s.Last.Pred.Item) Then
       Set LBO = s.Last.Pred.Item
   Else
       LBO = s.Last.Pred.Item
   End If

End Property


'@Description("Assigns to the Item at Last but one Index")
Public Property Let LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the Item at Last but one Index"

   If s.Root Is Nothing Then
        Err.Raise 17 + vbObjectError, _
            "VBALib.SeqA.Let_FBO", _
            Fmt.Text("Index {0} not avaiable", s.Host.Count - 1)
    ElseIf s.Last.Pred Is Nothing Then
        Me.Insert ipItem, FIRST_INDEX
    Else
        s.Last.Pred.Item = ipItem
    End If

End Property


'@Description("Assigns to the item at Last but one Index")
Public Property Set LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the item at Last but one Index"

   If s.Root Is Nothing Then
        Err.Raise 17 + vbObjectError, _
            "VBALib.SeqA.Let_FBO", _
            Fmt.Text("Index {0} not avaiable", s.Host.Count - 1)
    ElseIf s.Last.Pred Is Nothing Then
        Me.Insert ipItem, FIRST_INDEX
    Else
        s.Last.Pred.Item = ipItem
    End If

End Property

''Public Property Get Capacity() As Long
''    Capacity = s.Size
''End Property
''
'''@("Resizes the host array to the specifies capacity, existing Hosts in the capacity range are preserved")
''Public Property Let Capacity(ByVal ipCapacity As Long)
''    s.Size = ipCapacity
''    Resize
''End Property
'
'
Public Function IndexOf _
( _
    ByVal ipItem As Variant, _
    Optional ByVal ipStart As Long = 1, _
    Optional ByVal ipRun As Long = -1 _
) As Long
    
    If s.Root Is Nothing Then
        IndexOf = -1
        Exit Function
    End If
    
    If ipStart < 1 Or ipStart > s.Host.Count Then
        IndexOf = -1
        Exit Function
    End If
    
    If ipRun = 0 Or ipRun < -1 Then
        IndexOf = -1
        Exit Function
    End If
    
    ' ensure that ipstart+iprun only goes to the end of the seq
    Dim myEnd As Long
    If ipRun = 0 Then
        myEnd = s.Host.Count
    Else
        myEnd = ipStart + ipRun - 1
        If myEnd > s.Host.Count Then
            myEnd = s.Host.Count
        End If
    End If
    
    Dim myNode As SeqLNode
    Set myNode = GetNodeAt(ipStart)
    
    Dim myCount As Long
    For myCount = ipStart To myEnd
        
        If ComparerHelpers.Equals(myNode.Item, ipItem) Then
            IndexOf = ipStart + myCount - 1
            Exit Function
        End If
        
        Set myNode = myNode.Succ
    
    Next
    
    IndexOf = -1
    
End Function

Public Function LastIndexOf _
( _
    ByVal ipItem As Variant, _
    Optional ByVal ipStart As Long = 1, _
    Optional ByVal ipRun As Long = 0 _
) As Long
    
    If s.Root Is Nothing Then
        LastIndexOf = -1
        Exit Function
    End If
    
    If ipStart < 1 Or ipStart > s.Host.Count Then
        LastIndexOf = -1
        Exit Function
    End If
    
    ' ensure that ipstart+iprun only goes to the end of the seq
    Dim myEnd As Long
    If ipRun = 0 Then
        myEnd = s.Host.Count
    Else
        myEnd = ipStart + ipRun - 1
        If myEnd > s.Host.Count Then
            myEnd = s.Host.Count
        End If
    End If
    
    'cannot use Iteritems unless we convert managing nodes into managing a list object
    ' which is probably not worth the effort as it will duplicate Seq classes
    Dim myNode As SeqLNode
    Set myNode = GetNodeAt(myEnd)
    
    Dim myCount As Long
    For myCount = ipStart To myEnd Step -1
        
        If ComparerHelpers.Equals(myNode.Item, ipItem) Then
            LastIndexOf = myCount
            Exit Function
        End If
        
        Set myNode = myNode.Pred
    
    Next
    
    LastIndexOf = -1
    
End Function



'@Description("Add a single item.  Returns the index at which added.  For compatibility with ArrayList")
Public Function Add(ByRef ipItem As Variant) As Long
Attribute Add.VB_Description = "Add a single item.  Returns the index at which added.  For compatibility with ArrayList"

    If s.Root Is Nothing Then
        Set s.Root = SeqLNode(ipItem:=ipItem)
        Set s.Last = s.Root
       
    Else
    
        Dim myNode As SeqLNode
        Set myNode = SeqLNode(s.Last, Nothing, ipItem)
        Set s.Last.Succ = myNode
        Set s.Last = myNode
    End If
    
    s.Host.Count = s.Host.Count + 1
    Add = s.Host.Count
    
End Function


'@Description("Add Items in the paramarray to the  )
Public Function AddItems(ParamArray ipParamarray() As Variant) As SeqL

    If ArrayInfo.LacksItems(VBA.CVar(ipParamarray)) Then
        Set AddItems = Me
        Exit Function
    End If

    Me.AddRange VBA.CVar(ipParamarray)

    Set AddItems = Me

End Function

'@Description("Add an array,  list type, dictionary type, or characters of a string")
Public Function AddRange(ByVal ipRange As Variant) As SeqL
Attribute AddRange.VB_Description = "Add an array,  list type, dictionary type, or characters of a string"

    Dim myItems As IterItems
    Set myItems = IterItems(ipRange)
    
    Do
        If GroupInfo.IsDictionary(ipRange) Then
            Me.Add Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            Me.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set AddRange = Me
    
End Function




Public Property Get Item(ByVal ipIndex As Long) As Variant

    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.Host.Count, "VBALib.SeqL.Get_Item"

    Dim myNode As SeqLNode
    Set myNode = GetNodeAt(ipIndex)

    If VBA.IsObject(myNode.Item) Then
        Set Item = myNode.Item
    Else
        Item = myNode.Item
    End If

End Property

Public Property Let Item(ByVal ipIndex As Long, ByVal ipItem As Variant)

    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.Host.Count, "VBALib.SeqL.Get_Item"

    Dim myNode As SeqLNode
    Set myNode = GetNodeAt(ipIndex)
    myNode.Item = ipItem

End Property

Public Property Set Item(ByVal ipIndex As Long, ByVal ipItem As Variant)

    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.Host.Count, "VBALib.SeqL.Get_Item"

    Dim myNode As SeqLNode
    Set myNode = GetNodeAt(ipIndex)
    Set myNode.Item = ipItem

End Property


Public Function Insert(ByVal ipIndex As Long, ByVal ipItem As Variant) As Long

    If ipIndex < FIRST_INDEX Or ipIndex > s.Host.Count Then
        Insert = -1
        Exit Function
    End If

    Dim myNode As SeqLNode
    Set myNode = GetNodeAt(ipIndex)

    
    Dim myNewNode As SeqLNode
    Set myNewNode = SeqLNode(myNode.Pred, myNode, ipItem)
    
    If Not (myNode.Pred Is Nothing) Then
        Set myNode.Pred.Succ = myNewNode
    End If
    
    Set myNode.Pred = myNewNode
    
    s.Host.Count = s.Host.Count + 1
    Insert = ipIndex

End Function
'
Public Function InsertItems(ByVal ipIndex As Long, ParamArray ipParamarray() As Variant) As SeqL
    Set InsertItems = InsertRange(ipIndex, VBA.CVar(ipParamarray))
End Function


Public Function InsertRange(ByVal ipIndex As Long, ByRef ipRange As Variant) As SeqL

    If ipIndex < FIRST_INDEX Or ipIndex > s.Host.Count Then
        Set InsertRange = Me
        Exit Function
    End If

    Dim myGroupId As e_Group
    myGroupId = GroupInfo.Id(ipRange)
    GuardInvalidRangeObject myGroupId, ipRange, "VBALib.SeqL.InsertRange"
    
    Dim myItems As IterItems
    Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Set InsertRange = Me
        Exit Function
    End If
    
    Dim myIndex As Long
    myIndex = ipIndex
    Do
        Insert myIndex, myItems.CurItem(0)
    Loop While myItems.MoveNext

'    Select Case myGroupId
'
'        Case e_Group.m_string:          InsertRangeFromString ipIndex, VBA.CStr(ipRange)
'        Case e_Group.m_array:           InsertRangeUsingForeach ipIndex, ipRange
'        Case e_Group.m_List:            InsertRangeUsingForeach ipIndex, ipRange
'        Case e_Group.m_Dictionary:      InsertRangeFromDictionary ipIndex, ipRange
'        Case Else
'
'    End Select

    Set InsertRange = Me
    
End Function


Private Sub InsertRangeFromString(ByRef ipIndex As Long, ByRef ipString As String)

    Dim myLen As Long
    myLen = VBA.Len(ipString)

    If myLen = 0 Then
        Exit Sub
    End If

    Dim myNode As SeqLNode
    Set myNode = GetNodeAt(ipIndex)
    
    Dim myIndex As Long
    For myIndex = 1 To myLen
    
        Dim myNewNode As SeqLNode
        Set myNewNode = SeqLNode(myNode.Pred, myNode, VBA.Mid$(ipString, myIndex, 1))
        
        If Not (myNode.Pred Is Nothing) Then
            Set myNode.Pred.Succ = myNewNode
        End If
        
        Set myNode.Pred = myNewNode
        
    Next
    
    s.Host.Count = s.Host.Count + myLen

End Sub


Private Sub InsertRangeUsingForeach(ByRef ipIndex As Long, ByRef ipForEach As Variant)

    Dim myLen As Long
    If ArrayInfo.IsArray(ipForEach) Then
        myLen = ArrayInfo.Count(ipForEach)
    Else
        myLen = ipForEach.Count
    End If

    If myLen < 1 Then
        Exit Sub
    End If

    Dim myNode As SeqLNode
    Set myNode = GetNodeAt(ipIndex)
   
    Dim myItem As Variant
    For Each myItem In ipForEach
    
        Dim myNewNode As SeqLNode
        Set myNewNode = SeqLNode(myNode.Pred, myNode, myItem)
        
        If Not (myNode.Pred Is Nothing) Then
            Set myNode.Pred.Succ = myNewNode
        End If
        
        Set myNode.Pred = myNewNode
        
    Next
    
    s.Host.Count = s.Host.Count + myLen
    
End Sub


Private Sub InsertRangeFromDictionary(ByRef ipIndex As Long, ByRef ipD As Variant)

    If ipD.Count < 1 Then
        Exit Sub
    End If

    Dim myNode As SeqLNode
    Set myNode = GetNodeAt(ipIndex)
   
    Dim myKey As Variant
    For Each myKey In ipD.Keys
    
        Dim myNewNode As SeqLNode
        Set myNewNode = SeqLNode(myNode.Pred, myNode, Array(myKey, ipD.Item(myKey)))
        
        If Not (myNode.Pred Is Nothing) Then
            Set myNode.Pred.Succ = myNewNode
        End If
        
        Set myNode.Pred = myNewNode
        
    Next
    
    s.Host.Count = s.Host.Count + ipD.Count

End Sub

'@Description("Removes the first encountered item from the SeqL")
Public Function Remove(ByRef ipItem As Variant) As Long
Attribute Remove.VB_Description = "Removes the first encountered item from the SeqL"

    If s.Root Is Nothing Then
        Remove = -1
        Exit Function
    End If

    Dim myNodeInfo As KVPair
    Set myNodeInfo = GetNodeInfo(ipItem)
    
    Dim myNode As SeqLNode
    Set myNode = myNodeInfo.Item
    
    If myNode.Pred Is Nothing Then
        Set s.Root = myNode.Succ
    Else
        Set myNode.Pred.Succ = myNode.Succ
    End If
    
    If myNode.Succ Is Nothing Then
        Set s.Last = myNode.Pred
    Else
        Set myNode.Succ.Pred = myNode.Pred
    End If
    
    Set myNode = Nothing
    
    s.Host.Count = s.Host.Count - 1
    
    Remove = myNodeInfo.Key

End Function

'@Description("Removes the first encountered item from the SeqL")
Public Function RemoveItems(ParamArray ipParamarray() As Variant) As SeqL
Attribute RemoveItems.VB_Description = "Removes the first encountered item from the SeqL"

    If s.Root Is Nothing Then
        Set RemoveItems = Me
        Exit Function
    End If

    If ArrayInfo.LacksItems(VBA.CVar(ipParamarray)) Then
        Set RemoveItems = Me
        Exit Function
    End If

    Dim myItem As Variant
    For Each myItem In ipParamarray
    
        Dim myNode As SeqLNode
        Set myNode = GetNodeInfo(myItem).Item
        
        If myNode.Pred Is Nothing Then
            Set s.Root = myNode.Succ
        Else
            Set myNode.Pred.Succ = myNode.Succ
        End If
        
        If myNode.Succ Is Nothing Then
            Set s.Last = myNode.Pred
        Else
            Set myNode.Succ.Pred = myNode.Pred
        End If
        
        Set myNode = Nothing
        
        s.Host.Count = s.Host.Count - 1
        
    Next

    Set RemoveItems = Me

End Function


'@Description("Removes the first encountered item from the SeqL")
Public Function RemoveAt(ParamArray ipParamarray() As Variant) As SeqL
Attribute RemoveAt.VB_Description = "Removes the first encountered item from the SeqL"

    If s.Root Is Nothing Then
        Set RemoveAt = Me
        Exit Function
    End If

    Dim myParams As Variant
    myParams = ipParamarray

    If ArrayInfo.LacksItems(myParams) Then
        Set RemoveAt = Me
        Exit Function
    End If
    
    ' The indexes may be in any order so need sorting then reversin
    Sorters.ShakerSortArray myParams
    
    Dim myIndex As Variant
    For myIndex = UBound(myParams) To LBound(myParams) Step -1
    
        Dim myNode As SeqLNode
        Set myNode = GetNodeAt(VBA.CLng(myParams(myIndex)))
        
        If myNode.Pred Is Nothing Then
            Set s.Root = myNode.Succ
        Else
            Set myNode.Pred.Succ = myNode.Succ
        End If
        
        If myNode.Succ Is Nothing Then
            Set s.Last = myNode.Pred
        Else
            Set myNode.Succ.Pred = myNode.Pred
        End If
        
        Set myNode = Nothing
        
        s.Host.Count = s.Host.Count - 1
        
    Next

    Set RemoveAt = Me

End Function


'@Description("Remove items in the specified range of Indexes")
Public Function RemoveRange(ByRef ipArray As Variant) As SeqL
Attribute RemoveRange.VB_Description = "Remove items in the specified range of Indexes"

    If s.Root Is Nothing Then
        Set RemoveRange = Me
        Exit Function
    End If

    If ArrayInfo.LacksItems(ipArray) Then
        Set RemoveRange = Me
        Exit Function
    End If

    Dim myItem As Variant
    For Each myItem In ipArray
    
        Dim myNode As SeqLNode
        Set myNode = GetNodeInfo(myItem).Item
        
        If myNode.Pred Is Nothing Then
            Set s.Root = myNode.Succ
        Else
            Set myNode.Pred.Succ = myNode.Succ
        End If
        
        If myNode.Succ Is Nothing Then
            Set s.Last = myNode.Pred
        Else
            Set myNode.Succ.Pred = myNode.Pred
        End If
        
        Set myNode = Nothing
        
        s.Host.Count = s.Host.Count - 1
        
    Next

    Set RemoveRange = Me

End Function


'@Description("Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use")
Public Function RemoveAtRange(ByRef ipArray As Variant) As SeqL
Attribute RemoveAtRange.VB_Description = "Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use"

    If s.Root Is Nothing Then
        Set RemoveAtRange = Me
        Exit Function
    End If

    If ArrayInfo.LacksItems(ipArray) Then
        Set RemoveAtRange = Me
        Exit Function
    End If
    
    Sorters.ShakerSortArray ipArray

    Dim myIndex As Long
    For myIndex = UBound(ipArray) To LBound(ipArray) Step -1
       RemoveAt ipArray(myIndex)
    Next

    Set RemoveAtRange = Me

End Function


Public Function RemoveAll(ParamArray ipParamarray() As Variant) As SeqL

    If s.Root Is Nothing Then
        Set RemoveAll = Me
        Exit Function
    End If
    
    If ArrayInfo.LacksItems(VBA.CVar(ipParamarray)) Then
        RemoveAllItems
        Set RemoveAll = Me
        Exit Function
    End If
    
    Dim myParam As Variant
    For Each myParam In ipParamarray
        RemoveAllSingleItem myParam
    Next

    Set RemoveAll = Me

End Function

Private Sub RemoveAllItems()

    Dim myNode As SeqLNode
    Set myNode = s.Last
    
    Do Until myNode.Pred Is Nothing
    
        Dim myTmpNode As SeqLNode
        Set myTmpNode = myNode
        
        Set myNode = myNode.Pred
        Set myTmpNode = Nothing
        
    Loop
    
    'Set myNode = Nothing
    Set s.Last = Nothing
    Set s.Root = Nothing
    s.Host.Count = 0
    
End Sub


Private Sub RemoveAllSingleItem(ByRef ipItem As Variant)

    Dim myNode As SeqLNode
    Set myNode = s.Root
    
    Set myNode = s.Root

    Do
        
        If ComparerHelpers.Equals(myNode.Item, ipItem) Then
           
            If myNode.Pred Is Nothing Then
                Set s.Root = myNode.Succ
            Else
                Set myNode.Pred.Succ = myNode.Succ
            End If
            
            If myNode.Succ Is Nothing Then
                Set s.Last = myNode.Pred
            Else
                Set myNode.Succ.Pred = myNode.Pred
            End If
            
            Dim myTmp As SeqLNode
            Set myTmp = myNode
            
            Set myNode = myNode.Succ
            
            s.Host.Count = s.Host.Count - 1
            
        Else
        
            Set myNode = myNode.Succ
        
        End If
        
    Loop Until myNode Is Nothing
  
End Sub

'@Description("Removes all Items from the SeqL")
Public Function Clear() As SeqL
    Set Clear = RemoveAll
End Function


'@Description("Removes all Items by replacing the Host collection with a new collection")
Public Function Reset() As SeqL
    Set Reset = RemoveAll
End Function


Public Function Fill(ByRef ipItem As Variant, Optional ByVal ipCount As Long = 1) As SeqL

    If ipCount < 1 Then
        Set Fill = Me
        Exit Function
    End If

    Dim myCount As Long
    For myCount = 1 To ipCount
        Me.Add ipItem
    Next

    Set Fill = Me

End Function


'@Description("Returns the first N items of the SeqL, Default 1")
Public Function Head(Optional ByVal ipSplitAfter As Long = 1) As SeqL
Attribute Head.VB_Description = "Returns the first N items of the SeqL, Default 1"

    If s.Host.Count <= 1 Then
        Set Head = SeqL.Deb
        Exit Function
    End If

    If ipSplitAfter < 1 Then
        Set Head = SeqL.Deb
        Exit Function
    End If

    If ipSplitAfter >= s.Host.Count Then
        Set Head = Me.Clone
        Exit Function
    End If

    Set Head = Me.Slice(1, ipSplitAfter)

End Function


'@Description("Returns the Items after SplitAfter, Default is Index 2")
Public Function Tail(Optional ByVal ipSplitAfter As Long = 1) As SeqL
Attribute Tail.VB_Description = "Returns the Items after SplitAfter, Default is Index 2"

    If s.Host.Count < 1 Then
        Set Tail = SeqL.Deb
        Exit Function
    End If

    If ipSplitAfter < 1 Then
        Set Tail = Me.Clone
        Exit Function
    End If

    If ipSplitAfter >= s.Host.Count Then
        Set Tail = SeqL.Deb
        Exit Function
    End If

    Set Tail = Me.Slice(ipSplitAfter + 1)

End Function


Public Function HoldsItem(ByRef ipItem As Variant) As Boolean

    If s.Root Is Nothing Then
        HoldsItem = False
        Exit Function
    End If

    Dim myNode As SeqLNode
    Set myNode = s.Root
    
    Do
    
        If ComparerHelpers.Equals(myNode.Item, ipItem) Then
            HoldsItem = True
            Exit Function
        End If
        
        Set myNode = myNode.Succ
        
    Loop Until myNode Is Nothing

    HoldsItem = False

End Function

Public Function Contains(ByRef ipItem As Variant) As Boolean
    Contains = Me.HoldsItem(ipItem)
End Function

Public Function LacksItem(ByRef ipItem As Variant) As Boolean
    LacksItem = Not HoldsItem(ipItem)
End Function

Public Function HoldsItems() As Boolean
    HoldsItems = s.Host.Count > 0
End Function

Public Function LacksItems() As Boolean
    LacksItems = s.Host.Count < 1
End Function
'
''
'''@Description("Makes a shallow copy of the SeqL to the provided array")
''Public Function CopyTo(ByRef ipArray As pArray) As SeqL
''
'''    ' Dim myArray As Variant = ipoArr.Cargo
'''     If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'''     If Guard.LacksItems(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'''     If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
'''     'If Guard.SizeMismatch(s.host.count > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
''    If Var.LacksItems(ipArray.Cargo) Then
''        Return Me
''    End If
''
''    Dim myIndex  As Long
''    For myIndex = FirstIndex To LastIndex
''
''        Dim myItem As Variant = s.Item(myIndex)
''
''        If VBA.IsObject(myItem) Then
''            Set ipArray.Cargo(myIndex) = myItem
''        Else
''            ipArray.Cargo(myIndex) = myItem
''        End If
''
''        If myIndex > Var.LastIndex(ipArray.Cargo) Then
''            Exit For
''        End If
''    Next
''
''    Return Me
''
''End Function
''
''
''Public Function CopyTo(ByRef ipArray As pArray, ByVal ipArrayStartIndex As Long) As SeqL
''
''    '  ' Dim myArray As Variant = ipoArr.Cargo
''    ' If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''    ' If Guard.LacksItems(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''    ' If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''    ' 'If Guard.SizeMismatch(s.host.count > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
''
''    Dim myArrayIndex  As Long = ipArrayStartIndex
''
''    Dim myHostIndex As Long
''    For myHostIndex = FirstIndex To LastIndex
''        Dim myItem As Variant = s.Item(myHostindex)
''
''        If VBA.IsObject(myItem) Then
''            Set ipArray.Cargo(myArrayIndex) = myItem
''        Else
''            ipArray.Cargo(myArrayIndex) = myItem
''        End If
''
''        myArrayIndex += 1
''        If myArrayIndex >= Var.LastIndex(ipArray.Cargo) Then
''            Exit For
''        End If
''    Next
''
''    Return Me
''
''End Function
''
''Public Function CopyTo _
''() '( _
''    ByVal ipSeqStartIndex As Long, _
''    ByRef ipArray As pArray, _
''    ByVal ipArrayStartIndex As Long, _
''    ByVal ipArrayCount As Long _
'') As SeqL IMplements SeqL.CopyTo
''
''    '  ' Dim myArray As Variant = ipoArr.Cargo
''    ' If Guard.IsNotArray(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''    ' If Guard.LacksItems(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''    ' If Guard.TooManyRanks(ipArray, CurrentComponentName, CurrentProcedureName) Then Return Me
''    ' 'If Guard.SizeMismatch(s.host.count > ArrayInfo.Count(myArray), CurrentComponentName, CurrentProcedureName) Then Return Me
''
''    Dim myArrayIndex  As Long = ipArrayStartIndex
''
''    Dim myHostIndex As Long
''    For myHostIndex = ipSeqStartIndex - 1 To LastIndex
''        Dim myItem As Variant = s.Item(myHostIndex)
''
''        If VBA.IsObject(myItem) Then
''            Set ipArray.Cargo(myArrayIndex) = myItem
''        Else
''            ipArray.Cargo(myArrayIndex) = myItem
''        End If
''
''        myArrayIndex += 1
''
''        If myArrayIndex > Var.LastIndex(ipArray.Cargo) Then
''            Exit For
''        End If
''
''    Next
''
''    Return Me
''
''End Function


Public Property Get myTypename() As String
   myTypename = MY_TYPENAME
End Property



Public Function MapIt(ByVal ipMapper As IMapper) As SeqL

    Dim myS As SeqL
    Set myS = SeqL.Deb

    If s.Root Is Nothing Then
        Set MapIt = myS
        Exit Function
    End If
    
    Dim myNode As SeqLNode
    Set myNode = s.Root
    
    Do
        myS.Add ipMapper.ExecMapper(myNode.Item)(0)
        Set myNode = myNode.Succ
    Loop Until myNode Is Nothing

    Set MapIt = myS

End Function

'@Description("Mutates the SeqL in place by applying the function in IMapper to each item")
Public Function MappedIt(ByRef ipMapper As IMapper) As SeqL
    'Mapped it works by reference but we allow a function return to enable fluid use of Mappedit

    If s.Root Is Nothing Then
        Set MappedIt = Me
        Exit Function
    End If
    
    Dim myNode As SeqLNode
    Set myNode = s.Root
    
    Do

        Dim myItem As Variant
        myItem = ipMapper.ExecMapper(myNode.Item)

        If VBA.IsObject(myItem(0)) Then
            Set myNode.Item = myItem(0)
        Else
            myNode.Item = myItem(0)
        End If
        
        Set myNode = myNode.Succ
        
    Loop Until myNode Is Nothing

    Set MappedIt = Me

End Function

Public Function FilterIt(ByVal ipComparer As IComparer) As SeqL

    Dim myS As SeqL
    Set myS = SeqL.Deb

    If s.Root Is Nothing Then
        Set FilterIt = myS
        Exit Function
    End If
    
    Dim myNode As SeqLNode
    Set myNode = s.Root
    
    Do

        If ipComparer.ExecCmp(myNode.Item) Then
            myS.Add myNode.Item
        End If

        Set myNode = myNode.Succ
    
    Loop Until myNode Is Nothing

    Set FilterIt = myS

End Function

' Does not generate an interim SeqL as would filterIt followed by Count.
Public Function CountIt(ByVal ipComparer As IComparer) As Long

    If s.Root Is Nothing Then
        CountIt = -1
        Exit Function
    End If
    
    Dim myCount As Long
    myCount = 0

    Dim myNode As SeqLNode
    Set myNode = s.Root
    
    Do

        If ipComparer.ExecCmp(myNode.Item) Then
            myCount = myCount + 1
        End If

        Set myNode = myNode.Succ
    
    Loop Until myNode Is Nothing

    CountIt = myCount

End Function

'@Description("Returns a single Host based on the Reducer").
Public Function ReduceIt(ByRef ipReducer As IReducer) As Variant
    'ReduceIt = ipReducer.ExecReduction(Me)
    Dim myItem As Variant
    myItem = Array(ipReducer.ExecReduction(Me))

    If VBA.IsObject(myItem(0)) Then
       Set ReduceIt = myItem(0)
    Else
        ReduceIt = myItem(0)
    End If

End Function
'

''@Description("Returns the index of the Item")


Public Function Push(ParamArray ipParamarray() As Variant) As SeqL
     Set Push = AddRange(VBA.CVar(ipParamarray))
End Function


Public Function PushRange(ByRef ipRange As Variant) As SeqL
    Set PushRange = AddRange(ipRange)
End Function


Public Function Pop() As Variant

    If s.Root Is Nothing Then
        Pop = Null
        Exit Function
    End If
    
'    Dim myNode As SeqLNode
'    Set myNode = s.Last

    If VBA.IsObject(s.Last.Item) Then
        Set Pop = s.Last.Item
    Else
        Pop = s.Last.Item
    End If

    Dim myTmp As SeqLNode
    Set myTmp = s.Last
    Set s.Last = s.Last.Pred
    Set s.Last.Succ = Nothing
    Set myTmp.Pred = Nothing
    Set myTmp.Succ = Nothing
    Set myTmp = Nothing

    s.Host.Count = s.Host.Count - 1
    
End Function


Public Function PopRange(Optional ByVal ipCount As Long = 1) As SeqL

    If s.Root Is Nothing Then
        Set PopRange = SeqL.Deb
        s.Host.Count = 0
        Exit Function
    End If

    If ipCount > s.Host.Count Then
        Set PopRange = Me.Reversed
        Me.RemoveAll
        Exit Function
    End If
    'slicing does no remve the items from the host seql
    
    Dim myS As SeqL
    Set myS = SeqL.Deb
    
    Dim myCount As Long
    For myCount = 1 To ipCount

        Dim myTmp As SeqLNode
        Set myTmp = s.Last
'
        myS.Add s.Last.Item
        
        Set s.Last = s.Last.Pred
        Set s.Last.Succ = Nothing
        Set myTmp.Pred = Nothing
        Set myTmp.Succ = Nothing
        Set myTmp = Nothing
        s.Host.Count = s.Host.Count - 1
        
    Next
    
    Set PopRange = myS

End Function

Public Function Reverse() As SeqL

    If s.Root Is Nothing Then
        Set Reverse = Me
        Exit Function
    End If


    Dim myNewLast As SeqLNode
    Set myNewLast = s.Root
    
    Dim myNewRoot As SeqLNode
    Set myNewRoot = s.Last
    
    Do
    
        ' swap pred and succ for each node
        Dim myTmp As SeqLNode
        
        Set myTmp = s.Last.Succ
        Set s.Last.Succ = s.Last.Pred
        Set s.Last.Pred = myTmp
        
        Set s.Last = s.Last.Succ
        
    Loop Until s.Last Is Nothing
    
    Set s.Root = myNewRoot
    Set s.Last = myNewLast
    
    
    Set Reverse = Me

 End Function

 Public Function Reversed() As SeqL

    Dim myS As SeqL
    Set myS = SeqL.Deb
        
    If s.Root Is Nothing Then
       Set Reversed = myS
       Exit Function
    End If
        
    Dim myNode As SeqLNode
    Set myNode = s.Last
    
    Do
        myS.Add myNode.Item
        
        Set myNode = myNode.Pred
        
    Loop Until myNode Is Nothing
    
    Set Reversed = myS

 End Function
 
 
Public Function enQueue(ParamArray ipParamarray() As Variant) As SeqL
   Set enQueue = AddRange(VBA.CVar(ipParamarray))
End Function


Public Function EnqueueRange(ByRef ipRange As Variant) As SeqL
   Set EnqueueRange = AddRange(ipRange)
End Function

Public Function Dequeue() As Variant

     If s.Root Is Nothing Then
        Dequeue = Null
        Exit Function
    End If

    If VBA.IsObject(s.Root.Item) Then
        Set Dequeue = s.Root.Item
    Else
        Dequeue = s.Root.Item
    End If

    Dim myTmp As SeqLNode
    Set myTmp = s.Root
    Set s.Root = s.Root.Succ
    Set s.Root.Pred = Nothing
    Set myTmp.Pred = Nothing
    Set myTmp.Succ = Nothing
    Set myTmp = Nothing

    s.Host.Count = s.Host.Count - 1
    

End Function


Public Function DequeueRange(Optional ByVal ipCount As Long = 1) As SeqL

    If s.Root Is Nothing Then
        Set DequeueRange = SeqL.Deb
        s.Host.Count = 0
        Exit Function
    End If

    If ipCount > s.Host.Count Then
        Set DequeueRange = Me.Clone
        Me.RemoveAll
        Exit Function
    End If
    'slicing does no remve the items from the host seql
    
'    Dim myNode As SeqL.Node
'    Set myNode = s.Last
'
    Dim myS As SeqL
    Set myS = SeqL.Deb
    
    Dim myCount As Long
    For myCount = 1 To ipCount

        Dim myTmp As SeqLNode
        Set myTmp = s.Root
        
        myS.Add myTmp.Item
        
        Set s.Root = s.Root.Succ
        Set s.Root.Pred = Nothing
        Set myTmp.Pred = Nothing
        Set myTmp.Succ = Nothing
        Set myTmp = Nothing
        s.Host.Count = s.Host.Count - 1
        
    Next
    
    Set DequeueRange = myS
    
End Function
''Public Function RotL(Optional ByVal ipCount As Long = 1) As SeqL
''    Dim myCount As Long
''    For myCount = 1 To ipCount
''        AddItems Dequeue
''    Next
''    Return Me
''End Function
''
''Public Function RotR(Optional ByVal ipCount As Long = 1) As SeqL
''    Dim myCount As Long
''    For myCount = 1 To ipCount
''        Insert 1, Pop
''    Next
''    Return Me
''End Function
''
'
Public Function Sort() As SeqL
     Sorters.ShakerSortSeq Me
     Set Sort = Me
 End Function
'
Public Function Sorted() As SeqL
    Dim myS As SeqL
    Set myS = Me.Clone
    Sorters.ShakerSortSeq myS
    Set Sorted = myS
End Function

''Private Sub QuickSort1(ByRef iopSortable As Variant, Optional ByVal ipLeft As Long, Optional ByVal ipRight As Long)
''
''    Dim myFirst As Long
''    Dim myLast As Long
''    Dim myMid As Variant
''    Dim mySwap As Variant
''
''    'Dim iopSortable.Cargo As Meta = Meta.Deb(iopSortable)
''    'Dim myReversible As Meta = Meta.Deb(iopSortable)
''
''    ' Dim iopSortable.Cargo As Variant
''    ' If ArrayInfo.IsArray(iopSortable) Then
''    '     Set iopSortable.Cargo = ListArray.Deb(iopSortable)
''    ' Else
''    '     Set iopSortable.Cargo = iopSortable
''    ' End If
''
''
''    If ipRight = 0 Then
''        ipLeft = iopSortable.Cargo.FirstIndex(1) 'LBound(iopSortable)
''        ipRight = iopSortable.Cargo.LastIndex(1) 'UBound(iopSortable)
''    End If
''    myFirst = ipLeft
''    myLast = ipRight
''    myMid = iopSortable.Cargo.Item((ipLeft + ipRight) \ 2)
''    Do
''        Do While iopSortable.Cargo.Item(myFirst) < myMid And myFirst < ipRight
''            myFirst += 1
''        Loop
''        Do While myMid < iopSortable.Cargo.Item(myLast) And myLast > ipLeft
''            myLast -= 1
''        Loop
''
''        If myFirst <= myLast Then
''
''            If VBA.IsObject(iopSortable.Cargo.Item(myFirst)) Then
''                Set mySwap = iopSortable.Cargo.Item(myFirst)
''                Set iopSortable.Cargo.Item(myFirst) = iopSortable.Cargo.Item(myLast)
''                Set iopSortable.Cargo.Item(myLast) = mySwap
''            Else
''                mySwap = iopSortable.Cargo.Item(myFirst)
''                iopSortable.Cargo.Item(myFirst) = iopSortable.Cargo.Item(myLast)
''                iopSortable.Cargo.Item(myLast) = mySwap
''            End If
''            myFirst += 1
''            myLast -= 1
''        End If
''    Loop Until myFirst > myLast
''    If ipLeft < myLast Then
''        QuickSort1 iopSortable.Cargo, ipLeft, myLast
''    End If
''    If myFirst < ipRight Then
''        QuickSort1 iopSortable, myFirst, ipRight
''    End If
''End Sub
''
''Public Function Swap(ByRef ipLHS As Long, ByVal ipRHS As Long) As SeqL
''    Dim myTmp As Variant
''    If VBA.IsObject(s.Item(ipLHS)) Then
''        Set myTmp = s.Item(ipLHS)
''    Else
''        myTmp = s.Item(ipLHS)
''    End If
''
''    If VBA.IsObject(s.Item(ipRHS)) Then
''        Set s.Item(ipLHS) = s.Item(ipRHS)
''    Else
''        s.Item(ipLHS) = s.Item(ipRHS)
''    End If
''    If VBA.IsObject(myTmp) Then
''        Set s.Item(ipRHS) = myTmp
''    Else
''        s.Item(ipRHS) = myTmp
''    End If
''
''    Return Me
''End Function
''
''Public Function Reverse() As SeqL
''
''    ' we need to reverse in place
''
''    Dim myArray As Variant
''    ReDim myArray(LBound(s, 1) To UBound(s, 1))
''
''
''    Dim myindex As Long = 1
''    Dim myReverseIndex As Long
''    For myReverseIndex = LastIndex To FirstIndex Step -1
''
''        myArray(myReverseIndex) = s.Item(myIndex)
''        myindex += 1
''    Next
''
''    s = myArray
''    ' Dim myReversed As SeqL = SeqL.Deb
''    ' Dim myItems As IterItems = IterItems.Deb(Me).MoveToEnd
''    ' Do
''    '   myReversed.Add myItems(0)
''    ' Loop While myItems.MovePrev
''     Return Me
''
''End Function
''
''' Public Function Set(ByVal ipSet As SetOf, ipParam As SeqL) As SeqL
'''     Return Cops.Set(ipSet, Me, ipParam)
''' End Function
''
'' Public Function SetOf(ByVal ipSet As e_Set, ipLHS As SeqL, ByRef ipRHS As oContainer) As SeqL
''
''        ' Dim myLHS As SeqL = SeqL.Deb(ipLHS)
''        ' Dim myRHS As SeqL = SeqL.Deb(ipRHS)
''
''        Select Case ipSet
''
''            Case e_Set.m_Both:              Return Both(ipLHS, ipRHS)
''            Case e_Set.m_HostOnly:          Return LHSOnly(ipLHS, ipRHS)
''            Case e_Set.m_ParamOnly:         Return LHSOnly(ipRHS, ipLHS) ' note reversal of params
''            Case e_Set.m_NotInBoth:           Return NotBoth(ipLHS, ipRHS)
''            Case e_Set.m_Unique:              Return MergeUnique(ipLHS, ipRHS)
''
''        End Select
''
''End Function
''
''
''
''
''Private Function LHSOnly(ByRef ipLHS As oContainer, ByRef ipRHS As oContainer) As SeqL
''    ' Dim myLHSIsKvp As Boolean = Var.IsItemByKey(ipLHS)
''    ' Dim myRHSIsKvp As Boolean = Var.IsItemByKey(ipRHS)
''    ' Dim myResult As SeqL = SeqL.Deb
''    ' Dim myH As IterItems = IterItems(ipLHs)
''    ' Do
''    '     If myLHSIsKvp Then
''
''
''    '     Dim myItem As Variant = myH.GetItem
''    '     If ipRHs.LacksItem(myItem) And myResult.LacksItem(myItem) Then
''    '         myResult.Add myItem
''    '     End If
''
''    ' Loop While myH.MoveNext
''
''    ' Return myResult
''
''End Function
''
''Private Function Both(ByRef ipLHS As SeqL, ByRef ipRHS As oContainer) As SeqL
''
''    Dim myResult As SeqL = SeqL.Deb
''
''    Dim myLHS As IterItems = IterItems(ipLHS)
''    Do
''        Dim myItem As Variant = myLHS.GetItem
''        If ipRHS.Cargo.HoldsItem(myItem) Then
''            myresult.Add Variant(myItem)
''        End If
''    Loop While myLHS.MoveNext
''
''    Return myResult
''
''End Function
''
''
''Private Function NotBoth(ByRef ipLHS As SeqL, ByRef ipRHS As oContainer) As SeqL
''
''    Return SeqL.Deb(PC(Me.LHSOnly(ipLHS, ipRHS))).Merge(PC(LHSOnly(ipRHS, ipLHS))) ' note the reversal of the parameters
''
''End Function
''
''Private Function MergeUnique(ByRef ipLHS As oContainer, ByRef ipRHS As oContainer) As SeqL
''
''    Dim myresult As SeqL = SeqL.Deb(ipLHS)
''    Dim myI As IterItems = IterItems(SeqL.Deb(ipRHS))
''    Do
''        Dim myItem As Variant = myI.GetItem
''        DoEvents
''        If myresult.Count = 0 Then
''            myresult.Add PV(myItem)
''        ElseIf myresult.LacksItem(PV(myItem)) Then
''            myresult.Add PV(myItem)
''        End If
''    Loop While myI.MoveNext
''    Return myresult
''End Function
''
''Public Function Merge(ByRef ioContainer As oContainer) As SeqL
''    Return Me.AddRange(ioContainer)
''End Function
''
''Public Function Host() As Variant Implements SeqL.Host
''    Return Items
''End Function
''
Public Function IsUnique() As Boolean

    Dim myFreqs As KvpC
    Set myFreqs = Me.Freq
    
    If s.Root Is Nothing Then
        IsUnique = False
        Exit Function
    End If
    
    Dim myFreq As Variant
    For Each myFreq In myFreqs
        'if the Item of a freq key is > 1 then we don't have unique items
        
        If myFreq.Item(myFreq) > 1 Then
           IsUnique = False
        End If

    Next

    IsUnique = True

End Function


Public Function IsNotUnique() As Boolean
    IsNotUnique = Not IsUnique
End Function


Public Function Freq() As KvpC

    Dim myKvp As KvpC
    Set myKvp = KvpC.Deb
    
    If s.Root Is Nothing Then
        Set Freq = myKvp
        Exit Function
    End If
    
    Dim myNode As SeqLNode
    Set myNode = s.Root
    
    Do
    
         If myKvp.Exists(myNode.Item) Then
             myKvp.Item(myNode.Item) = myKvp.Item(myNode.Item) + 1
         Else
             myKvp.Add myNode.Item, 1
         End If
         
         Set myNode = myNode.Succ
         
     Loop Until myNode Is Nothing

     Set Freq = myKvp
    

End Function

' Public Function Sort() As SeqL
' First
'     Sorters.ShakerSortSeq Me
'     Set Sort = Me
' End Function
'
'Public Function Sorted() As SeqL
'    Dim myS As SeqL
'    Set myS = Me.Clone
'    Sorters.ShakerSortSeq myS
'    Set Sorted = myS
'End Function

Public Function Unique() As SeqL

    Dim myS As SeqL
    Set myS = SeqL.Deb
    
    If s.Root Is Nothing Then
        Set Unique = myS
        Exit Function
    End If
    
    Dim myNode As SeqLNode
    Set myNode = s.Root
    
    Do
    
        If myS.LacksItem(myNode.Item) Then
            myS.Add myNode.Item
        End If
        
        Set myNode = myNode.Succ
        
    Loop Until myNode Is Nothing
    
    Set Unique = myS
    
End Function


Public Function SetOf(ByRef ipSet As e_SetoF, ByRef ipRangeItem As SeqL) As SeqL

    Select Case ipSet

        Case e_SetoF.m_Common:           Set SetOf = SetOfCommon(ipRangeItem)
        Case e_SetoF.m_HostOnly:         Set SetOf = SetOfHostOnly(ipRangeItem)
        Case e_SetoF.m_ParamOnly:        Set SetOf = SetOfParamOnly(ipRangeItem)
        Case e_SetoF.m_NotCommon:        Set SetOf = SetOfNotCommon(ipRangeItem)
        Case e_SetoF.m_Unique:           Set SetOf = SetofUnique(ipRangeItem)
        Case Else
            Err.Raise 17 + vbObjectError, _
                "VBALib.Seq.SetOf", _
                Fmt.Text("Invalid e_set member. Expecting {0} to {1}. Got {2}", e_SetoF.m_First, e_SetoF.m_Last, ipSet)

    End Select

 End Function


Private Function SetOfCommon(ByRef ipRangeItem As SeqL) As SeqL

    Dim myS As SeqL
    Set myS = SeqL.Deb

    Dim myIndex As Long
    For myIndex = ipRangeItem.FirstIndex To ipRangeItem.LastIndex
        If myS.LacksItem(ipRangeItem.Item(myIndex)) Then
            If Me.HoldsItem(ipRangeItem.Item(myIndex)) Then
                myS.Add ipRangeItem.Item(myIndex)
            End If
        End If
    Next

    Set SetOfCommon = myS

End Function


Private Function SetOfHostOnly(ByRef ipRangeItem As SeqL) As SeqL

    Dim myS As SeqL
    Set myS = Me.Unique

    Dim myIndex As Long
    For myIndex = ipRangeItem.FirstIndex To ipRangeItem.LastIndex

        If myS.HoldsItem(ipRangeItem.Item(myIndex)) Then
            myS.Remove ipRangeItem.Item(myIndex)
        End If

    Next

    Set SetOfHostOnly = myS


End Function

Private Function SetOfParamOnly(ByRef ipRangeItem As SeqL) As SeqL

    Dim myS As SeqL
    Set myS = SeqL.Deb

    Dim myIndex As Long
    For myIndex = ipRangeItem.FirstIndex To ipRangeItem.LastIndex

        If Me.LacksItem(ipRangeItem.Item(myIndex)) Then
            myS.Add ipRangeItem.Item(myIndex)
        End If

    Next

    Set SetOfParamOnly = myS


End Function

Private Function SetOfNotCommon(ByRef ipRangeItem As SeqL) As SeqL

    Dim myS As SeqL
    Set myS = Me.Unique

    Dim myIndex As Long
    For myIndex = ipRangeItem.FirstIndex To ipRangeItem.LastIndex

        If myS.HoldsItem(ipRangeItem.Item(myIndex)) Then
            myS.RemoveAll ipRangeItem.Item(myIndex)
        Else
            myS.Add ipRangeItem.Item(myIndex)
        End If

    Next

    Set SetOfNotCommon = myS

End Function

Private Function SetofUnique(ByRef ipRangeItem As SeqL) As SeqL

    Dim myS As SeqL
    Set myS = Me.Unique

    Dim myIndex As Long
    For myIndex = ipRangeItem.FirstIndex To ipRangeItem.LastIndex
        If myS.LacksItem(ipRangeItem.Item(myIndex)) Then
            myS.Add ipRangeItem.Item(myIndex)
        End If
    Next

    Set SetofUnique = myS

End Function

'@Description("Swaps the Items at the specified indexes")
Public Sub Swap(ByRef ipLHSIndex As Long, ByRef ipRHSIndex As Long)
Attribute Swap.VB_Description = "Swaps the Items at the specified indexes"

    Dim myTemp As Variant
    
    If VBA.IsObject(Item(ipLHSIndex)) Then
        Set myTemp = Item(ipLHSIndex)
    Else
        myTemp = Item(ipLHSIndex)
    End If
    
    If VBA.IsObject(Item(ipRHSIndex)) Then
        Set Item(ipLHSIndex) = Item(ipRHSIndex)
    Else
        Item(ipLHSIndex) = Item(ipRHSIndex)
    End If
    
    If VBA.IsObject(myTemp) Then
        Set Item(ipRHSIndex) = myTemp
    Else
        Item(ipRHSIndex) = myTemp
    End If

End Sub

Private Function GetNodeAt(ByRef ipIndex As Long) As SeqLNode

    Dim myNode As SeqLNode
    Set myNode = s.Root
    
    Dim myCount As Long
    myCount = 1
    
    Do While myCount < ipIndex
        
        Set myNode = myNode.Succ
        myCount = myCount + 1
        
    Loop

    Set GetNodeAt = myNode
    
End Function


Private Function GetNodeInfo(ByRef ipItem As Variant) As KVPair

    If s.Root Is Nothing Then
        Set GetNodeInfo = Nothing
        Exit Function
    End If
    
    Dim myNode As SeqLNode
    Set myNode = s.Root
    
    Dim myIndex As Long
    myIndex = 0
    
    Do
    
        myIndex = myIndex + 1
        
        If ComparerHelpers.Equals(myNode.Item, ipItem) Then
            Set GetNodeInfo = KVPair(myIndex, myNode)
            Exit Function
        End If
        
        Set myNode = myNode.Succ
        
    Loop Until myNode Is Nothing

    Set GetNodeInfo = Nothing
    
End Function
