VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "SeqL"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_Description = "SeqL is a Collection/ArrayList replacement. Items are stored in an Double Linked List.  Order of addition is preserved. Indexing is 1 based. Keys are not supported (See Kvp classes)"
'@PredeclaredId
'@Exposed
'@Folder("Seq")
'@ModuleDescription("SeqL is a Collection/ArrayList replacement. Items are stored in an Double Linked List.  Order of addition is preserved. Indexing is 1 based. Keys are not supported (See Kvp classes)")
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' 1 based indexing
' Does not support NewEnum (See Iteritems)

' SeqH uses the VBA Collection class as a host for the items
' Other versions of SeqL are available (SeqA, SeqAL, SeqL, SeqLH, SeqT)

' Seq classes do not implement NewEnum because not all classes support such a method.
' Instead the use of the iteritems class is promoted for a superior for each experiece.
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Items are accessed using 1 based indexing
' Not enumerable via NewEnum (See Iteritems)
' Keys are not suportes (see Kvp classes)
' Preserves order of addition.
' Insertion at a defined position is supported
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
Option Explicit
' constants common to all seq classes

Implements ISeq

Private Const MY_TYPENAME                       As String = "SeqL"
Private Const FIRST_INDEX                       As Long = 1
Private Const WHOLE_SEQ                         As Long = -1
Private Const TO_LAST_INDEX                     As Long = 0
Private Const DEFAULT_STEP                      As Long = 1
Private Const LACKS_ITEMS                       As Long = -1
Private Const INDEX_OUT_OF_BOUNDS               As Long = -1
Private Const NOT_FOUND                         As Long = -1



Private Type Host
    Count                                       As Long
End Type


Private Type State
    Root                                        As SeqLNode
    Last                                        As SeqLNode
End Type

Private s                                       As State


Private Type Properties
    FirstIndex                                  As Long
    Count                                       As Long
End Type

Private p                                       As Properties

' Deb is a Factory method of the PredeclaredId which returns a new instance of SeqL
'=================================================================================
' The input for Deb is a ParamArray.
' The ParamArray is interpreted according to the folowing rules
' If the ParamArray contains no Items
' - A empty SeqLuence (count = 0)
' If the ParamArray has 2 or more items
' - A SeqL of size equal to the ParamArray, items as generated by for each over the ParamArray
' If the ParamArray has a single Item
' - Number: Ignored: There is no underlying data structure that requires a capacity to be set
' - String: A Seq whose capacity is the length of the string with one character per Item
' - Array: Seq of items as provided by For Each over the array.  Multidimension arrays are flattened but the position in the original array can be calculated by the user if required. See also Bind
' - Dictionaries: a Seq of key/value arrays as generated from for each on the Keys array.
' - Collection: The collection is copied to the Host collection.  There is no refererence link to the original collection (See Host Property)
' - SeqL: Items as generated by for each on the SeqL
' - mscorlib Arraylist: Items as generated by for each on the arrylist
' - mscorlib Stack: Items as generated by for each on the stack
' - mscorlib Queue: Items as generated by for eac on the queue

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'Setup and reinitialisation methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'@DefaultMember
Public Function Deb(ParamArray ipParamarray() As Variant) As SeqL
Attribute Deb.VB_UserMemId = 0
    With New SeqL
        Set Deb = .ConstructInstance(VBA.CVar(ipParamarray))
    End With
End Function


Friend Function ConstructInstance(ByRef ipFPA As Variant) As SeqL
     
    p.Count = 0
    p.FirstIndex = FIRST_INDEX
    Set s.Root = Nothing
    Set s.Last = s.Root
    
    ' Check to see if we return a default 'empty' seq
    If ArrayOp.LacksItems(ipFPA) Then
        Set ConstructInstance = Me
        Exit Function
    End If
    
    ' ipParamArray contains one or more items depending on the input type.
    ' if the input contains only a single item we want to use that item
    ' else we want to treat the forwrded paramarray as a single array item
    
    Dim myItem As Variant
    If ArrayOp.HoldsOneItem(ipFPA) Then
        If VBA.IsObject(ipFPA(0)) Then
            Set myItem = ipFPA(0)
        Else
            myItem = ipFPA(0)
        End If
    Else
        myItem = ipFPA
    End If
    
    If GroupInfo.IsNumber(myItem) Then
        Set ConstructInstance = Me
        Exit Function
    End If
    
    ' Resolve the items in the forwarded paramarray using the rules
    ' as described above.
    Select Case True
    
        Case VBA.IsArray(myItem):               Set ConstructInstance = AddRange(ArrayOp.Linearise(myItem))
        Case GroupInfo.IsContainer(myItem):     Set ConstructInstance = AddRange(myItem)
        Case GroupInfo.IsString(myItem):        Set ConstructInstance = AddRange(myItem)
        Case Else:                              Set ConstructInstance = AddItems(myItem)
    End Select

End Function

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Core methods - essential for making the class work and status of the object
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'@Description("Add a single item.  Returns the index at which the item was added for compatibility with the mscorlib ArrayList.")
Public Function Add(ByVal ipItem As Variant) As Long
Attribute Add.VB_Description = "Add a single item.  Returns the index at which the item was added for compatibility with the mscorlib ArrayList."
    
    Dim myNode As SeqLNode: Set myNode = SeqLNode(Nothing, Nothing, ipItem)
    
    If Me.LacksItems Then
        SetupFirstNode myNode
    Else
        AppendNode myNode
    End If
    
    p.Count = p.Count + 1
    
    Add = p.Count
    
End Function


'@Description("Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer")
Public Function Count(Optional ByRef ipItem As Variant) As Long
Attribute Count.VB_Description = "Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer"

    Count = LACKS_ITEMS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If VBA.IsMissing(ipItem) Then
        Count = p.Count
        Exit Function
    End If

    Dim myCount As Long: myCount = 0

    Dim myNode As SeqLNode: Set myNode = s.Root
    Do
    
        If Comparers.EQ(myNode.Item, ipItem) Then
            myCount = myCount + 1
        End If
        
        Set myNode = myNode.Succ
        
    Loop Until myNode Is Nothing

    Count = myCount

End Function


'@Description("Inserts a single item at the specified index")
Public Function InsertAt(ByVal ipIndex As Long, ByVal ipItem As Variant) As Long
Attribute InsertAt.VB_Description = "Inserts a single item at the specified index"

    InsertAt = INDEX_OUT_OF_BOUNDS
    
    If Guard.IndexOutOfBounds(ipIndex, Me, "InsertAt", Guard.REPORT_BACK) Then
        Exit Function
    End If

    Dim myNewNode As SeqLNode: Set myNewNode = SeqLNode(Nothing, Nothing, ipItem)
    
    If ipIndex = p.FirstIndex Then
        PrependNode myNewNode
    Else
        InsertNode ipIndex, myNewNode
    End If
    
    p.Count = p.Count + 1
    InsertAt = ipIndex

End Function

Public Property Get Item(ByVal ipIndex As Long) As Variant

    Item = Null
    
    If Guard.IndexOutOfBounds(ipIndex, Me, "Get Item", Guard.REPORT_BACK) Then
        Exit Property
    End If

    Dim myItem As Variant: myItem = Array(GetNodeAt(ipIndex).Item)

    If VBA.IsObject(myItem(0)) Then
        Set Item = myItem(0)
    Else
        Item = myItem(0)
    End If

End Property


Public Property Let Item(ByVal ipIndex As Long, ByVal ipItem As Variant)

    Guard.IndexOutOfBounds ipIndex, Me, "Let_Item"

    Dim myNode As SeqLNode: Set myNode = GetNodeAt(ipIndex)
    myNode.Item = ipItem

End Property


Public Property Set Item(ByVal ipIndex As Long, ByVal ipItem As Variant)

    Guard.IndexOutOfBounds ipIndex, Me, "Set Item"

    Dim myNode As SeqLNode: Set myNode = GetNodeAt(ipIndex)
    Set myNode.Item = ipItem

End Property

'@Description("Removes the first encountered item from the Seq")
Public Function Remove(ByRef ipItem As Variant) As Long
Attribute Remove.VB_Description = "Removes the first encountered item from the Seq"

    Remove = NOT_FOUND

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myNodeInfo As KVPair: Set myNodeInfo = GetNodeInfo(ipItem)

    If NotFound(myNodeInfo.Item(1)) Then
        Exit Function
    End If

    RemoveNode myNodeInfo.Item(1)
        
    Remove = myNodeInfo.Key
    
End Function

'@Description("Removes the item at the specified index")
Public Function RemoveAt(ByVal ipIndex As Long) As Long
Attribute RemoveAt.VB_Description = "Removes the item at the specified index"

    RemoveAt = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If Guard.IndexOutOfBounds(ipIndex, Me, "RemoveAt", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    Dim myNode As SeqLNode: Set myNode = GetNodeAt(ipIndex)
    
    RemoveNode myNode
    RemoveAt = ipIndex
    
End Function

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Sugar methods' Add to the flexibility of the seq class using the above methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
Public Function Clone() As SeqL

    Dim myS As SeqL: Set myS = SeqL.Deb
    Set Clone = myS
    
    If Me.LacksItems Then
        Exit Function
    End If

    Dim myNode As SeqLNode: Set myNode = s.Root

    Do
        myS.Add myNode.Item
        Set myNode = myNode.Succ
    Loop Until myNode Is Nothing

    Set Clone = myS

End Function


'@Description("Returns the Items in the seq as an Array() of variants")
Public Function Items() As Variant
Attribute Items.VB_Description = "Returns the Items in the seq as an Array() of variants"

    Items = Array()
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Items = Me.ToArray
    
End Function

'@Description("Returns a string representation of the Items")
Public Function Join(Optional ByRef ipSeparator As String = Chars.twComma) As String
Attribute Join.VB_Description = "Returns a string representation of the Items"
    Join = Strs.Inner(Fmt.ItemSeparator(ipSeparator).Text("{0}", Me))
End Function

'@Description("Returns a subset of the SeqL")
Public Function Slice _
( _
Optional ByRef ipStart As Long = FIRST_INDEX, _
Optional ByRef ipRun As Long = WHOLE_SEQ, _
Optional ByRef ipStep As Long = DEFAULT_STEP _
) As SeqL
Attribute Slice.VB_Description = "Returns a subset of the SeqL"

    ' ToDo: Should all Seq return a SeqA for SLice?
    Set Slice = SeqL.Deb

    If Me.LacksItems Then
        Exit Function
    End If

    Guard.IndexOutOfBounds ipStart, Me, "Slice"

    Dim myEnd As Long
    If ipRun < Me.FirstIndex Then
        myEnd = Me.LastIndex
    Else
        myEnd = ipStart + ipRun - 1
        If myEnd > Me.LastIndex Then
            myEnd = Me.LastIndex
        End If
    End If

    Dim myS As SeqL: Set myS = SeqL.Deb

    Dim myNode As SeqLNode: Set myNode = GetNodeAt(ipStart)

    Do Until (ipStart > myEnd)
        myS.Add myNode.Item
        Dim myStep As Long
        For myStep = 1 To ipStep
            If myNode.Succ Is Nothing Then
                Exit Do
            End If
            ipStart = ipStart + 1
            Set myNode = myNode.Succ
        Next
    Loop

    Set Slice = myS

End Function


'@Description("Returns a shallow copy of the SeqL as an Array.  The Lbound of the array is 1")
Public Function ToArray() As Variant
Attribute ToArray.VB_Description = "Returns a shallow copy of the SeqL as an Array.  The Lbound of the array is 1"

    ToArray = Array()

    If Me.LacksItems Then
        Exit Function
    End If

    Dim myS As SeqA: Set myS = SeqA(Me.LastIndex)

    Dim myNode As SeqLNode: Set myNode = s.Root
    
    Do Until myNode Is Nothing
        
        myS.Add myNode.Item
        Set myNode = myNode.Succ
        
    Loop

    ToArray = myS.ToArray

End Function

'@Description("Returns a shallow copy of the SeqL as a VBA collection")
Public Function ToCollection() As Collection
Attribute ToCollection.VB_Description = "Returns a shallow copy of the SeqL as a VBA collection"

    Dim myC As Collection: Set myC = New Collection
    Set ToCollection = myC
    
    If Me.LacksItems Then
        Exit Function
    End If

    Dim myNode As SeqLNode: Set myNode = s.Root

    Do
        myC.Add myNode.Item
        Set myNode = myNode.Succ
    Loop Until myNode Is Nothing

    Set ToCollection = myC

End Function


'@Description("Returns the predefined firstindex")
Public Function FirstIndex() As Long
Attribute FirstIndex.VB_Description = "Returns the predefined firstindex"
    FirstIndex = p.FirstIndex
End Function


'@Description("Returns the LastIndex of the Seq or -1 if the Seq is empty.  Equivalent to Count.")
Public Function LastIndex() As Long
Attribute LastIndex.VB_Description = "Returns the LastIndex of the Seq or -1 if the Seq is empty.  Equivalent to Count."

    If Me.Count < Me.FirstIndex Then
        LastIndex = LACKS_ITEMS
    Else
        LastIndex = Me.Count
    End If

End Function


'@Description("Returns the predefined First but One index")
Public Function FBOIndex() As Long
Attribute FBOIndex.VB_Description = "Returns the predefined First but One index"
    FBOIndex = Me.FirstIndex + 1
End Function


'Description("Returns the index of the second to last item in the SeqL, or -1 if the SeqL has lees than 2 items")
Public Function LBOIndex() As Long

    If Me.LastIndex < Me.FBOIndex Then
        LBOIndex = LACKS_ITEMS
    Else
        LBOIndex = Me.LastIndex - 1
    End If
   
End Function


'@Description("Returns the item at FirstIndex")
Public Property Get First() As Variant
Attribute First.VB_Description = "Returns the item at FirstIndex"

    First = Null
    
    If Me.LacksItems Then
        Exit Property
    End If

    If VBA.IsObject(s.Root.Item) Then
        Set First = s.Root.Item
    Else
        First = s.Root.Item
    End If

End Property


'@Description("Assigns to the Item at FirstIndex")
Public Property Let First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    ' ToDo: review if the add action is better as an error
    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If

    s.Root.Item = ipItem

End Property


'@Description("Assigns to the Item at FirstIndex")
Public Property Set First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If

    Set s.Root.Item = ipItem

End Property


'@Description("Returns the Item at LastIndex")
Public Property Get Last() As Variant
Attribute Last.VB_Description = "Returns the Item at LastIndex"

    Last = Null
    
    If Me.LacksItems Then
        Exit Property
    End If
    
    If VBA.IsObject(s.Last.Item) Then
        Set Last = s.Last.Item
    Else
        Last = s.Last.Item
    End If

End Property


'@Description("Assigns to the Item at LastIndex")
Public Property Let Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the Item at LastIndex"

    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If

    s.Last.Item = ipItem

End Property


'@Description("Assigns to the item at LastIndex")
Public Property Set Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the item at LastIndex"

    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If

    Set s.Last.Item = ipItem
   
End Property


'@Description("Returns the item at First but one Index")
Public Property Get FBO() As Variant
Attribute FBO.VB_Description = "Returns the item at First but one Index"

    FBO = Null
    
    If Guard.IndexNotFound(FBOIndex, Me, "Get FBO", Guard.REPORT_BACK) Then
        Exit Property
    End If
    
    If VBA.IsObject(s.Root.Succ.Item) Then
        Set FBO = s.Root.Succ.Item
    Else
        FBO = s.Root.Succ.Item
    End If

End Property


'@Description("Assigns to the Item at First but one Index")
Public Property Let FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at First but one Index"

    Guard.IndexNotFound FBOIndex, Me, "Let FBO"

    s.Root.Succ.Item = ipItem
  
End Property


'@Description("Assigns to the Item at First but one Index")
Public Property Set FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at First but one Index"

    Guard.IndexNotFound FBOIndex, Me, "Set FBO"

    Set s.Root.Succ.Item = ipItem

End Property


'@Description("Returns the Item at Lastbut one Index")
Public Property Get LBO() As Variant
Attribute LBO.VB_Description = "Returns the Item at Lastbut one Index"

    LBO = Null
    
    If Guard.IndexNotFound(Me.FBOIndex, Me, "Get LBO", Guard.REPORT_BACK) Then
        Exit Property
    End If
    
    If VBA.IsObject(s.Last.Pred.Item) Then
        Set LBO = s.Last.Pred.Item
    Else
        LBO = s.Last.Pred.Item
    End If

End Property


'@Description("Assigns to the Item at Last but one Index")
Public Property Let LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the Item at Last but one Index"

     Guard.IndexNotFound Me.LBOIndex, Me, "Let LBO"

     s.Last.Pred.Item = ipItem

End Property


'@Description("Assigns to the item at Last but one Index")
Public Property Set LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the item at Last but one Index"

    Guard.IndexNotFound Me.LBOIndex, Me, "Set LBO"

    s.Last.Pred.Item = ipItem
   
End Property


Public Function IndexOf _
( _
    ByVal ipItem As Variant, _
    Optional ByVal ipStart As Long = FIRST_INDEX, _
    Optional ByVal ipRun As Long = TO_LAST_INDEX _
) As Long
    
    IndexOf = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If Guard.IndexOutOfBounds(ipStart, Me, "IndexOf", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    ' No quick check for lacksitem as its too expensive

    ' ensure that ipstart+iprun only goes to the end of the seq
    Dim myEnd As Long
    If ipRun = TO_LAST_INDEX Then
        myEnd = Me.LastIndex
    ElseIf ipRun > 0 Then
        myEnd = ipStart + ipRun - 1
        If myEnd > Me.LastIndex Then
            myEnd = Me.LastIndex
        End If
    Else
        Exit Function
    End If
    
    ' we only need to search in the range defined by ipStart, myEnd
    Dim myNode As SeqLNode: Set myNode = GetNodeAt(ipStart)
    
    Dim myIndex As Long
    For myIndex = ipStart To myEnd
        
        If Comparers.EQ(myNode.Item, ipItem) Then
            IndexOf = myIndex
            Exit Function
        End If
        
        Set myNode = myNode.Succ
    
    Next
    
End Function

'@Description("Returns the index of the first Item found or -1.  Search range may be specified")
Public Function LastIndexOf _
( _
ByVal ipItem As Variant, _
Optional ByVal ipStart As Long = FIRST_INDEX, _
Optional ByVal ipRun As Long = TO_LAST_INDEX _
) As Long
Attribute LastIndexOf.VB_Description = "Returns the index of the first Item found or -1.  Search range may be specified"

    LastIndexOf = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If Guard.IndexOutOfBounds(ipStart, Me, "LastIndexOf", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    ' No quick check for lacksitem as its too expensive

    ' ensure that ipstart+iprun only goes to the end of the seq
    Dim myEnd As Long
    If ipRun = TO_LAST_INDEX Then
        myEnd = Me.LastIndex
    ElseIf ipRun > 0 Then
        myEnd = ipStart + ipRun - 1
        If myEnd > Me.LastIndex Then
            myEnd = Me.LastIndex
        End If
    Else
        Exit Function
    End If
    
    Dim myNode As SeqLNode: Set myNode = GetNodeAt(myEnd)
    
    Dim myIndex As Long
    For myIndex = myEnd To ipStart Step -1
        
        If Comparers.EQ(myNode.Item, ipItem) Then
            LastIndexOf = myIndex
            Exit Function
        End If
        
        Set myNode = myNode.Pred
    
    Next
    
    LastIndexOf = NOT_FOUND
    
End Function




'@Description("Add Items in the paramarray to the  )
Public Function AddItems(ParamArray ipParamarray() As Variant) As SeqL

    If ArrayOp.LacksItems(VBA.CVar(ipParamarray)) Then
        Set AddItems = Me
        Exit Function
    End If

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))

    AddRange myParamarray

    Set AddItems = Me

End Function


'@Description("Add an array,  list type, dictionary type, or characters of a string")
Public Function AddRange(ByVal ipRange As Variant) As SeqL
Attribute AddRange.VB_Description = "Add an array,  list type, dictionary type, or characters of a string"

    Set AddRange = Me
    
    Guard.InvalidRangeItem ipRange, MY_TYPENAME & ".AddRange", Guard.REPORT_BACK
    
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        If GroupInfo.IsItemByKey(ipRange) Then
            Me.Add Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            Me.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set AddRange = Me
    
End Function


'@Description("Inserts one or more items starting at ipIndex")
Public Function InsertAtItems(ByVal ipIndex As Long, ParamArray ipParamarray() As Variant) As SeqL
Attribute InsertAtItems.VB_Description = "Inserts one or more items starting at ipIndex"
    
    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set InsertAtItems = InsertAtRange(ipIndex, myParamarray)
    
End Function

'@Description("Inserts items in a cotainer starting at ipIndex")
Public Function InsertAtRange(ByVal ipIndex As Long, ByRef ipRange As Variant) As SeqL
Attribute InsertAtRange.VB_Description = "Inserts items in a cotainer starting at ipIndex"

    Set InsertAtRange = Me

    If Guard.IndexOutOfBounds(ipIndex, Me, "InsertAtRange", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    Guard.InvalidRangeItem ipRange, MY_TYPENAME & ".InsertAtRange"
    
    ' insert in reverse order so we don't have to increment ipIndex
    Dim myItems As IterItems: Set myItems = IterItems(ipRange).MoveToEndIndex
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
    
        If GroupInfo.IsItemByKey(ipRange) Then
            InsertAt ipIndex, Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            InsertAt ipIndex, myItems.CurItem(0)
        End If
   
    Loop While myItems.MovePrev
    
    Set InsertAtRange = Me
    
End Function


'@Description "Removes the first encountered item from the Seq for each item in the ParamArray"
Public Function RemoveItems(ParamArray ipParamarray() As Variant) As SeqL
Attribute RemoveItems.VB_Description = "Removes the first encountered item from the Seq for each item in the ParamArray"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set RemoveItems = RemoveRange(myParamarray)
    
    Set RemoveItems = Me
    
End Function


'@Description("Remove items in the specified range of Indexes")
Public Function RemoveRange(ByRef ipRange As Variant) As SeqL
Attribute RemoveRange.VB_Description = "Remove items in the specified range of Indexes"

    Set RemoveRange = Me
    
    If Me.LacksItems Then
        Exit Function
    End If

    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        Dim myNode As SeqLNode: Set myNode = GetNodeInfo(myItems.CurItem(0)).Item(1)
        If Not myNode Is Nothing Then
            RemoveNode myNode
        End If
    Loop While myItems.MoveNext
    
    Set RemoveRange = Me
    
End Function

Public Function RemoveAll(ParamArray ipParamarray() As Variant) As SeqL

    Set RemoveAll = Me
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))

    
    If ArrayOp.LacksItems(myParamarray) Then
        ' For SeqL removeall is effectively the same as reset
        RemoveAllItems
        Exit Function
    End If
    
    Dim myParam As Variant
    For Each myParam In myParamarray
        RemoveAllSingleItem myParam
    Next
    
    Set RemoveAll = Me

End Function


'@Description("Removes all Items from the SeqL")
Public Function Clear() As SeqL
Attribute Clear.VB_Description = "Removes all Items from the SeqL"
    Set Clear = RemoveAll
End Function


'@Description("Removes all Items by replacing the Host collection with a new collection")
Public Function Reset() As SeqL
Attribute Reset.VB_Description = "Removes all Items by replacing the Host collection with a new collection"

    Set Reset = Me

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myNode As SeqLNode: Set myNode = s.Last
    Do Until myNode.Pred Is Nothing
        Dim myTmp As SeqLNode: Set myTmp = myNode
        Set myNode = myNode.Pred
        RemoveNode myTmp
    Loop
    
    Set s.Root = Nothing
    Set s.Last = Nothing
    
End Function




'@Description("Removes the first encountered item from the SeqL")
Public Function RemoveIndexes(ParamArray ipParamarray() As Variant) As SeqL
Attribute RemoveIndexes.VB_Description = "Removes the first encountered item from the SeqL"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set RemoveIndexes = RemoveIndexesRange(myParamarray)
    
    Set RemoveIndexes = Me
    
End Function


'@Description("Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use")
Public Function RemoveIndexesRange(ByRef ipRange As Variant) As SeqL
Attribute RemoveIndexesRange.VB_Description = "Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use"

    Set RemoveIndexesRange = Me
    
    If Me.LacksItems Then
        Exit Function
    End If

    ' We cannot use iteritems on ipRange directly because
    ' we need to ensure that the indexes are removed in reverse
    ' order to avoid indexes being disconnected from thier original positions
    Dim myS As SeqA
    ' SeqA will combine keys and items to a an array
    ' if ipRange is a dictionary
    ' so we choose to select the Items as the indexes

    If GroupInfo.IsItemByKey(ipRange) Then
        Set myS = SeqA(ipRange.Items)
    Else
        Set myS = SeqA(ipRange)
    End If
    
    If myS.LacksItems Then
        Exit Function
    End If
        
    myS.Sorted
    
    'Remove the sorted indexes in reverse order
    Dim myItems As IterItems: Set myItems = IterItems(myS).MoveToEndIndex
    Do
         RemoveNode GetNodeAt(myItems.CurItem(0))
    Loop While myItems.MovePrev
    
    Set RemoveIndexesRange = Me
    
End Function

Public Function Fill(ByRef ipItem As Variant, Optional ByVal ipCount As Long = 1) As SeqL

    Set Fill = Me
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        Me.Add ipItem
    Next

End Function


'@Description("Returns the first N items of the SeqL, Default 1")
Public Function Head(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As SeqL
Attribute Head.VB_Description = "Returns the first N items of the SeqL, Default 1"

    Set Head = SeqL.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If

    If ipSplitAfter < Me.FirstIndex Then
        Exit Function
    End If

    If ipSplitAfter >= Me.LastIndex Then
        Set Head = Me.Clone
        Exit Function
    End If

    Set Head = Me.Slice(Me.FirstIndex, ipSplitAfter)

End Function


'@Description("Returns the Items after SplitAfter, Default is Index 2")
Public Function Tail(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As SeqL
Attribute Tail.VB_Description = "Returns the Items after SplitAfter, Default is Index 2"

    Set Tail = SeqL.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If

    If ipSplitAfter >= Me.LastIndex Then
        Exit Function
    End If
    
    If ipSplitAfter < Me.FirstIndex Then
        Set Tail = Me.Clone
        Exit Function
    End If

    Set Tail = Me.Slice(ipSplitAfter + 1)

End Function


Public Function RotLeft(Optional ByVal ipCount As Long = 1) As SeqL
    
    Set RotLeft = Me
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount = 0 Then
        Exit Function
    End If
    
    If ipCount < 0 Then
        Set RotLeft = RotRight(VBA.Abs(ipCount))
        Exit Function
    End If
    
    Me.AddRange Me.DequeueRange(ipCount)
    
End Function


Public Function RotRight(Optional ByVal ipCount As Long = 1) As SeqL
    
    Set RotRight = Me
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount = 0 Then
        Exit Function
    End If
    
    If ipCount < 0 Then
        Set RotRight = RotLeft(VBA.Abs(ipCount))
        Exit Function
    End If
    
    Me.InsertAtRange 1, Me.PopRange(ipCount).Reverse
    
End Function

Public Function HoldsItem(ByRef ipItem As Variant) As Boolean

    HoldsItem = False
    
    If Me.LacksItems Then
        Exit Function
    End If

    
    Dim myNode As SeqLNode: Set myNode = GetNodeInfo(ipItem).Item(1)
   
    Do Until myNode Is Nothing
    
        If Comparers.EQ(myNode.Item, ipItem) Then
            HoldsItem = True
            Exit Function
        End If
        
        Set myNode = myNode.Succ
        
    Loop

End Function


Public Function Contains(ByRef ipItem As Variant) As Boolean
    Contains = Me.HoldsItem(ipItem)
End Function


Public Function LacksItem(ByRef ipItem As Variant) As Boolean
    LacksItem = Not Me.HoldsItem(ipItem)
End Function


Public Function HoldsItems() As Boolean
    HoldsItems = Not s.Root Is Nothing
End Function


Public Function LacksItems() As Boolean
    LacksItems = Not Me.HoldsItems
End Function


Public Property Get TypeName() As String
    TypeName = MY_TYPENAME
End Property

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' An attempt as  providing some 'lambda' functionality - see IMapper and mp/cmp/rd classes
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C

'@Description("Mutates the Seq in place by applying the function in IMapper to each item")
Public Function MappedIt(ByRef ipMapper As IMapper) As SeqL
Attribute MappedIt.VB_Description = "Mutates the Seq in place by applying the function in IMapper to each item"
    'Mapped it works by reference but we allow a function return to enable fluid use of Mappedit
    
    Set MappedIt = Me

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myNode As SeqLNode: Set myNode = s.Root
    Do Until myNode Is Nothing

        Dim myA() As Variant: myA = ipMapper.ExecMapper(myNode.Item)

        If VBA.IsObject(myA(0)) Then
            Set myNode.Item = myA(0)
        Else
            myNode.Item = myA(0)
        End If
        
        Set myNode = myNode.Succ
        
    Loop

    Set MappedIt = Me

End Function


'@Description("Returns a new Seq where each item in the Host has been mutated by the function provided by IMapper")
Public Function MapIt(ByVal ipMapper As IMapper) As SeqL
Attribute MapIt.VB_Description = "Returns a new Seq where each item in the Host has been mutated by the function provided by IMapper"

    Dim myS As SeqL: Set myS = SeqL.Deb
    Set MapIt = myS

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myNode As SeqLNode: Set myNode = s.Root
    Do
        myS.Add ipMapper.ExecMapper(myNode.Item)(0)
        Set myNode = myNode.Succ
    Loop Until myNode Is Nothing
    
    Set MapIt = myS

End Function


'@Description("Returns a new Seq where each item returns true from the IComparer")
Public Function FilterIt(ByVal ipComparer As IComparer) As SeqL
Attribute FilterIt.VB_Description = "Returns a new Seq where each item returns true from the IComparer"

    Dim myS As SeqL: Set myS = SeqL.Deb
    Set FilterIt = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myNode As SeqLNode: Set myNode = s.Root
    Do

        If ipComparer.ExecCmp(myNode.Item) Then
            myS.Add myNode.Item
        End If

        Set myNode = myNode.Succ
    
    Loop Until myNode Is Nothing

  

End Function


'@Description("Returns the count the number of items where IComparer returns true")
Public Function CountIt(ByVal ipComparer As IComparer) As Long
Attribute CountIt.VB_Description = "Returns the count the number of items where IComparer returns true"

    CountIt = -1
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myCount As Long: myCount = 0
    
    Dim myNode As SeqLNode: Set myNode = s.Root
    Do

        If ipComparer.ExecCmp(myNode.Item) Then
            myCount = myCount + 1
        End If

        Set myNode = myNode.Succ
    
    Loop Until myNode Is Nothing

    CountIt = myCount

End Function


'@Description("Returns the single value computed by the IReducer").
Public Function ReduceIt(ByRef ipReducer As IReducer) As Variant
    
    ReduceIt = Null

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myA() As Variant: myA = ipReducer.ExecReduction(Me)

    If VBA.IsObject(myA(0)) Then
        Set ReduceIt = myA(0)
    Else
        ReduceIt = myA(0)
    End If

End Function


'@Description("Adds one or more items to the seq at the end of the seq")
Public Function Push(ParamArray ipParamarray() As Variant) As SeqL
Attribute Push.VB_Description = "Adds one or more items to the seq at the end of the seq"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set Push = AddRange(myParamarray)
    
End Function

'@Description("Add the Items in ipRange to the end of the Seq")
Public Function PushRange(ByRef ipRange As Variant) As SeqL
Attribute PushRange.VB_Description = "Add the Items in ipRange to the end of the Seq"
    Set PushRange = AddRange(ipRange)
End Function


'@Description("Removes the last item from the seq and returns it")
Public Function Pop() As Variant
Attribute Pop.VB_Description = "Removes the last item from the seq and returns it"

    Pop = Null

    If Me.LacksItems Then
        Exit Function
    End If
    
    If VBA.IsObject(s.Last.Item) Then
        Set Pop = s.Last.Item
    Else
        Pop = s.Last.Item
    End If

    RemoveNode s.Last
    
    'p.count = p.count - 1
    
End Function

'@Description("Removes ipCount Items from the  end of the Seq. Returns a SeqA of the items in order of removal"
Public Function PopRange(Optional ByVal ipCount As Long = 1) As SeqA

    Set PopRange = SeqA.Deb
    
    If ipCount < Me.FirstIndex Then
        Exit Function
    End If
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount > Me.LastIndex Then
        'Bug: SeqA(Me).reverse instantiates a seqc
        Set PopRange = SeqA(Me.Reverse)
        Me.RemoveAll
        Exit Function
    End If
    
    Dim myS As SeqA: Set myS = SeqA.Deb
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        myS.Add Me.Pop
    Next
    
    Set PopRange = myS
    
End Function


'@Description("Adds items to the seq at the end of the seq")
Public Function enQueue(ParamArray ipParamarray() As Variant) As SeqL
Attribute enQueue.VB_Description = "Adds items to the seq at the end of the seq"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set enQueue = AddRange(myParamarray)
    
End Function


Public Function EnqueueRange(ByRef ipRange As Variant) As SeqL
    Set EnqueueRange = AddRange(ipRange)
End Function


Public Function Dequeue() As Variant

    Dequeue = Null

    If Me.LacksItems Then
        Exit Function
    End If
    
    If VBA.IsObject(s.Root.Item) Then
        Set Dequeue = s.Root.Item
    Else
        Dequeue = s.Root.Item
    End If

    RemoveNode s.Root
    
End Function


Public Function DequeueRange(Optional ByRef ipCount As Long = 1) As SeqA

    Set DequeueRange = SeqA.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount < 1 Then
        Exit Function
    End If

    If ipCount > Me.LastIndex Then
        ipCount = Me.LastIndex
    End If
    
    Dim myS As SeqA: Set myS = SeqA.Deb
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        myS.Add Me.Dequeue
    Next
    
    Set DequeueRange = myS
    
End Function


'@Description("Returns a new sequence sorted in 'Ascending' order"
Public Function Sort() As SeqL

    Dim myS As SeqL: Set myS = SeqL.Deb
        
    If Me.LacksItems Then
        Set Sort = myS
        Exit Function
    End If
         
    '@Ignore AssignmentNotUsed
    Set myS = Me.Clone
    Sorters.ShakerSortByItem myS
    Set Sort = myS
    
End Function


'@Description("Sorts the seq in place in 'Ascending' order ")
Public Function Sorted() As SeqL
Attribute Sorted.VB_Description = "Sorts the seq in place in 'Ascending' order "
        
    Set Sorted = Me

    If Me.LacksItems Then
        Exit Function
    End If
        
    Sorters.ShakerSortByItem Me
    Set Sorted = Me
    
End Function


'@Description("Returns a new seq with Items in reverse order")
Public Sub Swap(ByRef ipLHSIndex As Long, ByRef ipRHSIndex As Long)
Attribute Swap.VB_Description = "Returns a new seq with Items in reverse order"

    Guard.IndexOutOfBounds ipLHSIndex, Me, "Swap"
    Guard.IndexOutOfBounds ipRHSIndex, Me, "Swap"

    Dim myTemp As Variant
    
    If VBA.IsObject(Item(ipLHSIndex)) Then
        Set myTemp = Item(ipLHSIndex)
    Else
        myTemp = Item(ipLHSIndex)
    End If
    
    If VBA.IsObject(Item(ipRHSIndex)) Then
        Set Item(ipLHSIndex) = Item(ipRHSIndex)
    Else
        Item(ipLHSIndex) = Item(ipRHSIndex)
    End If
    
    If VBA.IsObject(myTemp) Then
        Set Item(ipRHSIndex) = myTemp
    Else
        Item(ipRHSIndex) = myTemp
    End If

End Sub

'@Description("Returns a new seq with Items in reverse order")
Public Function Reverse() As SeqL
Attribute Reverse.VB_Description = "Returns a new seq with Items in reverse order"

    Dim myS As SeqL: Set myS = SeqL.Deb
    Set Reverse = myS
    
    If Me.LacksItems Then
        Exit Function
    End If

    Dim myIndex As Long
    For myIndex = p.Count To FIRST_INDEX Step -1
        myS.Add GetNodeAt(myIndex).Item
    Next
     
    Set Reverse = myS

End Function


'@Description("Reverses the order of items in place")
Public Function Reversed() As SeqL
Attribute Reversed.VB_Description = "Reverses the order of items in place"
    
    If p.Count < FIRST_INDEX + 1 Then
        Set Reversed = Me
        Exit Function
    End If
     
    Dim myFirstIndex As Long: myFirstIndex = p.FirstIndex
    Dim myLastIndex As Long: myLastIndex = p.Count
    
    Do
    
        Me.Swap myFirstIndex, myLastIndex
        myFirstIndex = myFirstIndex + 1
        myLastIndex = myLastIndex - 1
    
    Loop Until myFirstIndex >= myLastIndex

    Set Reversed = Me

End Function

'@Description("Returns true if there are no duplicate items")
Public Function IsUnique() As Boolean
Attribute IsUnique.VB_Description = "Returns true if there are no duplicate items"

    If LacksItems Then
        IsUnique = False
        Exit Function
    End If
    
    Dim myS As cHashC: Set myS = New cHashC
    
    Dim myNode As SeqLNode: Set myNode = s.Root
    
    Do
    
        If myS.Exists(myNode.Item) Then
            IsUnique = False
            Exit Function
        Else
            myS.Add myNode.Item
        End If
        
        Set myNode = myNode.Succ
        
    Loop Until myNode Is Nothing

    IsUnique = True

End Function


Public Function IsNotUnique() As Boolean
    IsNotUnique = Not IsUnique
End Function


'@Description("Returns the a new seq with the unique subset of the host Seq")
Public Function Dedup() As SeqL
Attribute Dedup.VB_Description = "Returns the a new seq with the unique subset of the host Seq"

    Dim myS As SeqL: Set myS = SeqL.Deb
    Set Dedup = myS

    If Me.LacksItems Then
        Exit Function
    End If

    Dim myNode As SeqLNode: Set myNode = s.Root
    Do Until myNode Is Nothing
    
        If myS.LacksItem(myNode.Item) Then
            myS.Add myNode.Item
        End If
        
        Set myNode = myNode.Succ
        
    Loop

    Set Dedup = myS
            
End Function


'@Description("Removes duplicate items from the seq")
Public Function Deduped() As SeqL
Attribute Deduped.VB_Description = "Removes duplicate items from the seq"

    Set Deduped = Me
    
    If p.Count <= 1 Then
        Exit Function
    End If
    
    ' first found items are stored in myS
    ' if an item is subsequently found to also be in myS
    ' the node is deleted
    Dim myS As SeqL: Set myS = SeqL.Deb
    
    Dim myNode As SeqLNode: Set myNode = s.Last
    Do Until myNode Is Nothing
    
        If myS.HoldsItem(myNode.Item) Then
        
            Dim myTmpNode As SeqLNode: Set myTmpNode = myNode
            Set myNode = myNode.Pred
            RemoveNode myTmpNode
            
        Else
        
            myS.Add myNode.Item
            Set myNode = myNode.Pred
        End If
        
    Loop
    
    Set Deduped = Me
    
End Function

''@Description("Transposes a seq of seq. Non existent items are replaced by Empty. Muutates seq")
'Public Function Transposed() As SeqA
'
'    'find the maximum size of the inner sequences
'    Dim myMaxRowIndex As Variant: myMaxRowIndex = Me.Clone.ReduceIt(rdInner(rdCountIt)).ReduceIt(rdFoldl(fnMaxNum, Globals.minLong))
'
'    ' The Transpose function cannot assume that the inner sequences are of equal length
'    ' make the inner sequences equal in length.
'    Dim myIndex As Long
'    For myIndex = Me.FirstIndex To Me.LastIndex
'        Dim myCount As Long: myCount = Me.Item(myIndex).LastIndex
'        If myCount < myMaxRowIndex Then
'            Me.Item(myIndex).Fill Empty, myMaxRowIndex - myCount
'        End If
'    Next
'
'    ' create the recipient seq
'    Dim myTrans() As Variant: ReDim myTrans(1 To myMaxRowIndex)
'    For myIndex = 1 To myMaxRowIndex
'        ' we don't know what type of seq is in seqA so call Deb on the instance
'        Set myTrans(myIndex) = Me.First.Deb.Fill(Empty, Me.LastIndex)
'    Next
'
'    ' now do the transposition
'    Dim myRowIndex As Long
'    For myRowIndex = Me.FirstIndex To Me.LastIndex
'
'        Dim myRow As Variant: Set myRow = Me.Item(myRowIndex)
'
'        Dim myColIndex As Long
'        For myColIndex = myRow.FirstIndex To myMaxRowIndex
'
'            If VBA.IsObject(Me.Item(myRowIndex).Item(myColIndex)) Then
'                Set myTrans(myColIndex).Item(myRowIndex) = Me.Item(myRowIndex).Item(myColIndex)
'            Else
'                 myTrans(myColIndex).Item(myRowIndex) = Me.Item(myRowIndex).Item(myColIndex)
'            End If
'
'        Next
'
'    Next
'    'Fmt.Dbg "{0}", myTrans
'    s.Host = myTrans
'    p.Count = myMaxRowIndex
'    p.Size = myMaxRowIndex
'    Set Transposed = Me
'
'End Function

'@Description("Transposes a seq of seq. Non existent items are replaced by Empty")
Public Function Transpose() As SeqL
Attribute Transpose.VB_Description = "Transposes a seq of seq. Non existent items are replaced by Empty"
    
    'find the maximum size of the inner sequences
    Dim myMaxRowIndex As Variant: myMaxRowIndex = Me.Clone.ReduceIt(rdInner(rdCountIt)).ReduceIt(rdFoldl(fnMaxNum, HelpVBA.minLong))
    
    ' The Transpose function cannot assume that the inner sequences are of equal length
    ' make the inner sequences equal in length.
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
        Dim myCount As Long: myCount = Me.Item(myIndex).LastIndex
        If myCount < myMaxRowIndex Then
            Me.Item(myIndex).Fill Empty, myMaxRowIndex - myCount
        End If
    Next
    
    ' create the recipient seq
    Dim myTrans As Variant: Set myTrans = Me.Deb
    For myIndex = 1 To myMaxRowIndex
        ' we don't know what type of seq is in seqA so call Deb on the instance
        myTrans.Add Me.First.Deb.Fill(Empty, Me.LastIndex)
    Next
    
    ' now do the transposition
    Dim myRowIndex As Long
    For myRowIndex = Me.FirstIndex To Me.LastIndex
    
        Dim myRow As Variant: Set myRow = Me.Item(myRowIndex)
        
        Dim myColIndex As Long
        For myColIndex = myRow.FirstIndex To myMaxRowIndex
            
            If VBA.IsObject(Me.Item(myRowIndex).Item(myColIndex)) Then
                Set myTrans.Item(myColIndex).Item(myRowIndex) = Me.Item(myRowIndex).Item(myColIndex)
            Else
                 myTrans.Item(myColIndex).Item(myRowIndex) = Me.Item(myRowIndex).Item(myColIndex)
            End If
 
        Next
        
    Next
    'Fmt.Dbg "{0}", myTrans
    'Set ipSeq = myTrans
    Set Transpose = myTrans

End Function

Public Function Freq() As KvpA

    Dim myK As KvpA: Set myK = KvpA.Deb
    Set Freq = myK
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myNode As SeqLNode: Set myNode = s.Root
    Do
    
        If myK.HoldsItem(myNode.Item) Then
            myK.Item(myNode.Item) = myK.Item(myNode.Item) + 1
        Else
            myK.Add myNode.Item, 1
        End If
         
        Set myNode = myNode.Succ
         
    Loop Until myNode Is Nothing

    Set Freq = myK
    
End Function


Public Function SetOf(ByRef ipSet As e_SetoF, ByRef ipRangeItem As SeqL) As SeqL

    Select Case ipSet

        Case e_SetoF.m_Common:           Set SetOf = SetOfCommon(ipRangeItem)
        Case e_SetoF.m_HostOnly:         Set SetOf = SetOfHostOnly(ipRangeItem)
        Case e_SetoF.m_ParamOnly:        Set SetOf = SetOfParamOnly(ipRangeItem)
        Case e_SetoF.m_NotCommon:        Set SetOf = SetOfNotCommon(ipRangeItem)
        Case e_SetoF.m_Unique:           Set SetOf = SetofUnique(ipRangeItem)
        Case Else
            Err.Raise 17 + vbObjectError, _
            "VBALib.SeqL.SetOf", _
            Fmt.Text("Invalid e_set member. Expecting {0} to {1}. Got {2}", e_SetoF.m_First, e_SetoF.m_last, ipSet)

    End Select

End Function



'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' Private methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
Private Function SetOfCommon(ByRef ipSeq As SeqL) As SeqL

    Dim myS As SeqL: Set myS = SeqL.Deb
    Set SetOfCommon = myS
    
    If Me.LacksItems Or ipSeq.LacksItems Then
        Exit Function
    End If
    
    Dim myNode As SeqLNode: Set myNode = s.Root
    
    Do
        If ipSeq.HoldsItem(myNode.Item) Then
            myS.Add myNode.Item
        End If
        
        Set myNode = myNode.Succ
        
    Loop Until myNode Is Nothing

    Set SetOfCommon = myS

End Function


Private Function SetOfHostOnly(ByRef ipSeq As SeqL) As SeqL

    Dim myS As SeqL: Set myS = SeqL.Deb
    Set SetOfHostOnly = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    If ipSeq.LacksItems Then
        Exit Function
    End If
    
    Dim myNode As SeqLNode: Set myNode = s.Root
    Do
    
        If ipSeq.HoldsItem(myNode.Item) Then
            myS.RemoveAll myNode.Item
        End If
        
        Set myNode = myNode.Succ
        
    Loop Until myNode Is Nothing
    
    Set SetOfHostOnly = myS
    
End Function


Private Function SetOfParamOnly(ByRef ipSeq As SeqL) As SeqL

    Dim myS As SeqL: Set myS = SeqL.Deb
    Set SetOfParamOnly = myS
    
    If ipSeq.LacksItems Then
        Exit Function
    End If
    
    Set myS = ipSeq.Dedup
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myNode As SeqLNode: Set myNode = s.Root
    Do
    
        If myS.HoldsItem(myNode.Item) Then
            myS.RemoveAll myNode.Item
        End If
        
        Set myNode = myNode.Succ
        
    Loop Until myNode Is Nothing
    
    Set SetOfParamOnly = myS
    
End Function


Private Function SetOfNotCommon(ByRef ipSeq As SeqL) As SeqL

    Dim myS As SeqL: Set myS = SeqL.Deb
    Set SetOfNotCommon = myS
    
    If LacksItems And ipSeq.LacksItems Then
        Exit Function
    End If
    
    Dim myNode As SeqLNode: Set myNode = s.Root
    Do
    
        If ipSeq.LacksItem(myNode.Item) Then
            If myS.LacksItem(myNode.Item) Then
                myS.Add myNode.Item
            End If
        End If
        
        Set myNode = myNode.Succ
        
    Loop Until myNode Is Nothing
    
    Dim myItems As IterItems: Set myItems = IterItems(ipSeq)
    Do
    
        If Me.LacksItem(myItems.CurItem(0)) Then
            If myS.LacksItem(myItems.CurItem(0)) Then
                myS.Add myItems.CurItem(0)
            End If
        End If
        
    Loop While myItems.MoveNext
    
    Set SetOfNotCommon = myS

End Function


Private Function SetofUnique(ByRef ipSeq As SeqL) As SeqL

    Dim myS As SeqL: Set myS = SeqL.Deb
    Set SetofUnique = myS
    
    If Me.LacksItems And ipSeq.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    Dim myItems As IterItems: Set myItems = IterItems(ipSeq)
    Do
    
        If myS.LacksItem(myItems.CurItem(0)) Then
            myS.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetofUnique = myS

End Function

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' Private functions
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C

Private Function GetNodeAt(ByRef ipIndex As Long) As SeqLNode

    Dim myNode As SeqLNode: Set myNode = s.Root
    
    Dim myCount As Long
    myCount = 1
    
    Do
        
        If myCount = ipIndex Then
            Set GetNodeAt = myNode
            Exit Function
        End If
        
        Set myNode = myNode.Succ
        myCount = myCount + 1
        
    Loop Until myNode Is Nothing

    Set GetNodeAt = Nothing
    
End Function


Private Function GetNodeInfo(ByRef ipItem As Variant) As KVPair

    Set GetNodeInfo = KVPair(-1, Nothing)
        
    Dim myNode As SeqLNode
    Set myNode = s.Root
    
    Dim myIndex As Long
    myIndex = 0
    
    Do Until myNode Is Nothing
    
        myIndex = myIndex + 1
        
        If Comparers.EQ(myNode.Item, ipItem) Then
            Set GetNodeInfo = KVPair(myIndex, myNode)
            Exit Function
        End If
        
        Set myNode = myNode.Succ
        
    Loop

End Function

'@Description("Add the node to the end of the node list")
Private Sub AppendNode(ByRef ipNode As SeqLNode)
Attribute AppendNode.VB_Description = "Add the node to the end of the node list"

    Set ipNode.Pred = s.Last
    Set ipNode.Succ = Nothing
    Set s.Last.Succ = ipNode
    Set s.Last = ipNode
    
End Sub

'@Description("Insert the new node in the node list before the current node")
Private Sub InsertNode(ByRef ipIndex As Long, ByRef ipNewNode As SeqLNode)
Attribute InsertNode.VB_Description = "Insert the new node in the node list before the current node"

    Dim myCurNode As SeqLNode: Set myCurNode = GetNodeAt(ipIndex)
    
    Set ipNewNode.Pred = myCurNode.Pred
    Set ipNewNode.Succ = myCurNode
    
    Set myCurNode.Pred = ipNewNode
    Set ipNewNode.Pred.Succ = ipNewNode
    
End Sub
'@Description("Inserts newnode at the start of the node list")
Private Sub PrependNode(ByRef ipNode As SeqLNode)
Attribute PrependNode.VB_Description = "Inserts newnode at the start of the node list"

    Set ipNode.Pred = Nothing
    Set ipNode.Succ = s.Root
    Set s.Root.Pred = ipNode
    Set s.Root = ipNode

End Sub

Private Sub SetupFirstNode(ByRef ipNode As SeqLNode)

    Set s.Root = ipNode
    Set s.Last = ipNode
    
End Sub
'@Ignore ProcedureCanBeWrittenAsFunction
Private Sub RemoveNode(ByRef ipNode As SeqLNode)

    If ipNode Is Nothing Then
        Exit Sub
    End If
    
    If p.Count = 1 Then
        Set s.Root = Nothing
        Set s.Last = Nothing
        p.Count = p.Count - 1
        Exit Sub
    End If
    
    '@Ignore VariableNotUsed
    Dim myTmp As SeqLNode:
    ' case of first node
    If ipNode.Pred Is Nothing Then
        Set myTmp = ipNode
        Set s.Root = ipNode.Succ
        Set s.Root.Pred = Nothing
        Set myTmp = Nothing
        p.Count = p.Count - 1
        Exit Sub
    End If
    
    ' case of last node
    If ipNode.Succ Is Nothing Then
        Set myTmp = ipNode
        Set s.Last = ipNode.Pred
        Set s.Last.Succ = Nothing
        Set myTmp = Nothing
        p.Count = p.Count - 1
        Exit Sub
    End If

    '@Ignore AssignmentNotUsed
    Set myTmp = ipNode
    Set ipNode.Pred.Succ = ipNode.Succ
    Set ipNode.Succ.Pred = ipNode.Pred
    Set myTmp = Nothing
    p.Count = p.Count - 1
    
End Sub

Private Sub RemoveAllItems()

    Dim myNode As SeqLNode: Set myNode = s.Last
    
    Do
    
        '@Ignore VariableNotUsed
        Dim myTmpNode As SeqLNode: Set myTmpNode = myNode
        
        Set myNode = myNode.Pred
        Set myTmpNode = Nothing
        
    Loop Until myNode Is Nothing
    
    Set s.Last = Nothing
    Set s.Root = Nothing
    p.Count = 0
    
End Sub


Private Sub RemoveAllSingleItem(ByRef ipItem As Variant)

    Dim myNode As SeqLNode: Set myNode = s.Last

    Do
        
        If Comparers.EQ(myNode.Item, ipItem) Then
           
            Dim myTmp As SeqLNode
            Set myTmp = myNode
            Set myNode = myNode.Pred
            RemoveNode myTmp
            
        Else
        
            Set myNode = myNode.Pred
        
        End If
        
    Loop Until myNode Is Nothing
  
End Sub

Private Function NotFound(ByRef ipItem As Variant) As Boolean

    If VBA.IsObject(ipItem) Then
        NotFound = ipItem Is Nothing
    ElseIf GroupInfo.IsNumber(ipItem) Then
        NotFound = ipItem = -1
    Else
        NotFound -VBA.IsEmpty(ipItem)
    End If
        
End Function

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'Interface Members
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
Private Function ISeq_Deb(ParamArray ipParamarray() As Variant) As Variant
    With New SeqL
        Set ISeq_Deb = .ConstructInstance(VBA.CVar(ipParamarray))
    End With
End Function
Private Function ISeq_Add(ByVal ipItem As Variant) As Long
    ISeq_Add = Add(ipItem)
End Function

Private Function ISeq_Count(Optional ByRef ipItem As Variant) As Long
    ISeq_Count = Count(ipItem)
End Function

Private Function ISeq_InsertAt(ByVal ipIndex As Long, ByVal ipItem As Variant) As Long
    ISeq_InsertAt = InsertAt(ipIndex, ipItem)
End Function

Private Property Get ISeq_Item(ByVal ipIndex As Long) As Variant
    ISeq_Item = Item(ipIndex)
End Property

Private Property Let ISeq_Item(ByVal ipIndex As Long, ByVal ipItem As Variant)
    Item(ipIndex) = ipItem
End Property

Private Property Set ISeq_Item(ByVal ipIndex As Long, ByVal ipItem As Variant)
    Set Item(ipIndex) = ipItem
End Property

Private Function ISeq_Remove(ByRef ipItem As Variant) As Long
    ISeq_Remove = Remove(ipItem)
End Function

Private Function ISeq_RemoveAt(ByRef ipIndex As Long) As Long
    ISeq_RemoveAt = RemoveAt(ipIndex)
End Function

'Private Function ISeq_Bind(ByRef ipArray As Variant) As Variant
'    Set ISeq_Bind = Bind(ipArray)
'End Function

Private Function ISeq_Clone() As Variant
    Set ISeq_Clone = Clone()
End Function

Private Function ISeq_Items() As Variant
    ISeq_Items = Items()
End Function

Private Function ISeq_Join(Optional ByRef ipSeparator As String = Chars.twComma) As String
    ISeq_Join = Join(ipSeparator)
End Function

Private Function ISeq_Slice(Optional ByRef ipStart As Long = FIRST_INDEX, Optional ByRef ipRun As Long = WHOLE_SEQ, Optional ByRef ipStep As Long = DEFAULT_STEP) As Variant
    Set ISeq_Slice = Slice(ipStart, ipRun, ipStep)
End Function

Private Function ISeq_ToArray() As Variant
    ISeq_ToArray = ToArray()
End Function

Private Function ISeq_ToCollection() As Collection
    Set ISeq_ToCollection = ToCollection()
End Function

Private Function ISeq_FirstIndex() As Long
    ISeq_FirstIndex = FirstIndex()
End Function

Private Function ISeq_LastIndex() As Long
    ISeq_LastIndex = LastIndex()
End Function

Private Function ISeq_FBOIndex() As Long
    ISeq_FBOIndex = FBOIndex()
End Function

Private Function ISeq_LBOIndex() As Long
    ISeq_LBOIndex = LBOIndex()
End Function

Private Property Get ISeq_First() As Variant
    ISeq_First = First
End Property

Private Property Let ISeq_First(ByVal ipItem As Variant)
    First = ipItem
End Property

Private Property Set ISeq_First(ByVal ipItem As Variant)
    Set First = ipItem
End Property

Private Property Get ISeq_Last() As Variant
    ISeq_Last = Last
End Property

Private Property Let ISeq_Last(ByVal ipItem As Variant)
    Last = ipItem
End Property

Private Property Set ISeq_Last(ByVal ipItem As Variant)
    Set Last = ipItem
End Property

Private Property Get ISeq_FBO() As Variant
    ISeq_FBO = FBO
End Property

Private Property Let ISeq_FBO(ByVal ipItem As Variant)
    FBO = ipItem
End Property

Private Property Set ISeq_FBO(ByVal ipItem As Variant)
    Set FBO = ipItem
End Property

Private Property Get ISeq_LBO() As Variant
    ISeq_LBO = LBO
End Property

Private Property Let ISeq_LBO(ByVal ipItem As Variant)
    LBO = ipItem
End Property

Private Property Set ISeq_LBO(ByVal ipItem As Variant)
    Set LBO = ipItem
End Property

Private Function ISeq_IndexOf(ByVal ipItem As Variant, Optional ByVal ipStart As Long = FIRST_INDEX, Optional ByVal ipRun As Long = TO_LAST_INDEX) As Long
    ISeq_IndexOf = IndexOf(ipItem, ipStart, ipRun)
End Function

Private Function ISeq_LastIndexOf(ByVal ipItem As Variant, Optional ByVal ipStart As Long = FIRST_INDEX, Optional ByVal ipRun As Long = TO_LAST_INDEX) As Long
    ISeq_LastIndexOf = LastIndexOf(ipItem, ipStart, ipRun)
End Function

Private Function ISeq_AddItems(ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_AddItems = AddItems(ipParamarray)
End Function

Private Function ISeq_AddRange(ByVal ipRange As Variant) As Variant
    Set ISeq_AddRange = AddRange(ipRange)
End Function

Private Function ISeq_InsertAtItems(ByVal ipIndex As Long, ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_InsertAtItems = InsertAtItems(ipIndex, ipParamarray)
End Function

Private Function ISeq_InsertAtRange(ByVal ipIndex As Long, ByRef ipRange As Variant) As Variant
    Set ISeq_InsertAtRange = InsertAtRange(ipIndex, ipRange)
End Function

Private Function ISeq_RemoveItems(ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_RemoveItems = RemoveItems(ipParamarray)
End Function

Private Function ISeq_RemoveRange(ByRef ipRange As Variant) As Variant
    Set ISeq_RemoveRange = RemoveRange(ipRange)
End Function

Private Function ISeq_RemoveAll(ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_RemoveAll = RemoveAll(ipParamarray)
End Function

Private Function ISeq_Clear() As Variant
    Set ISeq_Clear = Clear()
End Function

Private Function ISeq_Reset() As Variant
    Set ISeq_Reset = Reset()
End Function

Private Function ISeq_RemoveIndexes(ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_RemoveIndexes = RemoveIndexes(ipParamarray)
End Function

Private Function ISeq_RemoveIndexesRange(ByRef ipRange As Variant) As Variant
    Set ISeq_RemoveIndexesRange = RemoveIndexesRange(ipRange)
End Function

Private Function ISeq_Fill(ByRef ipItem As Variant, Optional ByVal ipCount As Long = 1) As Variant
    Set ISeq_Fill = Fill(ipItem, ipCount)
End Function

Private Function ISeq_Head(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As Variant
    Set ISeq_Head = Head(ipSplitAfter)
End Function

Private Function ISeq_Tail(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As Variant
    Set ISeq_Tail = Tail(ipSplitAfter)
End Function

Private Function ISeq_RotLeft(Optional ByVal ipCount As Long = 1) As Variant
    Set ISeq_RotLeft = RotLeft(ipCount)
End Function

Private Function ISeq_RotRight(Optional ByVal ipCount As Long = 1) As Variant
    Set ISeq_RotRight = RotRight(ipCount)
End Function

Private Function ISeq_HoldsItem(ByRef ipItem As Variant) As Boolean
    ISeq_HoldsItem = HoldsItem(ipItem)
End Function

Private Function ISeq_Contains(ByRef ipItem As Variant) As Boolean
    ISeq_Contains = Contains(ipItem)
End Function

Private Function ISeq_LacksItem(ByRef ipItem As Variant) As Boolean
    ISeq_LacksItem = LacksItem(ipItem)
End Function

Private Function ISeq_HoldsItems() As Boolean
    ISeq_HoldsItems = HoldsItems()
End Function

Private Function ISeq_LacksItems() As Boolean
    ISeq_LacksItems = LacksItems()
End Function

Private Property Get ISeq_TypeName() As String
    ISeq_TypeName = TypeName
End Property

Private Function ISeq_MappedIt(ByRef ipMapper As IMapper) As Variant
    Set ISeq_MappedIt = MappedIt(ipMapper)
End Function

Private Function ISeq_MapIt(ByVal ipMapper As IMapper) As Variant
    Set ISeq_MapIt = MapIt(ipMapper)
End Function

Private Function ISeq_FilterIt(ByVal ipComparer As IComparer) As Variant
    Set ISeq_FilterIt = FilterIt(ipComparer)
End Function

Private Function ISeq_CountIt(ByVal ipComparer As IComparer) As Long
    ISeq_CountIt = CountIt(ipComparer)
End Function

Private Function ISeq_ReduceIt(ByRef ipReducer As IReducer) As Variant
    ISeq_ReduceIt = ReduceIt(ipReducer)
End Function

Private Function ISeq_Push(ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_Push = Push(ipParamarray)
End Function

Private Function ISeq_PushRange(ByRef ipRange As Variant) As Variant
    Set ISeq_PushRange = PushRange(ipRange)
End Function

Private Function ISeq_Pop() As Variant
    ISeq_Pop = Pop()
End Function

Private Function ISeq_PopRange(Optional ByVal ipCount As Long = 1) As Variant
    Set ISeq_PopRange = PopRange(ipCount)
End Function

Private Function ISeq_enQueue(ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_enQueue = enQueue(ipParamarray)
End Function

Private Function ISeq_EnqueueRange(ByRef ipRange As Variant) As Variant
    Set ISeq_EnqueueRange = EnqueueRange(ipRange)
End Function

Private Function ISeq_Dequeue() As Variant
    ISeq_Dequeue = Dequeue()
End Function

Private Function ISeq_DequeueRange(Optional ByVal ipCount As Long = 1) As Variant
    Set ISeq_DequeueRange = DequeueRange(ipCount)
End Function

Private Function ISeq_Sort() As Variant
    Set ISeq_Sort = Sort()
End Function

Private Function ISeq_Sorted() As Variant
    Set ISeq_Sorted = Sorted()
End Function

Private Sub ISeq_Swap(ByRef ipLHSIndex As Long, ByRef ipRHSIndex As Long)
   Swap ipLHSIndex, ipRHSIndex
End Sub

Private Function ISeq_Reverse() As Variant
    Set ISeq_Reverse = Reverse()
End Function

Private Function ISeq_Reversed() As Variant
    Set ISeq_Reversed = Reversed()
End Function

Private Function ISeq_IsUnique() As Boolean
    ISeq_IsUnique = IsUnique()
End Function

Private Function ISeq_IsNotUnique() As Boolean
    ISeq_IsNotUnique = IsNotUnique()
End Function

Private Function ISeq_Dedup() As Variant
    Set ISeq_Dedup = Dedup()
End Function

Private Function ISeq_Deduped() As Variant
    Set ISeq_Deduped = Deduped()
End Function

Private Function ISeq_Freq() As KvpA
    Set ISeq_Freq = Freq()
End Function

Private Function ISeq_SetOf(ByRef ipSet As e_SetoF, ByRef ipRangeItem As ISeq) As ISeq
    Set ISeq_SetOf = SetOf(ipSet, ipRangeItem)
End Function
