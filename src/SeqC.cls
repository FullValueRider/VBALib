VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "SeqC"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_Description = "SeqC is a multipurpose Collection/ArrayList replacement.  It uses a collection to store the items.  Items are access using 1 based indexing. For a Keyed collection, use one of the Kvp classes"
'@PredeclaredId
'@Exposed
'@Folder("Seq")
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C

'@ModuleDescription("SeqC is a multipurpose Collection/ArrayList replacement.  It uses a collection to store the items.  Items are access using 1 based indexing. For a Keyed collection, use one of the Kvp classes")
' SeqC uses the VBA Collection class as a host for the items
' Other versions of SeqC are available (SeqA, SeqC, SeqAL, SeqH, SeqT, SeqL)

' Seq classes do not implement NewEnum because not all classes support such a method.
' Instead the use of the iteritems class is promoted for a superior for each experiece.

Option Explicit

Private Const MY_TYPENAME                       As String = "SeqC"
Private Const FIRST_INDEX                       As Long = 1

Private Type State
    Host                                        As Collection
End Type


Private s                                       As State


' Deb is a Factory method of the PredeclaredId which returns a new instance of SeqC
'=================================================================================
' The input for Deb is a ParamArray.
' The ParamArray is interpreted according to the folowing rules
' If the ParamArray contains no Items
' - A empty SeqCuence (count = 0)
' If the ParamArray has 2 or more items
' - A SeqC of size equal to the ParamArray, items as generated by for each over the ParamArray
' If the ParamArray has a single Item
' - Number: SeqC with specified capacity with each Item being the Value 'Empty'
' - String: A SeqC whose capacity is the length of the string with one character per Item
' - Array: SeqC of items as provided by For Each over the array.  Multidimension arrays are flattened but the position in the original array can be calculated by the user if required.
' - Dictionaries: a SeqC of key/value arrays as generated from for each on the Keys array.
' - Collection: The collection is copied to the Host collection.  There is no refererence link to the original collection (See Bind Property)
' - SeqC: Items as generated by for each on the SeqC
' - mscorlib Arraylist: Items as generated by for each on the arrylist
' - mscorlib Stack: Items as generated by for each on the stack
' - mscorlib Queue: Items as generated by for eac on the queue


'@DefaultMember
Public Function Deb(ParamArray ipParamarray() As Variant) As SeqC
Attribute Deb.VB_UserMemId = 0
    With New SeqC
        Set Deb = .ConstructInstance(VBA.CVar(ipParamarray))
    End With
End Function


Friend Function ConstructInstance(ByRef ipFPA As Variant) As SeqC
    
    Set s.Host = New Collection
    
    ' Check to see if we return a default 'empty' seq
    If ArrayOp.LacksItems(ipFPA) Then
        Set ConstructInstance = Me
        Exit Function
    End If
    
    ' ipParamArray contains one or more items depending on the input type.
    ' if the input contains only a single item we want to use that item
    ' else we want to treat the forwrded paramarray as a single array item
    
    Dim myItem As Variant
    If ArrayOp.HoldsOneItem(ipFPA) Then
        If VBA.IsObject(ipFPA(0)) Then
            Set myItem = ipFPA(0)
        Else
            myItem = ipFPA(0)
        End If
    Else
        myItem = ipFPA
    End If
    
    ' See the Bind method if mutability of an input array required
    
    ' Resolve the items in the forwarded paramarray using the rules for
    ' instantiation as described above.
    Select Case True
    
        Case VBA.IsArray(myItem):               Set ConstructInstance = AddRange(ArrayOp.Linearise(myItem))
        Case GroupInfo.IsContainer(myItem):     Set ConstructInstance = AddRange(myItem)
        Case GroupInfo.IsString(myItem):        Set ConstructInstance = AddRange(myItem)
        Case GroupInfo.IsNumber(myItem):        Set ConstructInstance = ConstructInstanceByCount(VBA.CLng(myItem))
        Case Else:                              Set ConstructInstance = AddItems(myItem)
    End Select
    
End Function


Private Function ConstructInstanceByCount(ByRef ipSize As Long) As SeqC
    
    If ipSize < FIRST_INDEX Then
        Set ConstructInstanceByCount = Me
        Exit Function
    End If
    
    Dim myCount As Long
    For myCount = FIRST_INDEX To ipSize
        s.Host.Add Empty
    Next
    
    Set ConstructInstanceByCount = Me
    
End Function


Public Function Bind(ByRef ipCollection As Collection) As SeqC
    Set s.Host = ipCollection
    Set Bind = Me
End Function


Public Function Clone() As SeqC
    Set Clone = SeqC.Deb(s.Host)
End Function


''@Enumerator
'Public Function NewEnum() As IUnknown
'   Set NewEnum = s.Host.[_NewEnum]
'End Function


Public Function Count(Optional ByRef ipItem As Variant) As Long

    If s.Host.Count < 1 Then
        Count = -1
        Exit Function
    End If
    
     If VBA.IsMissing(ipItem) Then
        Count = s.Host.Count
        Exit Function
    End If
    
    Dim myCount As Long: myCount = 0
    
    Dim myIndex As Long
    For myIndex = FIRST_INDEX To s.Host.Count
        If ComparerHelpers.Equals(s.Host.Item(myIndex), ipItem) Then
            myCount = myCount + 1
        End If
    Next
    
    Count = myCount
    
End Function


Public Function Items() As Variant

    If s.Host.Count < FirstIndex Then
        Items = Array()
        Exit Function
    End If
    
    #If twinbasic Then
        Items = s.Host.Items
    #Else
        Items = Me.ToArray
    #End If
    
End Function


'@Description("Returns a subset of the SeqC")
Public Function Slice _
( _
Optional ByRef ipStart As Long = 1, _
Optional ByRef ipRun As Long = -1, _
Optional ByRef ipStep As Long = 1 _
) As SeqC
Attribute Slice.VB_Description = "Returns a subset of the SeqC"
    
    If s.Host.Count = 0 Then
        Set Slice = SeqC.Deb
        Exit Function
    End If
    
    GuardIndexOutOfBounds ipStart, FIRST_INDEX, s.Host.Count, "SeqC.Slice"
    
    Dim myRun As Long
    myRun = ipRun
    If myRun < FIRST_INDEX Then
        myRun = s.Host.Count - ipStart + 1
    Else
        GuardIndexOutOfBounds myRun + ipStart - 1, FIRST_INDEX, s.Host.Count, "SeqC.Slice"
    End If
   

    Dim myS As SeqC: Set myS = SeqC.Deb
   
    Dim mySeqIndex As Long
    For mySeqIndex = ipStart To ipStart + myRun - 1 Step ipStep
        myS.Add s.Host.Item(mySeqIndex)
    Next

    Set Slice = myS

End Function


'@Description("Returns a shallow copy of the SeqC as an Array.  The Lbound of the array is 1")
Public Function ToArray() As Variant
Attribute ToArray.VB_Description = "Returns a shallow copy of the SeqC as an Array.  The Lbound of the array is 1"

    If s.Host.Count < FIRST_INDEX Then
        ToArray = Array()
        Exit Function
    End If
    
    #If twinbasic Then
        Dim myA As Variant
        myA = s.Host.Items
        ReDim Preserve myA(1 To s.Host.Count)
        ToArray = myA
        
    #Else
    
        Dim myArray As Variant
        ReDim myArray(FIRST_INDEX To s.Host.Count)
        
        Dim myIndex As Long
        For myIndex = FIRST_INDEX To s.Host.Count
    
            If VBA.IsObject(s.Host(myIndex)) Then
                Set myArray(myIndex) = s.Host(myIndex)
            Else
                myArray(myIndex) = s.Host(myIndex)
            End If
        
        Next
        
        ToArray = myArray
        
    #End If

End Function


'@Description("Returns a shallow copy of the SeqC as a VBA collection")
Public Function ToCollection() As Collection
Attribute ToCollection.VB_Description = "Returns a shallow copy of the SeqC as a VBA collection"
    
    Dim myC As Collection
    Set myC = New Collection
    
    If s.Host.Count < FIRST_INDEX Then
        Set ToCollection = myC
        Exit Function
    End If
    
    Dim myItem As Variant
    For Each myItem In s.Host
        myC.Add myItem
    Next
    
    Set ToCollection = myC
    
End Function


'@Description("Returns the LBound of the SeqC or -1 if the SeqC is empty.  Defined as 1 for SeqC")
Public Function FirstIndex() As Long
Attribute FirstIndex.VB_Description = "Returns the LBound of the SeqC or -1 if the SeqC is empty.  Defined as 1 for SeqC"

    If s.Host.Count < FIRST_INDEX Then
        FirstIndex = -1
    Else
        FirstIndex = FIRST_INDEX
    End If
    
End Function


'@Description("Returns the UBound of the SeqC or -1 if the SeqC is empty.  Equivalent to Count.")
Public Function LastIndex() As Long
Attribute LastIndex.VB_Description = "Returns the UBound of the SeqC or -1 if the SeqC is empty.  Equivalent to Count."

    If s.Host.Count < FIRST_INDEX Then
        LastIndex = -1
    Else
        LastIndex = s.Host.Count
    End If
   
End Function


'@Description("Returns the index of the second item in the SeqC or -1  if the SeqC has less than 2 Items")
Public Function FBOIndex() As Long
Attribute FBOIndex.VB_Description = "Returns the index of the second item in the SeqC or -1  if the SeqC has less than 2 Items"

    If s.Host.Count < FIRST_INDEX + 1 Then
        FBOIndex = -1
    Else
        FBOIndex = FIRST_INDEX + 1
    End If
    
End Function


'Description("Returns the index of the second to last item in the SeqC, or -1 if the SeqC has lees than 2 items")
Public Function LBOIndex() As Long

    If s.Host.Count < FIRST_INDEX + 1 Then
        LBOIndex = -1
    Else
        LBOIndex = s.Host.Count - 1
    End If
   
End Function



'@DescriptioN("Returns the item at FirstIndex")
Public Property Get First() As Variant
Attribute First.VB_Description = "Returns the item at FirstIndex"

    If s.Host.Count < FIRST_INDEX Then
        First = Null
        Exit Property
    End If
  
    If VBA.IsObject(s.Host.Item(FIRST_INDEX)) Then
        Set First = s.Host.Item(FIRST_INDEX)
    Else
        First = s.Host.Item(FIRST_INDEX)
    End If
   
End Property


'@DescriptioN("Assigns to the Item at FirstIndex")
Public Property Let First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    ' ToDo: review if the add action is better as an error
    If s.Host.Count < FIRST_INDEX Then
        Me.Add ipItem
        Exit Property
    End If
    
    Me.Item(FIRST_INDEX) = ipItem
   
End Property


'@Description("Assigns to the Item at FirstIndex")
Public Property Set First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    If s.Host.Count < FIRST_INDEX Then
        Me.Add ipItem
        Exit Property
    End If
   
    Set Me.Item(FirstIndex) = ipItem
   
End Property


'@Description("Returns the Item at LastIndex")
Public Property Get Last() As Variant
Attribute Last.VB_Description = "Returns the Item at LastIndex"

    If s.Host.Count < FIRST_INDEX Then
        Last = Null
        Exit Property
    End If
   
    If VBA.IsObject(s.Host.Item(s.Host.Count)) Then
        Set Last = s.Host.Item(s.Host.Count)
    Else
        Last = s.Host.Item(s.Host.Count)
    End If
End Property


'@Description("Assigns to the Item at LastIndex")
Public Property Let Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the Item at LastIndex"

    If s.Host.Count < FIRST_INDEX Then
        s.Host.Add ipItem
        Exit Property
    End If
    
    
    Me.Item(s.Host.Count) = ipItem
   
End Property


'@Description("Assigns to the item at LastIndex")
Public Property Set Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the item at LastIndex"

    If s.Host.Count < FIRST_INDEX Then
        s.Host.Add ipItem
        Exit Property
    End If
  
    Set Me.Item(s.Host.Count) = ipItem
    
End Property


'@Description("Returns the item at FirstIndex")
Public Property Get FBO() As Variant
Attribute FBO.VB_Description = "Returns the item at FirstIndex"

    Dim FBOIndex As Long: FBOIndex = FIRST_INDEX + 1
   
    If s.Host.Count < FBOIndex Then
        FBO = Null
        Exit Property
    End If
   
    If VBA.IsObject(s.Host.Item(FBOIndex)) Then
        Set FBO = s.Host.Item(FBOIndex)
    Else
        FBO = s.Host.Item(FBOIndex)
    End If
   
End Property


'@Description("Assigns to the Item at FirstIndex")
Public Property Let FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at FirstIndex"

    If s.Host.Count < FIRST_INDEX Then
        Err.Raise 17 + vbObjectError, _
            "SeqC.Let_FBO", _
            Fmt.Text("Index {0} not avaiable", FirstIndex + 1)
    ElseIf s.Host.Count = FIRST_INDEX Then
        s.Host.Add ipItem
    Else
        Me.Item(FIRST_INDEX + 1) = ipItem
    End If
   
End Property


'@Description("Assigns to the Item at FirstIndex")
Public Property Set FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at FirstIndex"

    If s.Host.Count <= FIRST_INDEX Then
        Err.Raise 17 + vbObjectError, _
            "SeqC.Let_FBO", _
            Fmt.Text("Index {0} not avaiable", FIRST_INDEX + 1)
    ElseIf s.Host.Count = FIRST_INDEX Then
        s.Host.Add ipItem
    Else
        Set Me.Item(FIRST_INDEX + 1) = ipItem
    End If
   
End Property


'@Description("Returns the Item at LastIndex")
Public Property Get LBO() As Variant
Attribute LBO.VB_Description = "Returns the Item at LastIndex"

    Dim LBOIndex As Long: LBOIndex = s.Host.Count - 1

    If LBOIndex < FIRST_INDEX Then
        LBO = Null
        Exit Property
    End If
    
    If VBA.IsObject(s.Host.Item(LBOIndex)) Then
        Set LBO = s.Host.Item(LBOIndex)
    Else
        LBO = s.Host.Item(LBOIndex)
    End If

   
End Property


'@Description("Assigns to the Item at LastIndex")
Public Property Let LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the Item at LastIndex"

    If s.Host.Count < FIRST_INDEX Then
        Err.Raise 17 + vbObjectError, _
            "SeqC.Let_FBO", _
            Fmt.Text("Index {0} not avaiable", s.Host.Count - 1)
    ElseIf s.Host.Count = FIRST_INDEX Then
        s.Host.Add ipItem, before:=FIRST_INDEX
    Else
        Me.Item(s.Host.Count - 1) = ipItem
    End If
   
End Property


'@Description("Assigns to the item at LastIndex")
Public Property Set LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the item at LastIndex"

    If s.Host.Count < FIRST_INDEX Then
        Err.Raise 17 + vbObjectError, _
            "SeqC.Let_FBO", _
            Fmt.Text("Index {0} not avaiable", s.Host.Count - 1)
    ElseIf s.Host.Count = FIRST_INDEX Then
        s.Host.Add ipItem, before:=FIRST_INDEX
    Else
        Set Me.Item(s.Host.Count - 1) = ipItem
    End If
    
End Property


'@Description("Returns the index of the first Item in the specified range or -1 if not found")
Public Function IndexOf _
( _
ByVal ipItem As Variant, _
Optional ByVal ipStart As Long = 1, _
Optional ByVal ipRun As Long = 0 _
) As Long
Attribute IndexOf.VB_Description = "Returns the index of the first Item in the specified range or -1 if not found"

    IndexOf = -1
    
    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If
    
    If ipStart < FIRST_INDEX Or ipStart > s.Host.Count Then
        Exit Function
    End If
    
    ' ensure that ipstart+iprun only goes to the end of the seq
    Dim myEnd As Long
    If ipRun = 0 Then
        myEnd = s.Host.Count
    Else
        myEnd = ipStart + ipRun - 1
        If myEnd > s.Host.Count Then
            myEnd = s.Host.Count
        End If
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipStart, myEnd)
    Do
        If ComparerHelpers.Equals(myItems.CurItem(0), ipItem) Then
            IndexOf = myItems.CurKey(0)
            Exit Function
        End If
        
    Loop While myItems.MoveNext
    
End Function


'@Description("Returns the index of the last item inthe specified range or -1 if not found")
Public Function LastIndexOf _
( _
ByVal ipItem As Variant, _
Optional ByVal ipStart As Long = 1, _
Optional ByVal ipRun As Long = 0 _
) As Long
Attribute LastIndexOf.VB_Description = "Returns the index of the last item inthe specified range or -1 if not found"
    
    LastIndexOf = -1
    
    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If
    
    If ipStart < FIRST_INDEX Or ipStart > s.Host.Count Then
        Exit Function
    End If
    
    Dim myEnd As Long
    If ipRun = 0 Then
        myEnd = s.Host.Count
    Else
        myEnd = ipStart + ipRun - 1
        If myEnd > s.Host.Count Then
            myEnd = s.Host.Count
        End If
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).FTS(ipStart, myEnd).MoveToEndIndex
    Do
        If ComparerHelpers.Equals(myItems.CurItem(0), ipItem) Then
            LastIndexOf = myItems.CurKey(0)
            Exit Function
        End If
    
    Loop While myItems.MovePrev
    
    LastIndexOf = -1
    
End Function


'@Description("Add a single item.  Returns the index at which the item was added for compatibility with the mscorlib ArrayList.")
Public Function Add(ByRef ipItem As Variant) As Long
Attribute Add.VB_Description = "Add a single item.  Returns the index at which the item was added for compatibility with the mscorlib ArrayList."

    s.Host.Add ipItem
    Add = s.Host.Count
    
End Function


'@Description("Adds one or more items . Return the Me instance")
Public Function AddItems(ParamArray ipParamarray() As Variant) As SeqC
Attribute AddItems.VB_Description = "Adds one or more items . Return the Me instance"

    If ArrayOp.LacksItems(VBA.CVar(ipParamarray)) Then
        Set AddItems = Me
        Exit Function
    End If

    Dim myParamarray As Variant: myParamarray = ipParamarray
    myParamarray = ArrayOp.Splat(myParamarray)

    AddRange myParamarray

    Set AddItems = Me

End Function


'@Description("Add an array, list type, dictionary type, or characters of a string")
Public Function AddRange(ByVal ipRange As Variant) As SeqC
Attribute AddRange.VB_Description = "Add an array, list type, dictionary type, or characters of a string"
        
    Set AddRange = Me
    
     If GroupInfo.IsNotContainer(ipRange) And GroupInfo.IsNotString(ipRange) Then
        Err.Raise 17 + vbObjectError, _
            "VBALib.SeqC.AddRange", _
            Fmt.Text("Expecting a container type.  Got {0}", VBA.TypeName(ipRange))
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(ipRange) '.movetoendindex
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        If GroupInfo.IsDictionary(ipRange) Then
            Me.Add Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            Me.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext

End Function


Public Property Get Item(ByRef ipIndex As Long) As Variant

    Item = Null
    
    If ipIndex < FIRST_INDEX Or ipIndex > s.Host.Count Then
        Exit Property
    End If
   
    Dim myItem As Variant: myItem = Array(s.Host.Item(ipIndex))
    
    If VBA.IsObject(myItem(0)) Then
        Set Item = myItem(0)
    Else
        Item = myItem(0)
    End If
    
End Property


Public Property Let Item(ByRef ipIndex As Long, ByVal ipItem As Variant)
    
    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.Host.Count, "SeqC.Let_Item"
    
    s.Host.Add ipItem, after:=ipIndex
    s.Host.Remove ipIndex
    
End Property


Public Property Set Item(ByRef ipIndex As Long, ByVal ipItem As Variant)

    GuardIndexOutOfBounds ipIndex, FIRST_INDEX, s.Host.Count, "SeqC.Set_Item"
  
    s.Host.Add ipItem, after:=ipIndex
    s.Host.Remove ipIndex
   
End Property


'@Description("Inserts one or more items starting at ipIndex. Returns the index of the inserted item")
Public Function InsertAt(ByRef ipIndex As Long, ByRef ipItem As Variant) As Long
Attribute InsertAt.VB_Description = "Inserts one or more items starting at ipIndex. Returns the index of the inserted item"

    If ipIndex < FIRST_INDEX Or ipIndex > s.Host.Count Then
        InsertAt = -1
        Exit Function
    End If

    s.Host.Add ipItem, before:=ipIndex
    
    InsertAt = ipIndex

End Function


'@Description("Inserts one or more items starting at ipIndex")
Public Function InsertAtItems(ByRef ipIndex As Long, ParamArray ipParamarray() As Variant) As SeqC
Attribute InsertAtItems.VB_Description = "Inserts one or more items starting at ipIndex"
    
    Dim myParamarray As Variant: myParamarray = ipParamarray
    myParamarray = ArrayOp.Splat(myParamarray)
    
    Set InsertAtItems = InsertAtRange(ipIndex, myParamarray)
    
End Function


'@Description("For strings inserts individual characters starting at ipIndex.  For Containers adds each item in the Container")
Public Function InsertAtRange(ByRef ipIndex As Long, ByRef ipRange As Variant) As SeqC
Attribute InsertAtRange.VB_Description = "For strings inserts individual characters starting at ipIndex.  For Containers adds each item in the Container"

    If ipIndex < FIRST_INDEX Or ipIndex > s.Host.Count Then
        Set InsertAtRange = Me
        Exit Function
    End If
    
    GuardInvalidRangeItem ipRange, "SeqC.InsertAtRange"
    
    Dim myItems As IterItems: Set myItems = IterItems(ipRange).MoveToEndIndex
    
    If myItems.LacksItems Then
        Set InsertAtRange = Me
        Exit Function
    End If
    
    Do
        If GroupInfo.IsDictionary(ipRange) Then
            InsertAt ipIndex, Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            InsertAt ipIndex, myItems.CurItem(0)
        End If
   
    Loop While myItems.MovePrev
    
    Set InsertAtRange = Me
    
End Function


'@Description("Removes the first encountered item from the Seq")
Public Function Remove(ByRef ipItem As Variant) As Long
Attribute Remove.VB_Description = "Removes the first encountered item from the Seq"

    If s.Host.Count < FIRST_INDEX Then
        Remove = -1
        Exit Function
    End If
    
    Dim myIndex As Long: myIndex = IndexOf(ipItem)
    
    s.Host.Remove myIndex

    Remove = myIndex
    
End Function

'@Description "Removes the first encountered item from the SeqC"
Public Function RemoveItems(ParamArray ipParamarray() As Variant) As SeqC
Attribute RemoveItems.VB_Description = "Removes the first encountered item from the SeqC"

    Dim myParamarray As Variant: myParamarray = ipParamarray
    myParamarray = ArrayOp.Splat(myParamarray)
    
    Set RemoveItems = RemoveRange(myParamarray)
    
    Set RemoveItems = Me
    
End Function


'@Description("Remove items in the specified range of Indexes")
Public Function RemoveRange(ByRef ipRange As Variant) As SeqC
Attribute RemoveRange.VB_Description = "Remove items in the specified range of Indexes"
  
    Set RemoveRange = Me
    
    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If
   
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        s.Host.Remove IndexOf(myItems.CurItem(0))
    Loop While myItems.MoveNext
 
End Function

'@Description("If the ParamArray is empty, removes all items otherwise removes all ocurrences of  each item in the paramarray")
Public Function RemoveAll(ParamArray ipParamarray() As Variant) As SeqC
Attribute RemoveAll.VB_Description = "If the ParamArray is empty, removes all items otherwise removes all ocurrences of  each item in the paramarray"

    Set RemoveAll = Me
    
    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If
    
    If ArrayOp.LacksItems(VBA.CVar(ipParamarray)) Then
  
        #If twinbasic Then
            s.Host.Clear
        #Else
            RemoveAllItems
        #End If
        
        Exit Function
        
    End If
        
    Dim myItem As Variant
    For Each myItem In ipParamarray
        RemoveAllSingleItem myItem
    Next
    
End Function

'@("Removes all Items from the SeqC")
Public Function Clear() As SeqC
    Set Clear = RemoveAll
End Function


'@("Removes all Items by replacing the Host collection with a new collection")
Public Function Reset() As SeqC
    Set s.Host = New Collection
    Set Reset = Me
End Function


'@Description("Removes the first encountered item from the Seq")
Public Function RemoveAt(ByRef ipIndex As Long) As Long
Attribute RemoveAt.VB_Description = "Removes the first encountered item from the Seq"

    RemoveAt = -1
    
    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If
    
    If ipIndex < FIRST_INDEX Or ipIndex > s.Host.Count Then
        Exit Function
    End If
    
    s.Host.Remove ipIndex
        
    RemoveAt = ipIndex
    
End Function





'@Description("Removes the items at the Indexes.  Indexes are sorted before use.")
Public Function RemoveIndexes(ParamArray ipParamarray() As Variant) As SeqC
Attribute RemoveIndexes.VB_Description = "Removes the items at the Indexes.  Indexes are sorted before use."

    Dim myParamarray As Variant: myParamarray = ipParamarray
    myParamarray = ArrayOp.Splat(myParamarray)
    
    Set RemoveIndexes = RemoveIndexesRange(myParamarray)
    
    Set RemoveIndexes = Me
    
End Function





'@Description("Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use")
Public Function RemoveIndexesRange(ByRef ipRange As Variant) As SeqC
Attribute RemoveIndexesRange.VB_Description = "Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use"
  
    Set RemoveIndexesRange = Me
    
    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If
    
    ' We need to utilise Iteritems twice
    ' because we need to sort the values in ipRange
    
    Dim myS As SeqA: Set myS = SeqA(ipRange).Sorted
    
    If myS.LacksItems Then
        Exit Function
    End If
    
    '@Ignore AssignmentNotUsed
    Dim myItems As IterItems: Set myItems = IterItems(myS).MoveToEndIndex
    Do
        s.Host.Remove myItems.CurItem(0)
    Loop While myItems.MovePrev
    
    Set RemoveIndexesRange = Me
        
End Function


'@Description("Adds Count of Item to the SeqC")
Public Function Fill(ByRef ipItem As Variant, Optional ByVal ipCount As Long = 1) As SeqC
Attribute Fill.VB_Description = "Adds Count of Item to the SeqC"

    Set Fill = Me

    If ipCount < FIRST_INDEX Then
        Exit Function
    End If
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        s.Host.Add ipItem
    Next
    
End Function


'@Description("Returns the first N items of the SeqC, Default 1")
Public Function Head(Optional ByVal ipSplitAfter As Long = 1) As SeqC
Attribute Head.VB_Description = "Returns the first N items of the SeqC, Default 1"
    
    Set Head = SeqC.Deb
    
    If s.Host.Count <= FIRST_INDEX Then
        Exit Function
    End If

    If ipSplitAfter < FIRST_INDEX Then
        Exit Function
    End If
    
    If ipSplitAfter >= s.Host.Count Then
        Set Head = Me.Clone
        Exit Function
    End If
    
    Set Head = Me.Slice(FIRST_INDEX, ipSplitAfter)

End Function


'@Description("Returns the Items after SplitAfter, Default is Index 2")
Public Function Tail(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As SeqC
Attribute Tail.VB_Description = "Returns the Items after SplitAfter, Default is Index 2"

    Set Tail = SeqC.Deb
    
    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If
    
    If ipSplitAfter >= s.Host.Count Then
        Exit Function
    End If
    
    If ipSplitAfter < FIRST_INDEX Then
        Set Tail = Me.Clone
        Exit Function
    End If
    
    Set Tail = Me.Slice(ipSplitAfter + 1)

End Function


'@Description("True if the Item is found in the SeqC")
Public Function HoldsItem(ByRef ipItem As Variant) As Boolean
Attribute HoldsItem.VB_Description = "True if the Item is found in the SeqC"
    
    HoldsItem = False

    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If

    Dim myItems As IterItems: Set myItems = IterItems(s.Host)
    Do
        If ComparerHelpers.Equals(myItems.CurItem(0), ipItem) Then
            HoldsItem = True
            Exit Function
        End If
    Loop While myItems.MoveNext

End Function


'@Description("ArrayList terminology for HoldsItem")
Public Function Contains(ByRef ipItem As Variant) As Boolean
Attribute Contains.VB_Description = "ArrayList terminology for HoldsItem"
    Contains = Me.HoldsItem(ipItem)
End Function


'@Description("True if the Item is not found in the SeqC")
Public Function LacksItem(ByRef ipItem As Variant) As Boolean
Attribute LacksItem.VB_Description = "True if the Item is not found in the SeqC"
    LacksItem = Not Me.HoldsItem(ipItem)
End Function


'@Description("Alternative to Count > 0")
Public Function HoldsItems() As Boolean
Attribute HoldsItems.VB_Description = "Alternative to Count > 0"
    HoldsItems = s.Host.Count >= FIRST_INDEX
End Function


'@Description("Alternative to Count=0")
Public Function LacksItems() As Boolean
Attribute LacksItems.VB_Description = "Alternative to Count=0"
    LacksItems = s.Host.Count < FIRST_INDEX
End Function


Public Property Get myTypename() As String
    myTypename = MY_TYPENAME
End Property



'@Description("Mutates the Seq in place by applying the function in IMapper to each item")
Public Function MappedIt(ByRef ipMapper As IMapper) As SeqC
Attribute MappedIt.VB_Description = "Mutates the Seq in place by applying the function in IMapper to each item"
    'Mapped it works by reference but we allow a function return to enable fluid use of Mappedit
    
    Set MappedIt = Me
    
    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host)
    Do
   
        Dim myItem As Variant: myItem = ipMapper.ExecMapper(myItems.CurItem(0))
        
        If VBA.IsObject(myItem(0)) Then
            Set Me.Item(myItems.CurKey(0)) = myItem(0)
        Else
            Me.Item(myItems.CurKey(0)) = myItem(0)
        End If
        
    Loop While myItems.MoveNext
    
End Function


'@Description("Returns a new Seq where each item in the Host has been mutated by the function provided by IMapper")
Public Function MapIt(ByRef ipMapper As IMapper) As SeqC
Attribute MapIt.VB_Description = "Returns a new Seq where each item in the Host has been mutated by the function provided by IMapper"

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set MapIt = myS
    
    If s.Host.Count < FirstIndex Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host)
    Do
        myS.Add ipMapper.ExecMapper(myItems.CurItem(0))(0)
    Loop While myItems.MoveNext
    
    Set MapIt = myS

End Function




'@Description("Returns a new SeqC comprised of item where IComparer is true")
Public Function FilterIt(ByVal ipComparer As IComparer) As SeqC
Attribute FilterIt.VB_Description = "Returns a new SeqC comprised of item where IComparer is true"

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set FilterIt = myS
    
    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host)
    Do
    
        If ipComparer.ExecCmp(myItems.CurItem(0)) Then
            myS.Add myItems.CurItem(0)
        End If
    
    Loop While myItems.MoveNext
    
      Set FilterIt = myS

End Function


'@Description("Returns a count where the function provided by IComparer is true")
Public Function CountIt(ByVal ipComparer As IComparer) As Long
Attribute CountIt.VB_Description = "Returns a count where the function provided by IComparer is true"

    If s.Host.Count < FIRST_INDEX Then
        CountIt = -1
        Exit Function
    End If
   
    Dim myCount As Long: myCount = 0
   
    Dim myItems As IterItems: Set myItems = IterItems(s.Host)
    Do
    
        If ipComparer.ExecCmp(myItems.CurItem(0)) Then
            myCount = myCount + 1
        End If
        
    Loop While myItems.MoveNext
   
    CountIt = myCount
    
End Function


'@Description("Returns a single value based on the function applied by the IReducer").
Public Function ReduceIt(ByRef ipReducer As IReducer) As Variant

    If s.Host.Count < FIRST_INDEX Then
        ReduceIt = Null
        Exit Function
    End If
    
    Dim myItem As Variant: myItem = Array(ipReducer.ExecReduction(Me))
   
    If VBA.IsObject(myItem(0)) Then
        Set ReduceIt = myItem(0)
    Else
        ReduceIt = myItem(0)
    End If
   
End Function


Public Property Get TypeName() As String
    TypeName = MY_TYPENAME
End Property


Public Function Push(ParamArray ipParamarray() As Variant) As SeqC

    Dim myParamarray As Variant: myParamarray = ipParamarray
    myParamarray = ArrayOp.Splat(myParamarray)
    
    Set Push = AddRange(myParamarray)
    
End Function


Public Function PushRange(ByRef ipRange As Variant) As SeqC
    Set PushRange = AddRange(ipRange)
End Function


Public Function Pop() As Variant

    If s.Host.Count < FIRST_INDEX Then
        Pop = Null
        Exit Function
    End If

    Dim myItem As Variant: myItem = Array(s.Host.Item(s.Host.Count))
    
    If VBA.IsObject(myItem(0)) Then
        Set Pop = myItem(0)
    Else
        Pop = myItem(0)
    End If
    
    s.Host.Remove s.Host.Count
    
End Function


Public Function PopRange(Optional ByVal ipCount As Long = 1) As SeqC

    Set PopRange = SeqC.Deb
    
    If ipCount < 0 Then
        Exit Function
    End If
    
    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If

    
    If ipCount > s.Host.Count Then
        Set PopRange = Me.Reverse
        Me.RemoveAll
        Exit Function
    End If
    
    Dim myS As SeqC: Set myS = SeqC.Deb
    
    Dim myIndex As Long
    For myIndex = s.Host.Count To s.Host.Count - ipCount + 1 Step -1
        myS.Add s.Host.Item(myIndex)
        s.Host.Remove myIndex
    Next
    
    Set PopRange = myS
    
End Function


Public Function enQueue(ParamArray ipParamarray() As Variant) As SeqC

    Dim myParamarray As Variant: myParamarray = ipParamarray
    myParamarray = ArrayOp.Splat(myParamarray)
    
    Set enQueue = AddRange(myParamarray)
    
End Function


Public Function EnqueueRange(ByRef ipRange As Variant) As SeqC
    Set EnqueueRange = AddRange(ipRange)
End Function


Public Function Dequeue() As Variant
    
    If s.Host.Count < FIRST_INDEX Then
        Dequeue = Null
        Exit Function
    End If
    
    Dim myItem As Variant
    myItem = Array(s.Host.Item(FIRST_INDEX))
    
    If VBA.IsObject(myItem(0)) Then
        Set Dequeue = myItem(0)
    Else
        Dequeue = myItem(0)
    End If
    
    s.Host.Remove FIRST_INDEX
    
End Function


Public Function DequeueRange(Optional ByVal ipCount As Long = 1) As SeqC

    Set DequeueRange = SeqC.Deb
    
    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If
    
    If ipCount < 1 Then
        Exit Function
    End If
    
    If ipCount > s.Host.Count Then
        Set DequeueRange = Me.Clone
        Me.RemoveAll
        Exit Function
    End If
    
    Dim myS As SeqC: Set myS = SeqC.Deb
    
    Dim myIndex As Long
    For myIndex = 1 To ipCount
        myS.Add Me.Dequeue
    Next
    
    Set DequeueRange = myS
    
End Function


'@Description("Returns a new seq with the items in ' Ascending' order")
Public Function Sort() As SeqC
Attribute Sort.VB_Description = "Returns a new seq with the items in ' Ascending' order"

    Dim myS As SeqC: Set myS = Me.Clone
    
    If s.Host.Count < FIRST_INDEX Then
        Set Sort = Me
        Exit Function
    End If
        
    Sorters.ShakerSortByItem myS
    Set Sort = myS
    
End Function


'
'@Description("Sorts the seq in place in 'Ascending' order ")
Public Function Sorted() As SeqC
Attribute Sorted.VB_Description = "Sorts the seq in place in 'Ascending' order "
    
    If s.Host.Count < FIRST_INDEX Then
        Set Sorted = Me
        Exit Function
    End If
        
    Sorters.ShakerSortByItem Me
    Set Sorted = Me
    
End Function


'@Description("Swaps the Items at the specified indexes")
Public Sub Swap(ByRef ipLHSIndex As Long, ByRef ipRHSIndex As Long)
Attribute Swap.VB_Description = "Swaps the Items at the specified indexes"

    Dim myTemp As Variant
    
    If VBA.IsObject(Item(ipLHSIndex)) Then
        Set myTemp = Item(ipLHSIndex)
    Else
        myTemp = Item(ipLHSIndex)
    End If
    
    If VBA.IsObject(Item(ipRHSIndex)) Then
        Set Item(ipLHSIndex) = Item(ipRHSIndex)
    Else
        Item(ipLHSIndex) = Item(ipRHSIndex)
    End If
    
    If VBA.IsObject(myTemp) Then
        Set Item(ipRHSIndex) = myTemp
    Else
        Item(ipRHSIndex) = myTemp
    End If

End Sub


Public Function Reverse() As SeqC

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set Reverse = myS
    
    If s.Host.Count < FirstIndex Then
        Exit Function
    End If

    Dim myIndex As Long
    For myIndex = s.Host.Count To FIRST_INDEX Step -1
        myS.Add s.Host(myIndex)
    Next
     
    Set Reverse = myS

End Function


Public Function Reversed() As SeqC
    
    If s.Host.Count < FIRST_INDEX + 1 Then
        Set Reversed = Me
        Exit Function
    End If
     
    Dim myFirstIndex As Long: myFirstIndex = FIRST_INDEX
    Dim myLastIndex As Long: myLastIndex = s.Host.Count
    
    Do
    
        Me.Swap myFirstIndex, myLastIndex
        myFirstIndex = myFirstIndex + 1
        myLastIndex = myLastIndex - 1
    
    Loop Until myFirstIndex >= myLastIndex

    Set Reversed = Me

End Function


Public Function IsUnique() As Boolean

    If LacksItems Then
        IsUnique = False
        Exit Function
    End If
    
    Dim myH As cHashC: Set myH = New cHashC
    
    Dim myIndex As Long
    For myIndex = 1 To s.Host.Count
        If myH.Exists(s.Host.Item(myIndex)) Then
            IsUnique = False
            Exit Function
        Else
            myH.Add s.Host(myIndex)
        End If
    Next

    IsUnique = True

End Function


Public Function IsNotUnique() As Boolean
    IsNotUnique = Not IsUnique
End Function


'@Description("Returns the a new seq with the unique subset of the host Seq")
Public Function Dedup() As SeqC
Attribute Dedup.VB_Description = "Returns the a new seq with the unique subset of the host Seq"

    
    Dim myS As SeqC: Set myS = SeqC.Deb
    
        If s.Host.Count < FIRST_INDEX Then
        Set Dedup = myS
        Exit Function
    End If

    
    Select Case s.Host.Count
    
        Case Is < FIRST_INDEX:              Set Dedup = myS
            
        Case FIRST_INDEX:                   Set Dedup = Me.Clone
        
        Case Else

            Dim myItem As Variant
            For Each myItem In s.Host
                If myS.LacksItem(myItem) Then
                    myS.Add myItem
                End If
            Next
    
            Set Dedup = myS
            
    End Select
    
End Function


'@Description("Removes duplicate items from the seq")
Public Function Deduped() As SeqC
Attribute Deduped.VB_Description = "Removes duplicate items from the seq"

    If LacksItems Then
        Set Deduped = Me
        Exit Function
    End If
    
    Dim myH As cHashC: Set myH = New cHashC
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host).MoveToEndIndex
    Do
        If myH.Exists(myItems.CurItem(0)) Then
            s.Host.Remove myItems.CurKey(0)
        Else
            myH.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MovePrev
    
    Set Deduped = Me
End Function


Public Function Freq() As KvpA

    Dim myK As KvpA: Set myK = KvpA.Deb
    Set Freq = myK
    
    If s.Host.Count < FIRST_INDEX Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host)
    Do
    
        If myK.LacksKey(myItems.CurItem(0)) Then
            myK.Add myItems.CurItem(0), 1
        Else
            myK.Item(myItems.CurItem(0)) = myK.Item(myItems.CurItem(0)) + 1
        End If
        
    Loop While myItems.MoveNext
    
     Set Freq = myK
    
End Function


Public Function SetOf(ByRef ipSet As e_SetoF, ByRef ipRangeItem As SeqC) As SeqC

    Select Case ipSet

        Case e_SetoF.m_Common:           Set SetOf = SetOfCommon(ipRangeItem)
        Case e_SetoF.m_HostOnly:         Set SetOf = SetOfHostOnly(ipRangeItem)
        Case e_SetoF.m_ParamOnly:        Set SetOf = SetOfParamOnly(ipRangeItem)
        Case e_SetoF.m_NotCommon:        Set SetOf = SetOfNotCommon(ipRangeItem)
        Case e_SetoF.m_Unique:           Set SetOf = SetofUnique(ipRangeItem)
        Case Else
            Err.Raise 17 + vbObjectError, _
            "VBALib.SeqC.SetOf", _
            Fmt.Text("Invalid e_set member. Expecting {0} to {1}. Got {2}", e_SetoF.m_First, e_SetoF.m_Last, ipSet)
                
    End Select

End Function


'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' Private methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
Private Function SetOfCommon(ByRef ipSeq As SeqC) As SeqC

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set SetOfCommon = myS
    
    If Me.LacksItems Or ipSeq.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(ipSeq)
    Do
    
        Dim myItem As Variant: myItem = Array(myItems.CurItem(0))
        
        If Me.HoldsItem(myItem(0)) Then
            myS.Add myItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetOfCommon = myS

End Function


Private Function SetOfHostOnly(ByRef ipSeq As SeqC) As SeqC

    Dim myS As SeqC: Set myS = Me.Dedup
    Set SetOfHostOnly = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    If ipSeq.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(ipSeq)
    Do
    
        If myS.HoldsItem(myItems.CurItem(0)) Then
            myS.Remove myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetOfHostOnly = myS
    
End Function


Private Function SetOfParamOnly(ByRef ipSeq As SeqC) As SeqC
 
    Dim myS As SeqC: Set myS = SeqC.Deb
    Set SetOfParamOnly = myS
    
    If ipSeq.LacksItems Then
        Exit Function
    End If
    
    Set myS = ipSeq.Dedup
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host)
    Do
    
        If myS.HoldsItem(myItems.CurItem(0)) Then
            myS.Remove myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetOfParamOnly = myS

End Function


Private Function SetOfNotCommon(ByRef ipSeq As SeqC) As SeqC

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set SetOfNotCommon = myS
    
    If LacksItems And ipSeq.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host)
    Do
    
        If ipSeq.LacksItem(myItems.CurItem(0)) Then
            If myS.LacksItem(myItems.CurItem(0)) Then
                myS.Add myItems.CurItem(0)
            End If
        End If
        
    Loop While myItems.MoveNext
    
    '@Ignore AssignmentNotUsed
    Set myItems = IterItems(ipSeq)
    Do
    
        If Me.LacksItem(myItems.CurItem(0)) Then
            If myS.LacksItem(myItems.CurItem(0)) Then
                myS.Add myItems.CurItem(0)
            End If
        End If
        
    Loop While myItems.MoveNext
    
    Set SetOfNotCommon = myS
    
End Function


Private Function SetofUnique(ByRef ipSeq As SeqC) As SeqC

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set SetofUnique = myS
    
    If Me.LacksItems And ipSeq.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    Dim myItems As IterItems: Set myItems = IterItems(ipSeq)
    Do
    
        If myS.LacksItem(myItems.CurItem(0)) Then
            myS.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetofUnique = myS
    
End Function

Private Sub RemoveAllItems()

    Dim myIndex As Long
    For myIndex = s.Host.Count To 1 Step -1
        s.Host.Remove myIndex
    Next
    
End Sub


Private Sub RemoveAllSingleItem(ByRef ipItem As Variant)

    Dim myItems As IterItems: Set myItems = IterItems(s.Host).MoveToEndIndex
    Do
        If ComparerHelpers.Equals(myItems.CurItem(0), ipItem) Then
            s.Host.Remove myItems.CurKey(0)
        End If
    Loop While myItems.MovePrev
    
End Sub
