VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "SeqC"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_Description = "SeqC is a Collection/ArrayList replacement.  Items are stored in a Collection.  Indexing is 1 based. Order of addition is preserved. Keys are not supported (see Kvp classes)"
'@PredeclaredId
'@Exposed
'@Folder("Seq")
'@ModuleDescription("SeqC is a Collection/ArrayList replacement.  Items are stored in a Collection.  Indexing is 1 based. Order of addition is preserved. Keys are not supported (see Kvp classes)")
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' Items are accessed using 1 based indexing
' Not enumerable via NewEnum (See Iteritems)
' Keys are not suported (see Kvp classes)
' Preserves order of addition.
' Insertion at a defined position is supported
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
Option Explicit
' constants common to all seq classes

Implements ISeq
Private Const MY_TYPENAME                       As String = "SeqC"

Private Type State
    Host                                        As Collection
End Type

Private s                                       As State


Private Type Properties
    FirstIndex                                  As Long
End Type

Private p                                       As Properties
' Deb is a Factory method of the PredeclaredId which returns a new instance of SeqC
'=================================================================================
' The input for Deb is a ParamArray.
' The ParamArray is interpreted according to the folowing rules
' If the ParamArray contains no Items
' - A empty Sequence (count = 0)
' If the ParamArray has 2 or more items
' - A SeqC of size equal to the ParamArray, items as generated by for each over the ParamArray
' If the ParamArray has a single Item
' - Number: Ignored as it is not necessary to set the size of the underlying collection
' - String: A Seq whose capacity is the length of the string with one character per Item
' - Array: Seq of items as provided by For Each over the array.  Multidimension arrays are flattened but the position in the original array can be calculated by the user if required.
' - Dictionaries: a Seq of key/value arrays as generated from for each on the Keys array.
' - Collection: The collection is copied to the Host collection.  There is no refererence link to the original collection (See Bind Property)
' - SeqC: Items as generated by for each on the SeqC
' - mscorlib Arraylist: Items as generated by for each on the arrylist
' - mscorlib Stack: Items as generated by for each on the stack
' - mscorlib Queue: Items as generated by for eac on the queue

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'Setup and reinitialisation methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

'@DefaultMember
Public Function Deb(ParamArray ipParamarray() As Variant) As SeqC
Attribute Deb.VB_UserMemId = 0
    With New SeqC
        Set Deb = .ConstructInstance(VBA.CVar(ipParamarray))
    End With
End Function

Friend Function ConstructInstance(ByRef ipFPA As Variant) As SeqC
    
    ' count is obtained from s.Host
    Set s.Host = New Collection
    p.FirstIndex = FIRST_INDEX
    ' Check to see if we return a default 'empty' seq
    If ArrayOp.LacksItems(ipFPA) Then
        Set ConstructInstance = Me
        Exit Function
    End If
    
    ' ipParamArray contains one or more items depending on the input type.
    ' if the input contains only a single item we want to use that item
    ' else we want to treat the forwrded paramarray as a single array item
    
    Dim myItem As Variant
    If ArrayOp.HoldsOneItem(ipFPA) Then
        If VBA.IsObject(ipFPA(0)) Then
            Set myItem = ipFPA(0)
        Else
            myItem = ipFPA(0)
        End If
    Else
        myItem = ipFPA
    End If
    
    ' See the Bind method if mutability of an input collection is required
    
    ' Resolve the items in the forwarded paramarray using the rules
    ' described above.
    Select Case True
    
        Case VBA.IsArray(myItem):               Set ConstructInstance = AddRange(ArrayOp.Linearise(myItem))
        Case GroupInfo.IsContainer(myItem):     Set ConstructInstance = AddRange(myItem)
        Case GroupInfo.IsString(myItem):        Set ConstructInstance = AddRange(myItem)
        Case Else:                              Set ConstructInstance = AddItems(myItem)
    End Select
    
End Function

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Core methods - essential for making the class work and status of the object
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

'@Description("Add a single item.  Returns the index at which the item was added for compatibility with the mscorlib ArrayList.")
Public Function Add(ByVal ipItem As Variant) As Long
Attribute Add.VB_Description = "Add a single item.  Returns the index at which the item was added for compatibility with the mscorlib ArrayList."

    s.Host.Add ipItem
    Add = s.Host.Count
    
End Function


'@Description("Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer")
Public Function Count(Optional ByRef ipItem As Variant) As Long
Attribute Count.VB_Description = "Counts number of host items equal to ipItem.  For other condition use CountIt with the appropriate comparer"

    Count = LACKS_ITEMS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
     If VBA.IsMissing(ipItem) Then
        Count = s.Host.Count
        Exit Function
    End If
    
    Dim myCount As Long: myCount = 0
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
        If Comparers.EQ(s.Host.Item(myIndex), ipItem) Then
            myCount = myCount + 1
        End If
    Next
    
    Count = myCount
    
End Function


'@Description("Inserts one or more items starting at ipIndex. Returns the index of the inserted item")
Public Function InsertAt(ByRef ipIndex As Long, ByRef ipItem As Variant) As Long
Attribute InsertAt.VB_Description = "Inserts one or more items starting at ipIndex. Returns the index of the inserted item"

    InsertAt = INDEX_OUT_OF_BOUNDS

    If Guard.IndexOutOfBounds(ipIndex, Me, "InsertAt", Guard.REPORT_BACK) Then
        Exit Function
    End If

    s.Host.Add ipItem, before:=ipIndex
    
    InsertAt = ipIndex

End Function

Public Property Get Item(ByVal ipIndex As Long) As Variant

    Item = Null
    
    If Guard.IndexOutOfBounds(ipIndex, Me, "Get Item", Guard.REPORT_BACK) Then
        Exit Property
    End If
   
    Dim myItem As Variant: myItem = Array(s.Host.Item(ipIndex))
    
    If VBA.IsObject(myItem(0)) Then
        Set Item = myItem(0)
    Else
        Item = myItem(0)
    End If
    
End Property


Public Property Let Item(ByVal ipIndex As Long, ByVal ipItem As Variant)
    
    Guard.IndexOutOfBounds ipIndex, Me, "Let_Item"
    
    s.Host.Add ipItem, after:=ipIndex
    s.Host.Remove ipIndex
    
End Property


Public Property Set Item(ByVal ipIndex As Long, ByVal ipItem As Variant)

    Guard.IndexOutOfBounds ipIndex, Me, "SeqC.Set_Item"
  
    s.Host.Add ipItem, after:=ipIndex
    s.Host.Remove ipIndex
   
End Property

'@Description("Removes the first encountered item from the Seq")
Public Function Remove(ByRef ipItem As Variant) As Long
Attribute Remove.VB_Description = "Removes the first encountered item from the Seq"

    Remove = NOT_FOUND

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long: myIndex = IndexOf(ipItem)
    
    If NotFound(myIndex) Then
        Exit Function
    End If

    s.Host.Remove myIndex

    Remove = myIndex
    
End Function


'@Description("Removes the item at the specified index")
Public Function RemoveAt(ByRef ipIndex As Long) As Long
Attribute RemoveAt.VB_Description = "Removes the item at the specified index"

    RemoveAt = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If Guard.IndexOutOfBounds(ipIndex, Me, "RemoveAt", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    s.Host.Remove ipIndex
        
    RemoveAt = ipIndex
    
End Function


'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Sugar methods' Add to the flexibility of the seq class using the above methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

'@Description("Allows an external to be substituted for the internal items collection")
Public Function Bind(ByRef ipCollection As Collection) As SeqC
Attribute Bind.VB_Description = "Allows an external to be substituted for the internal items collection"
    Set s.Host = ipCollection
    Set Bind = Me
End Function

'@Description("Makes a shallow copy of the seq")
Public Function Clone() As SeqC
Attribute Clone.VB_Description = "Makes a shallow copy of the seq"

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set Clone = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Set Clone = SeqC(s.Host)
    
End Function

'@Description("Returns the Items in the seq as an Array() of variants")
Public Function Items() As Variant
Attribute Items.VB_Description = "Returns the Items in the seq as an Array() of variants"

    Items = Array()

    If Me.LacksItems Then
        Exit Function
    End If
    
    Items = Me.ToArray
    
End Function

'@Description("Returns a string representation of the Items")
Public Function Join(Optional ByRef ipSeparator As String = Chars.twComma) As String
Attribute Join.VB_Description = "Returns a string representation of the Items"
    Join = Strs.Inner(Fmt.ItemSeparator(ipSeparator).Text("{0}", Me))
End Function

'@Description("Returns a subset of the SeqC")
Public Function Slice _
( _
Optional ByRef ipStart As Long = FIRST_INDEX, _
Optional ByRef ipRun As Long = WHOLE_SEQ, _
Optional ByRef ipStep As Long = DEFAULT_STEP _
) As SeqC
Attribute Slice.VB_Description = "Returns a subset of the SeqC"
    
    ' ToDo: Should all Seq return a SeqA for SLice?
    Set Slice = SeqC.Deb

    If Me.LacksItems Then
        Exit Function
    End If
    
    Guard.IndexOutOfBounds ipStart, Me, "Slice"
    
    Dim myEnd As Long
    If ipRun < Me.FirstIndex Then
        myEnd = Me.LastIndex
    Else
        myEnd = ipStart + ipRun - 1
        If myEnd > Me.LastIndex Then
            myEnd = Me.LastIndex
        End If
    End If

   
    Dim myS As SeqC: Set myS = SeqC.Deb
   
    Dim mySeqIndex As Long
    For mySeqIndex = ipStart To myEnd Step ipStep
        myS.Add s.Host.Item(mySeqIndex)
    Next

    Set Slice = myS

End Function


'@Description("Returns a shallow copy of the SeqC as an Array.  The Lbound of the array is 1")
Public Function ToArray() As Variant
Attribute ToArray.VB_Description = "Returns a shallow copy of the SeqC as an Array.  The Lbound of the array is 1"

    ToArray = Array()

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myS As SeqA
    #If twinbasic Then
    
        Set myS = SeqA(s.Host.Items)
        
    #Else
    
        Set myS = SeqA(Me.LastIndex)
        
        Dim myItem As Variant
        For Each myItem In s.Host
            myS.Add myItem
        Next
             
    #End If
    
    ToArray = myS.ToArray

End Function


'@Description("Returns a shallow copy of the SeqC as a VBA collection")
Public Function ToCollection() As Collection
Attribute ToCollection.VB_Description = "Returns a shallow copy of the SeqC as a VBA collection"
    
    Dim myC As Collection: Set myC = New Collection
    Set ToCollection = myC
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItem As Variant
    For Each myItem In s.Host
        myC.Add myItem
    Next
    
    Set ToCollection = myC
    
End Function


'@Description("Returns the predefined firstindex")
Public Function FirstIndex() As Long
Attribute FirstIndex.VB_Description = "Returns the predefined firstindex"
    FirstIndex = p.FirstIndex
End Function


'@Description("Returns the LastIndex of the Seq or -1 if the Seq is empty.  Equivalent to Count.")
Public Function LastIndex() As Long
Attribute LastIndex.VB_Description = "Returns the LastIndex of the Seq or -1 if the Seq is empty.  Equivalent to Count."

    If Me.Count < FIRST_INDEX Then
        LastIndex = LACKS_ITEMS
    Else
        LastIndex = Me.Count
    End If
   
End Function


'@Description("Returns the predefined First but One index")
Public Function FBOIndex() As Long
Attribute FBOIndex.VB_Description = "Returns the predefined First but One index"
    FBOIndex = Me.FirstIndex + 1
End Function


'Description("Returns the index of the second to last item in the SeqC, or -1 if the SeqC has lees than 2 items")
Public Function LBOIndex() As Long

    If Me.LastIndex < Me.FBOIndex Then
        LBOIndex = LACKS_ITEMS
    Else
        LBOIndex = Me.LastIndex - 1
    End If
   
End Function

'@DescriptioN("Returns the item at FirstIndex")
Public Property Get First() As Variant
Attribute First.VB_Description = "Returns the item at FirstIndex"

    First = Null

    If Me.LacksItems Then
        Exit Property
    End If
  
    If VBA.IsObject(s.Host.Item(Me.FirstIndex)) Then
        Set First = s.Host.Item(Me.FirstIndex)
    Else
        First = s.Host.Item(Me.FirstIndex)
    End If
   
End Property


'@DescriptioN("Assigns to the Item at FirstIndex")
Public Property Let First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    ' ToDo: review if the add action is better as an error
    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If
    
    s.Host.Add ipItem, after:=Me.FirstIndex
    s.Host.Remove FirstIndex
    
End Property


'@Description("Assigns to the Item at FirstIndex")
Public Property Set First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If
    
    s.Host.Add ipItem, after:=FIRST_INDEX
    s.Host.Remove FirstIndex
    
End Property


'@Description("Returns the Item at LastIndex")
Public Property Get Last() As Variant
Attribute Last.VB_Description = "Returns the Item at LastIndex"

    Last = Null

    If Me.LacksItems Then
        Exit Property
    End If
   
    If VBA.IsObject(s.Host.Item(s.Host.Count)) Then
        Set Last = s.Host.Item(s.Host.Count)
    Else
        Last = s.Host.Item(s.Host.Count)
    End If
    
End Property


'@Description("Assigns to the Item at LastIndex")
Public Property Let Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the Item at LastIndex"

    If Me.LacksItems Then
        s.Host.Add ipItem
        Exit Property
    End If
    
    s.Host.Remove s.Host.Count
    s.Host.Add ipItem
   
End Property


'@Description("Assigns to the item at LastIndex")
Public Property Set Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the item at LastIndex"

    If Me.LacksItems Then
        s.Host.Add ipItem
        Exit Property
    End If
  
    Set Me.Item(s.Host.Count) = ipItem
    
End Property


'@Description("Returns the item at FirstIndex")
Public Property Get FBO() As Variant
Attribute FBO.VB_Description = "Returns the item at FirstIndex"

    FBO = Null
    
    If Guard.IndexNotFound(FBOIndex, Me, "Get FBO", Guard.REPORT_BACK) Then
        Exit Property
    End If
   
    If VBA.IsObject(s.Host.Item(Me.FBOIndex)) Then
        Set FBO = s.Host.Item(Me.FBOIndex)
    Else
        FBO = s.Host.Item(Me.FBOIndex)
    End If
   
End Property


'@Description("Assigns to the Item at First but one Index")
Public Property Let FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at First but one Index"

    Guard.IndexNotFound FBOIndex, Me, "Let FBO"
    
    s.Host.Add ipItem, after:=Me.FBOIndex
    s.Host.Remove Me.FBOIndex
    
End Property


'@Description("Assigns to the Item at FirstIndex")
Public Property Set FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at FirstIndex"

    Guard.IndexNotFound FBOIndex, Me, "Set FBO"
   
    s.Host.Remove Me.FBOIndex
    s.Host.Add ipItem, after:=Me.FirstIndex
   
End Property


'@Description("Returns the Item at LastIndex")
Public Property Get LBO() As Variant
Attribute LBO.VB_Description = "Returns the Item at LastIndex"

    LBO = Null
    
    If Guard.IndexNotFound(Me.LBOIndex, Me, "Get LBO", Guard.REPORT_BACK) Then
        Exit Property
    End If
    
    If VBA.IsObject(s.Host.Item(LBOIndex)) Then
        Set LBO = s.Host.Item(LBOIndex)
    Else
        LBO = s.Host.Item(LBOIndex)
    End If

   
End Property


'@Description("Assigns to the Item at LastIndex")
Public Property Let LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the Item at LastIndex"

    Guard.IndexNotFound Me.LBOIndex, Me, "Let LBO"

    Me.Item(Me.LBOIndex) = ipItem

End Property


'@Description("Assigns to the item at LastIndex")
Public Property Set LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the item at LastIndex"

    Guard.IndexNotFound Me.LBOIndex, Me, "Set LBO"

    Set Me.Item(Me.LBOIndex) = ipItem
    
End Property


'@Description("Returns the index of the first Item found or -1.  Search range may be specified")
Public Function IndexOf _
( _
    ByVal ipItem As Variant, _
    Optional ByVal ipStart As Long = FIRST_INDEX, _
    Optional ByVal ipRun As Long = TO_LAST_INDEX _
) As Long
Attribute IndexOf.VB_Description = "Returns the index of the first Item found or -1.  Search range may be specified"

    IndexOf = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If Guard.IndexOutOfBounds(ipStart, Me, "IndexOf", Guard.REPORT_BACK) Then
        Exit Function
    End If
        
    ' No quick check for lacksitem as its too expensive

    
    ' ensure that ipstart+iprun only goes to the end of the seq
    Dim myEnd As Long
    If ipRun = TO_LAST_INDEX Then
        myEnd = Me.LastIndex
    ElseIf ipRun > 0 Then
        myEnd = ipStart + ipRun - 1
        If myEnd > Me.LastIndex Then
            myEnd = Me.LastIndex
        End If
    Else
        Exit Function
    End If
    
    ' we only need to search in the range defined by ipStart, myEnd
    Dim myIndex As Long
    For myIndex = ipStart To myEnd
   
        If Comparers.EQ(s.Host.Item(myIndex), ipItem) Then
            IndexOf = myIndex
            Exit Function
        End If
    
    Next
    
End Function


'@Description("Returns the index of the last item inthe specified range or -1 if not found")
Public Function LastIndexOf _
( _
ByVal ipItem As Variant, _
Optional ByVal ipStart As Long = FIRST_INDEX, _
Optional ByVal ipRun As Long = TO_LAST_INDEX _
) As Long
Attribute LastIndexOf.VB_Description = "Returns the index of the last item inthe specified range or -1 if not found"
    
    LastIndexOf = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If Guard.IndexOutOfBounds(ipStart, Me, "LastIndexOf", Guard.REPORT_BACK) Then
        Exit Function
    End If

    ' No quick check for lacksitem as its too expensive
    
    Dim myEnd As Long
    If ipRun = TO_LAST_INDEX Then
        myEnd = Me.LastIndex
    ElseIf ipRun > 0 Then
        myEnd = ipStart + ipRun - 1
        If myEnd > Me.LastIndex Then
            myEnd = Me.LastIndex
        End If
    Else
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = myEnd To ipStart Step -1
    
        If Comparers.EQ(s.Host.Item(myIndex), ipItem) Then
            LastIndexOf = myIndex
            Exit Function
        End If
    
    Next
    
    LastIndexOf = NOT_FOUND
    
End Function


'@Description("Adds one or more items . Return the Me instance")
Public Function AddItems(ParamArray ipParamarray() As Variant) As SeqC
Attribute AddItems.VB_Description = "Adds one or more items . Return the Me instance"

    If ArrayOp.LacksItems(VBA.CVar(ipParamarray)) Then
        Set AddItems = Me
        Exit Function
    End If

    Dim myParamarray As Variant: myParamarray = VBA.CVar(ipParamarray)

    AddRange myParamarray

    Set AddItems = Me

End Function


'@Description("Add an array, list type, dictionary type, or characters of a string")
Public Function AddRange(ByVal ipRange As Variant) As SeqC
Attribute AddRange.VB_Description = "Add an array, list type, dictionary type, or characters of a string"
        
    Set AddRange = Me
    
    Guard.InvalidRangeItem ipRange, MY_TYPENAME & ".AddRange", Guard.REPORT_BACK
    
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        Dim myA() As Variant: myA = Array(myItems.CurItem(0))
        If GroupInfo.IsItemByKey(ipRange) Then
            Me.Add Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            Me.Add myA(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set AddRange = Me

End Function


'@Description("Inserts one or more items starting at ipIndex")
Public Function InsertAtItems(ByRef ipIndex As Long, ParamArray ipParamarray() As Variant) As SeqC
Attribute InsertAtItems.VB_Description = "Inserts one or more items starting at ipIndex"
    
    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set InsertAtItems = InsertAtRange(ipIndex, myParamarray)
    
End Function


'@Description("Inserts items in a cotainer starting at ipIndex")
Public Function InsertAtRange(ByRef ipIndex As Long, ByRef ipRange As Variant) As SeqC
Attribute InsertAtRange.VB_Description = "Inserts items in a cotainer starting at ipIndex"

    Set InsertAtRange = Me
        
    If Guard.IndexOutOfBounds(ipIndex, Me, "InsertAtRange", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    Guard.InvalidRangeItem ipRange, MY_TYPENAME & ".InsertAtRange"
    
    ' insert in reverse order so we don't have to increment ipIndex
    Dim myItems As IterItems: Set myItems = IterItems(ipRange).MoveToEndIndex
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        If GroupInfo.IsItemByKey(ipRange) Then
            InsertAt ipIndex, Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            InsertAt ipIndex, myItems.CurItem(0)
        End If
   
    Loop While myItems.MovePrev
    
    Set InsertAtRange = Me
    
End Function


'@Description "Removes the first encountered item from the SeqC"
Public Function RemoveItems(ParamArray ipParamarray() As Variant) As SeqC
Attribute RemoveItems.VB_Description = "Removes the first encountered item from the SeqC"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set RemoveItems = RemoveRange(myParamarray)
    
    Set RemoveItems = Me
    
End Function


'@Description("Remove items in the specified range of Indexes")
Public Function RemoveRange(ByRef ipRange As Variant) As SeqC
Attribute RemoveRange.VB_Description = "Remove items in the specified range of Indexes"
  
    Set RemoveRange = Me
    
    If Me.LacksItems Then
        Exit Function
    End If
   
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        s.Host.Remove IndexOf(myItems.CurItem(0))
    Loop While myItems.MoveNext
 
End Function

'@Description("If the ParamArray is empty, removes all items otherwise removes all ocurrences of  each item in the paramarray")
Public Function RemoveAll(ParamArray ipParamarray() As Variant) As SeqC
Attribute RemoveAll.VB_Description = "If the ParamArray is empty, removes all items otherwise removes all ocurrences of  each item in the paramarray"

    Set RemoveAll = Me
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    If ArrayOp.LacksItems(myParamarray) Then
  
        #If twinbasic Then
            s.Host.Clear
        #Else
            RemoveAllItems
        #End If
        
        Exit Function
        
    End If
        
    Dim myItem As Variant
    For Each myItem In myParamarray
        RemoveAllSingleItem myItem
    Next
    
End Function

'@Description("Removes all Items from the SeqC")
Public Function Clear() As SeqC
Attribute Clear.VB_Description = "Removes all Items from the SeqC"
    ' We cannot replace the current Host with a new collection
    ' as the Host may have been bound to an external collection
    ' and consequently a new instance would unbind the external collection
    Set Clear = RemoveAll
End Function


'@Description("Removes all Items by replacing the Host collection with a new collection")
Public Function Reset() As SeqC
Attribute Reset.VB_Description = "Removes all Items by replacing the Host collection with a new collection"
    Set s.Host = New Collection
    Set Reset = Me
End Function


'@Description("Removes the items at the Indexes.  Indexes are sorted before use.")
Public Function RemoveIndexes(ParamArray ipParamarray() As Variant) As SeqC
Attribute RemoveIndexes.VB_Description = "Removes the items at the Indexes.  Indexes are sorted before use."

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set RemoveIndexes = RemoveIndexesRange(myParamarray)
    
    Set RemoveIndexes = Me
    
End Function


'@Description("Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use")
Public Function RemoveIndexesRange(ByRef ipRange As Variant) As SeqC
Attribute RemoveIndexesRange.VB_Description = "Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use"
  
    Set RemoveIndexesRange = Me
    
    If Me.LacksItems Then
        Exit Function
    End If

    ' We cannot use iteritems on ipRange directly because
    ' we need to ensure that the indexes are removed in reverse
    ' order to avoid indexes being disconnected from thier original positions
    Dim myS As SeqA
    ' SeqA will combine keys and items to a an array
    ' if ipRange is a dictionary
    ' so we choose to select the Items as the indexes
    If GroupInfo.IsItemByKey(ipRange) Then
        Set myS = SeqA(ipRange.Items)
    Else
        Set myS = SeqA(ipRange)
    End If
    
    If myS.LacksItems Then
        Exit Function
    End If
        
    myS.Sorted

    '@Ignore AssignmentNotUsed
    'Remove the sorted indexes in reverse order
    Dim myItems As IterItems: Set myItems = IterItems(myS).MoveToEndIndex
    Do
        s.Host.Remove myItems.CurItem(0)
    Loop While myItems.MovePrev
    
    Set RemoveIndexesRange = Me
        
End Function


'@Description("Adds Count of Item to the SeqC")
Public Function Fill(ByRef ipItem As Variant, Optional ByVal ipCount As Long = 1) As SeqC
Attribute Fill.VB_Description = "Adds Count of Item to the SeqC"

    Set Fill = Me
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        Me.Add ipItem
    Next
    
End Function


'@Description("Returns the first N items of the SeqC, Default 1")
Public Function Head(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As SeqC
Attribute Head.VB_Description = "Returns the first N items of the SeqC, Default 1"
    
    Set Head = SeqC.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If

    If ipSplitAfter < Me.FirstIndex Then
        Exit Function
    End If
    
    If ipSplitAfter >= Me.LastIndex Then
        Set Head = Me.Clone
        Exit Function
    End If
    
    Set Head = Me.Slice(Me.FirstIndex, ipSplitAfter)

End Function


'@Description("Returns the Items after SplitAfter, Default is Index 2")
Public Function Tail(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As SeqC
Attribute Tail.VB_Description = "Returns the Items after SplitAfter, Default is Index 2"

    Set Tail = SeqC.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipSplitAfter >= Me.LastIndex Then
        Exit Function
    End If
    
    If ipSplitAfter < Me.FirstIndex Then
        Set Tail = Me.Clone
        Exit Function
    End If
    
    Set Tail = Me.Slice(ipSplitAfter + 1)

End Function

Public Function RotLeft(Optional ByVal ipCount As Long = 1) As SeqC
    
    Set RotLeft = Me
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount = 0 Then
        Exit Function
    End If
    
    If ipCount < 0 Then
        Set RotLeft = RotRight(VBA.Abs(ipCount))
        Exit Function
    End If
    
    Me.AddRange Me.DequeueRange(ipCount)
    
End Function


Public Function RotRight(Optional ByVal ipCount As Long = 1) As SeqC
    
    Set RotRight = Me
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount = 0 Then
        Exit Function
    End If
    
    If ipCount < 0 Then
        Set RotRight = RotLeft(VBA.Abs(ipCount))
        Exit Function
    End If
    
    Me.InsertAtRange 1, Me.PopRange(ipCount).Reverse
    
End Function
'@Description("True if the Item is found in the SeqC")
Public Function HoldsItem(ByRef ipItem As Variant) As Boolean
Attribute HoldsItem.VB_Description = "True if the Item is found in the SeqC"
    
    HoldsItem = False
    
    If Me.LacksItems Then
        Exit Function
    End If

    Dim myItem As Variant
    For Each myItem In s.Host
        If Comparers.EQ(myItem, ipItem) Then
            HoldsItem = True
            Exit Function
        End If
    Next

End Function


'@Description("ArrayList terminology for HoldsItem")
Public Function Contains(ByRef ipItem As Variant) As Boolean
Attribute Contains.VB_Description = "ArrayList terminology for HoldsItem"
    Contains = Me.HoldsItem(ipItem)
End Function


'@Description("True if the Item is not found in the SeqC")
Public Function LacksItem(ByRef ipItem As Variant) As Boolean
Attribute LacksItem.VB_Description = "True if the Item is not found in the SeqC"
    LacksItem = Not Me.HoldsItem(ipItem)
End Function


'@Description("Alternative to Count > 0")
Public Function HoldsItems() As Boolean
Attribute HoldsItems.VB_Description = "Alternative to Count > 0"
    HoldsItems = s.Host.Count >= Me.FirstIndex
End Function


'@Description("Alternative to Count=0")
Public Function LacksItems() As Boolean
Attribute LacksItems.VB_Description = "Alternative to Count=0"
    LacksItems = Not Me.HoldsItems
End Function


Public Property Get TypeName() As String
    TypeName = MY_TYPENAME
End Property



'@Description("Adds items to the seq at the end of the seq")
Public Function Push(ParamArray ipParamarray() As Variant) As SeqC
Attribute Push.VB_Description = "Adds items to the seq at the end of the seq"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set Push = AddRange(myParamarray)
    
End Function

'@Description("Add the Items in ipRange to the end of the Seq")
Public Function PushRange(ByRef ipRange As Variant) As SeqC
Attribute PushRange.VB_Description = "Add the Items in ipRange to the end of the Seq"
    Set PushRange = AddRange(ipRange)
End Function

'@Description("Removes the last item from the seq and returns it")
Public Function Pop() As Variant
Attribute Pop.VB_Description = "Removes the last item from the seq and returns it"

    Pop = Null

    If Me.LacksItems Then
        Exit Function
    End If

    Dim myItem As Variant: myItem = Array(s.Host.Item(s.Host.Count))
    
    If VBA.IsObject(myItem(0)) Then
        Set Pop = myItem(0)
    Else
        Pop = myItem(0)
    End If
    
    s.Host.Remove s.Host.Count
    
End Function

'@Description("Removes ipCount Items from the  end of the Seq. Returns a SeqA of the items in order of removal"
Public Function PopRange(Optional ByVal ipCount As Long = 1) As SeqA

    Set PopRange = SeqA.Deb
    
    If ipCount < Me.FirstIndex Then
        Exit Function
    End If
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount > Me.LastIndex Then
        'Bug: SeqA(Me).reverse instantiates a seqc
        Set PopRange = SeqA(Me.Reverse)
        Me.RemoveAll
        Exit Function
    End If
    
    Dim myS As SeqA: Set myS = SeqA.Deb
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        myS.Add Me.Pop
    Next
    
    Set PopRange = myS
        
End Function

'@Description("Adds items to the seq at the end of the seq")
Public Function enQueue(ParamArray ipParamarray() As Variant) As SeqC
Attribute enQueue.VB_Description = "Adds items to the seq at the end of the seq"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set enQueue = AddRange(myParamarray)
    
End Function


Public Function EnqueueRange(ByRef ipRange As Variant) As SeqC
    Set EnqueueRange = AddRange(ipRange)
End Function


Public Function Dequeue() As Variant

    Dequeue = Null

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItem As Variant: myItem = Array(s.Host(Me.FirstIndex))
    
     s.Host.Remove Me.FirstIndex
    
    If VBA.IsObject(myItem(0)) Then
        Set Dequeue = myItem(0)
    Else
        Dequeue = myItem(0)
    End If
    
End Function


Public Function DequeueRange(Optional ByRef ipCount As Long = 1) As SeqA

    Set DequeueRange = SeqA.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount < 1 Then
        Exit Function
    End If
    
    
    If ipCount > Me.LastIndex Then
        ipCount = Me.LastIndex
    End If
    
    Dim myS As SeqA: Set myS = SeqA.Deb
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        myS.Add Me.Dequeue
    Next
    
    Set DequeueRange = myS
        
End Function


'@Description("Returns a new seq with the items in ' Ascending' order")
Public Function Sort() As SeqC
Attribute Sort.VB_Description = "Returns a new seq with the items in ' Ascending' order"

    Dim myS As SeqC: Set myS = SeqC.Deb
    
    If Me.LacksItems Then
        Set Sort = myS
        Exit Function
    End If
        
    '@Ignore AssignmentNotUsed
    Set myS = Me.Clone
    Sorters.ShakerSortByItem myS
    Set Sort = myS
    
End Function


'@Description("Sorts the seq in place in 'Ascending' order ")
Public Function Sorted() As SeqC
Attribute Sorted.VB_Description = "Sorts the seq in place in 'Ascending' order "
    
    Set Sorted = Me
    
    If Me.LacksItems Then
        Exit Function
    End If
        
    Sorters.ShakerSortByItem Me
    Set Sorted = Me
    
End Function


'@Description "Swaps the Items at the specified indexes"
Public Sub Swap(ByRef ipLHSIndex As Long, ByRef ipRHSIndex As Long)
Attribute Swap.VB_Description = "Swaps the Items at the specified indexes"

    Dim myTemp As Variant
    
    If VBA.IsObject(Item(ipLHSIndex)) Then
        Set myTemp = Item(ipLHSIndex)
    Else
        myTemp = Item(ipLHSIndex)
    End If
    
    If VBA.IsObject(Item(ipRHSIndex)) Then
        Set Item(ipLHSIndex) = Item(ipRHSIndex)
    Else
        Item(ipLHSIndex) = Item(ipRHSIndex)
    End If
    
    If VBA.IsObject(myTemp) Then
        Set Item(ipRHSIndex) = myTemp
    Else
        Item(ipRHSIndex) = myTemp
    End If

End Sub

'@Description("Returns a new seq with Items in reverse order")
Public Function Reverse() As SeqC
Attribute Reverse.VB_Description = "Returns a new seq with Items in reverse order"

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set Reverse = myS
    
    If Me.LacksItems Then
        Exit Function
    End If

    Dim myIndex As Long
    For myIndex = Me.LastIndex To Me.FirstIndex Step -1
        myS.Add s.Host.Item(myIndex)
    Next
     
    Set Reverse = myS

End Function

'@Description("Reverses the order of items in place")
Public Function Reversed() As SeqC
Attribute Reversed.VB_Description = "Reverses the order of items in place"
    
    If Me.LacksItems Or s.Host.Count = 1 Then
        Set Reversed = Me
        Exit Function
    End If
     
    Dim myFirstIndex As Long: myFirstIndex = Me.FirstIndex
    Dim myLastIndex As Long: myLastIndex = Me.LastIndex
    
    Do
    
        Me.Swap myFirstIndex, myLastIndex
        myFirstIndex = myFirstIndex + 1
        myLastIndex = myLastIndex - 1
    
    Loop Until myFirstIndex >= myLastIndex

    Set Reversed = Me

End Function

'@Description("Returns true if there are no duplicate items")
Public Function IsUnique() As Boolean
Attribute IsUnique.VB_Description = "Returns true if there are no duplicate items"

    If LacksItems Then
        IsUnique = False
        Exit Function
    End If
    
    Dim myH As cHashC: Set myH = New cHashC
    
    Dim myIndex As Long
    For myIndex = 1 To s.Host.Count
        If myH.Exists(s.Host.Item(myIndex)) Then
            IsUnique = False
            Exit Function
        Else
            myH.Add s.Host(myIndex)
        End If
    Next

    IsUnique = True

End Function


Public Function IsNotUnique() As Boolean
    IsNotUnique = Not IsUnique
End Function


'@Description("Returns the a new seq with the unique subset of the host Seq")
Public Function Dedup() As SeqC
Attribute Dedup.VB_Description = "Returns the a new seq with the unique subset of the host Seq"

    
    Dim myS As SeqC: Set myS = SeqC.Deb
    Set Dedup = myS

    If Me.LacksItems Then
        Exit Function
    End If

    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
        If myS.LacksItem(s.Host(myIndex)) Then
            myS.Add s.Host(myIndex)
        End If
    Next

    Set Dedup = myS
            
End Function


'@Description("Removes duplicate items from the seq")
Public Function Deduped() As SeqC
Attribute Deduped.VB_Description = "Removes duplicate items from the seq"

    Set Deduped = Me
    
    If LacksItems Then
        Exit Function
    End If
    
    Dim myS As SeqC: Set myS = SeqC.Deb
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
    
        If myS.HoldsItem(s.Host.Item(myIndex)) Then
            s.Host.Remove myIndex
        Else
            myS.Add s.Host(myIndex)
        End If
        
    Next
    
    Set Deduped = Me
    
End Function

''@Description("Transposes a seq of seq. Non existent items are replaced by Empty. Muutates seq")
'Public Function Transposed() As SeqA
'
'    'find the maximum size of the inner sequences
'    Dim myMaxRowIndex As Variant: myMaxRowIndex = Me.Clone.ReduceIt(rdInner(rdCountIt)).ReduceIt(rdFoldl(fnMaxNum, Globals.minLong))
'
'    ' The Transpose function cannot assume that the inner sequences are of equal length
'    ' make the inner sequences equal in length.
'    Dim myIndex As Long
'    For myIndex = Me.FirstIndex To Me.LastIndex
'        Dim myCount As Long: myCount = Me.Item(myIndex).LastIndex
'        If myCount < myMaxRowIndex Then
'            Me.Item(myIndex).Fill Empty, myMaxRowIndex - myCount
'        End If
'    Next
'
'    ' create the recipient seq
'    Dim myTrans() As Variant: ReDim myTrans(1 To myMaxRowIndex)
'    For myIndex = 1 To myMaxRowIndex
'        ' we don't know what type of seq is in seqA so call Deb on the instance
'        Set myTrans(myIndex) = Me.First.Deb.Fill(Empty, Me.LastIndex)
'    Next
'
'    ' now do the transposition
'    Dim myRowIndex As Long
'    For myRowIndex = Me.FirstIndex To Me.LastIndex
'
'        Dim myRow As ISeq: Set myRow = Me.Item(myRowIndex)
'
'        Dim myColIndex As Long
'        For myColIndex = myRow.FirstIndex To myMaxRowIndex
'
'            If VBA.IsObject(Me.Item(myRowIndex).Item(myColIndex)) Then
'                Set myTrans(myColIndex).Item(myRowIndex) = Me.Item(myRowIndex).Item(myColIndex)
'            Else
'                 myTrans(myColIndex).Item(myRowIndex) = Me.Item(myRowIndex).Item(myColIndex)
'            End If
'
'        Next
'
'    Next
'    'Fmt.Dbg "{0}", myTrans
'    s.Host = myTrans
'    p.Count = myMaxRowIndex
'    p.Size = myMaxRowIndex
'    Set Transposed = Me
'
'End Function

'@Description("Transposes a seq of seq. Non existent items are replaced by Empty")
Public Function Transpose() As SeqC
Attribute Transpose.VB_Description = "Transposes a seq of seq. Non existent items are replaced by Empty"
    
    'find the maximum size of the inner sequences
    Dim myMaxRowIndex As Variant: myMaxRowIndex = Me.Clone.ReduceIt(rdInner(rdCountIt)).ReduceIt(rdFoldl(fnMaxNum, HelpVBA.minLong))
    
    ' The Transpose function cannot assume that the inner sequences are of equal length
    ' make the inner sequences equal in length.
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
        Dim myCount As Long: myCount = Me.Item(myIndex).LastIndex
        If myCount < myMaxRowIndex Then
            Me.Item(myIndex).Fill Empty, myMaxRowIndex - myCount
        End If
    Next
    
    ' create the recipient seq
    Dim myTrans As Variant: Set myTrans = Me.Deb
    For myIndex = 1 To myMaxRowIndex
        ' we don't know what type of seq is in seqA so call Deb on the instance
        myTrans.Add Me.First.Deb.Fill(Empty, Me.LastIndex)
    Next
    
    ' now do the transposition
    Dim myRowIndex As Long
    For myRowIndex = Me.FirstIndex To Me.LastIndex
    
        Dim myRow As ISeq: Set myRow = Me.Item(myRowIndex)
        
        Dim myColIndex As Long
        For myColIndex = myRow.FirstIndex To myMaxRowIndex
            
            If VBA.IsObject(Me.Item(myRowIndex).Item(myColIndex)) Then
                Set myTrans.Item(myColIndex).Item(myRowIndex) = Me.Item(myRowIndex).Item(myColIndex)
            Else
                 myTrans.Item(myColIndex).Item(myRowIndex) = Me.Item(myRowIndex).Item(myColIndex)
            End If
 
        Next
        
    Next
    'Fmt.Dbg "{0}", myTrans
    'Set ipSeq = myTrans
    Set Transpose = myTrans

End Function
Public Function Freq() As KvpA

    Dim myK As KvpA: Set myK = KvpA.Deb
    Set Freq = myK
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
    
        If myK.LacksKey(s.Host.Item(myIndex)) Then
            myK.Add s.Host.Item(myIndex), 1
        Else
            myK.Item(s.Host.Item(myIndex)) = myK.Item(s.Host.Item(myIndex)) + 1
        End If
        
    Next
    
     Set Freq = myK
    
End Function
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' An attempt as  providing some 'lambda' functionality - see IMapper and mp/cmp/rd classes
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
'@Description("Mutates the Seq in place by applying the function in IMapper to each item")
Public Function MappedIt(ByRef ipMapper As IMapper) As SeqC
Attribute MappedIt.VB_Description = "Mutates the Seq in place by applying the function in IMapper to each item"
    'Mapped it works by reference but we allow a function return to enable fluid use of Mappedit
    
    Set MappedIt = Me
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
        ' execmapper returns a single value array
        Dim myA() As Variant: myA = ipMapper.ExecMapper(s.Host.Item(myIndex))
        
        ' Use me.Item as we have to add and remove for collection
        If VBA.IsObject(myA(0)) Then
            Set Me.Item(myIndex) = myA(0)
        Else
            Me.Item(myIndex) = myA(0)
        End If
        
    Next
    
End Function


'@Description("Returns a new Seq where each item in the Host has been mutated by the function provided by IMapper")
Public Function MapIt(ByRef ipMapper As IMapper) As SeqC
Attribute MapIt.VB_Description = "Returns a new Seq where each item in the Host has been mutated by the function provided by IMapper"

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set MapIt = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.LastIndex
        ' execmapper returns a single value array
        Dim myA() As Variant: myA = ipMapper.ExecMapper(s.Host.Item(myIndex))
        myS.Add myA(0)
    Next
    
    Set MapIt = myS

End Function


'@Description("Returns a new Seq where each item returns true from the IComparer")
Public Function FilterIt(ByVal ipComparer As IComparer) As SeqC
Attribute FilterIt.VB_Description = "Returns a new Seq where each item returns true from the IComparer"

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set FilterIt = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItem As Variant
    For Each myItem In s.Host
        If ipComparer.ExecCmp(myItem) Then
            myS.Add myItem
        End If
    
    Next
    
      Set FilterIt = myS

End Function


'@Description("Returns the count the number of items where IComparer returns true")
Public Function CountIt(ByVal ipComparer As IComparer) As Long
Attribute CountIt.VB_Description = "Returns the count the number of items where IComparer returns true"

    CountIt = -1
    
    If Me.LacksItems Then
        Exit Function
    End If
   
    Dim myCount As Long: myCount = 0
   
    Dim myItem As Variant
    For Each myItem In s.Host
        If ipComparer.ExecCmp(myItem) Then
            myCount = myCount + 1
        End If
        
    Next
   
    CountIt = myCount
    
End Function


'@Description("Returns the single value computed by the IReducer").
Public Function ReduceIt(ByRef ipReducer As IReducer) As Variant

    ReduceIt = Null

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myA() As Variant: myA = ipReducer.ExecReduction(Me)
   
    If VBA.IsObject(myA(0)) Then
        Set ReduceIt = myA(0)
    Else
        ReduceIt = myA(0)
    End If
   
End Function

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Some set functionality
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

Public Function SetOf(ByRef ipSet As e_SetoF, ByRef ipRangeItem As Variant) As SeqC

    Select Case ipSet

        Case e_SetoF.m_Common:           Set SetOf = SetOfCommon(ipRangeItem)
        Case e_SetoF.m_HostOnly:         Set SetOf = SetOfHostOnly(ipRangeItem)
        Case e_SetoF.m_ParamOnly:        Set SetOf = SetOfParamOnly(ipRangeItem)
        Case e_SetoF.m_NotCommon:        Set SetOf = SetOfNotCommon(ipRangeItem)
        Case e_SetoF.m_Unique:           Set SetOf = SetofUnique(ipRangeItem)
        Case Else
            Err.Raise 17 + vbObjectError, _
            "VBALib.SeqC.SetOf", _
            Fmt.Text("Invalid e_set member. Expecting {0} to {1}. Got {2}", e_SetoF.m_First, e_SetoF.m_Last, ipSet)
                
    End Select

End Function


'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' Private methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
Private Function SetOfCommon(ByRef ipSeq As Variant) As SeqC

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set SetOfCommon = myS
    
    If Me.LacksItems Or ipSeq.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(ipSeq)
    Do
    
        Dim myItem As Variant: myItem = Array(myItems.CurItem(0))
        
        If Me.HoldsItem(myItem(0)) Then
            myS.Add myItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetOfCommon = myS

End Function


Private Function SetOfHostOnly(ByRef ipSeq As Variant) As SeqC

    Dim myS As SeqC: Set myS = Me.Dedup
    Set SetOfHostOnly = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    If ipSeq.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(ipSeq)
    Do
    
        If myS.HoldsItem(myItems.CurItem(0)) Then
            myS.Remove myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetOfHostOnly = myS
    
End Function


Private Function SetOfParamOnly(ByRef ipSeq As Variant) As SeqC
 
    Dim myS As SeqC: Set myS = SeqC.Deb
    Set SetOfParamOnly = myS
    
    If ipSeq.LacksItems Then
        Exit Function
    End If
    
    Set myS = ipSeq.Dedup
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host)
    Do
    
        If myS.HoldsItem(myItems.CurItem(0)) Then
            myS.Remove myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetOfParamOnly = myS

End Function


Private Function SetOfNotCommon(ByRef ipSeq As Variant) As SeqC

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set SetOfNotCommon = myS
    
    If LacksItems And ipSeq.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Host)
    Do
    
        If ipSeq.LacksItem(myItems.CurItem(0)) Then
            If myS.LacksItem(myItems.CurItem(0)) Then
                myS.Add myItems.CurItem(0)
            End If
        End If
        
    Loop While myItems.MoveNext
    
    '@Ignore AssignmentNotUsed
    Set myItems = IterItems(ipSeq)
    Do
    
        If Me.LacksItem(myItems.CurItem(0)) Then
            If myS.LacksItem(myItems.CurItem(0)) Then
                myS.Add myItems.CurItem(0)
            End If
        End If
        
    Loop While myItems.MoveNext
    
    Set SetOfNotCommon = myS
    
End Function


Private Function SetofUnique(ByRef ipSeq As Variant) As SeqC

    Dim myS As SeqC: Set myS = SeqC.Deb
    Set SetofUnique = myS
    
    If Me.LacksItems And ipSeq.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    Dim myItems As IterItems: Set myItems = IterItems(ipSeq)
    Do
    
        If myS.LacksItem(myItems.CurItem(0)) Then
            myS.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetofUnique = myS
    
End Function

Private Sub RemoveAllItems()

    Dim myIndex As Long
    For myIndex = s.Host.Count To 1 Step -1
        s.Host.Remove myIndex
    Next
    
End Sub


Private Sub RemoveAllSingleItem(ByRef ipItem As Variant)

    Dim myItems As IterItems: Set myItems = IterItems(s.Host).MoveToEndIndex
    Do
        If Comparers.EQ(myItems.CurItem(0), ipItem) Then
            s.Host.Remove myItems.CurKey(0)
        End If
    Loop While myItems.MovePrev
    
End Sub

Private Function NotFound(ByRef ipItem As Variant) As Boolean

    If VBA.IsObject(ipItem) Then
        NotFound = ipItem Is Nothing
    ElseIf GroupInfo.IsNumber(ipItem) Then
        NotFound = ipItem = -1
    Else
        NotFound -VBA.IsEmpty(ipItem)
    End If
        
End Function

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'Interface Members
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
Private Function ISeq_Deb(ParamArray ipParamarray() As Variant) As Variant
    With New SeqC
        Set ISeq_Deb = .ConstructInstance(VBA.CVar(ipParamarray))
    End With
End Function
Private Function ISeq_Add(ByVal ipItem As Variant) As Long
    ISeq_Add = Add(ipItem)
End Function

Private Function ISeq_Count(Optional ByRef ipItem As Variant) As Long
    ISeq_Count = Count(ipItem)
End Function

Private Function ISeq_InsertAt(ByVal ipIndex As Long, ByVal ipItem As Variant) As Long
    ISeq_InsertAt = InsertAt(ipIndex, ipItem)
End Function

Private Property Get ISeq_Item(ByVal ipIndex As Long) As Variant
    ISeq_Item = Item(ipIndex)
End Property

Private Property Let ISeq_Item(ByVal ipIndex As Long, ByVal ipItem As Variant)
    Item(ipIndex) = ipItem
End Property

Private Property Set ISeq_Item(ByVal ipIndex As Long, ByVal ipItem As Variant)
    Set Item(ipIndex) = ipItem
End Property

Private Function ISeq_Remove(ByRef ipItem As Variant) As Long
    ISeq_Remove = Remove(ipItem)
End Function

Private Function ISeq_RemoveAt(ByRef ipIndex As Long) As Long
    ISeq_RemoveAt = RemoveAt(ipIndex)
End Function

'Private Function ISeq_Bind(ByRef ipArray As Variant) As Variant
'    Set ISeq_Bind = Bind(ipArray)
'End Function

Private Function ISeq_Clone() As Variant
    Set ISeq_Clone = Clone()
End Function

Private Function ISeq_Items() As Variant
    ISeq_Items = Items()
End Function

Private Function ISeq_Join(Optional ByRef ipSeparator As String = Chars.twComma) As String
    ISeq_Join = Join(ipSeparator)
End Function

Private Function ISeq_Slice(Optional ByRef ipStart As Long = FIRST_INDEX, Optional ByRef ipRun As Long = WHOLE_SEQ, Optional ByRef ipStep As Long = DEFAULT_STEP) As Variant
    Set ISeq_Slice = Slice(ipStart, ipRun, ipStep)
End Function

Private Function ISeq_ToArray() As Variant
    ISeq_ToArray = ToArray()
End Function

Private Function ISeq_ToCollection() As Collection
    Set ISeq_ToCollection = ToCollection()
End Function

Private Function ISeq_FirstIndex() As Long
    ISeq_FirstIndex = FirstIndex()
End Function

Private Function ISeq_LastIndex() As Long
    ISeq_LastIndex = LastIndex()
End Function

Private Function ISeq_FBOIndex() As Long
    ISeq_FBOIndex = FBOIndex()
End Function

Private Function ISeq_LBOIndex() As Long
    ISeq_LBOIndex = LBOIndex()
End Function

Private Property Get ISeq_First() As Variant
    ISeq_First = First
End Property

Private Property Let ISeq_First(ByVal ipItem As Variant)
    First = ipItem
End Property

Private Property Set ISeq_First(ByVal ipItem As Variant)
    Set First = ipItem
End Property

Private Property Get ISeq_Last() As Variant
    ISeq_Last = Last
End Property

Private Property Let ISeq_Last(ByVal ipItem As Variant)
    Last = ipItem
End Property

Private Property Set ISeq_Last(ByVal ipItem As Variant)
    Set Last = ipItem
End Property

Private Property Get ISeq_FBO() As Variant
    ISeq_FBO = FBO
End Property

Private Property Let ISeq_FBO(ByVal ipItem As Variant)
    FBO = ipItem
End Property

Private Property Set ISeq_FBO(ByVal ipItem As Variant)
    Set FBO = ipItem
End Property

Private Property Get ISeq_LBO() As Variant
    ISeq_LBO = LBO
End Property

Private Property Let ISeq_LBO(ByVal ipItem As Variant)
    LBO = ipItem
End Property

Private Property Set ISeq_LBO(ByVal ipItem As Variant)
    Set LBO = ipItem
End Property

Private Function ISeq_IndexOf(ByVal ipItem As Variant, Optional ByVal ipStart As Long = FIRST_INDEX, Optional ByVal ipRun As Long = TO_LAST_INDEX) As Long
    ISeq_IndexOf = IndexOf(ipItem, ipStart, ipRun)
End Function

Private Function ISeq_LastIndexOf(ByVal ipItem As Variant, Optional ByVal ipStart As Long = FIRST_INDEX, Optional ByVal ipRun As Long = TO_LAST_INDEX) As Long
    ISeq_LastIndexOf = LastIndexOf(ipItem, ipStart, ipRun)
End Function

Private Function ISeq_AddItems(ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_AddItems = AddItems(ipParamarray)
End Function

Private Function ISeq_AddRange(ByVal ipRange As Variant) As Variant
    Set ISeq_AddRange = AddRange(ipRange)
End Function

Private Function ISeq_InsertAtItems(ByVal ipIndex As Long, ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_InsertAtItems = InsertAtItems(ipIndex, ipParamarray)
End Function

Private Function ISeq_InsertAtRange(ByVal ipIndex As Long, ByRef ipRange As Variant) As Variant
    Set ISeq_InsertAtRange = InsertAtRange(ipIndex, ipRange)
End Function

Private Function ISeq_RemoveItems(ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_RemoveItems = RemoveItems(ipParamarray)
End Function

Private Function ISeq_RemoveRange(ByRef ipRange As Variant) As Variant
    Set ISeq_RemoveRange = RemoveRange(ipRange)
End Function

Private Function ISeq_RemoveAll(ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_RemoveAll = RemoveAll(ipParamarray)
End Function

Private Function ISeq_Clear() As Variant
    Set ISeq_Clear = Clear()
End Function

Private Function ISeq_Reset() As Variant
    Set ISeq_Reset = Reset()
End Function

Private Function ISeq_RemoveIndexes(ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_RemoveIndexes = RemoveIndexes(ipParamarray)
End Function

Private Function ISeq_RemoveIndexesRange(ByRef ipRange As Variant) As Variant
    Set ISeq_RemoveIndexesRange = RemoveIndexesRange(ipRange)
End Function

Private Function ISeq_Fill(ByRef ipItem As Variant, Optional ByVal ipCount As Long = 1) As Variant
    Set ISeq_Fill = Fill(ipItem, ipCount)
End Function

Private Function ISeq_Head(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As Variant
    Set ISeq_Head = Head(ipSplitAfter)
End Function

Private Function ISeq_Tail(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As Variant
    Set ISeq_Tail = Tail(ipSplitAfter)
End Function

Private Function ISeq_RotLeft(Optional ByVal ipCount As Long = 1) As Variant
    Set ISeq_RotLeft = RotLeft(ipCount)
End Function

Private Function ISeq_RotRight(Optional ByVal ipCount As Long = 1) As Variant
    Set ISeq_RotRight = RotRight(ipCount)
End Function

Private Function ISeq_HoldsItem(ByRef ipItem As Variant) As Boolean
    ISeq_HoldsItem = HoldsItem(ipItem)
End Function

Private Function ISeq_Contains(ByRef ipItem As Variant) As Boolean
    ISeq_Contains = Contains(ipItem)
End Function

Private Function ISeq_LacksItem(ByRef ipItem As Variant) As Boolean
    ISeq_LacksItem = LacksItem(ipItem)
End Function

Private Function ISeq_HoldsItems() As Boolean
    ISeq_HoldsItems = HoldsItems()
End Function

Private Function ISeq_LacksItems() As Boolean
    ISeq_LacksItems = LacksItems()
End Function

Private Property Get ISeq_TypeName() As String
    ISeq_TypeName = TypeName
End Property

Private Function ISeq_MappedIt(ByRef ipMapper As IMapper) As Variant
    Set ISeq_MappedIt = MappedIt(ipMapper)
End Function

Private Function ISeq_MapIt(ByVal ipMapper As IMapper) As Variant
    Set ISeq_MapIt = MapIt(ipMapper)
End Function

Private Function ISeq_FilterIt(ByVal ipComparer As IComparer) As Variant
    Set ISeq_FilterIt = FilterIt(ipComparer)
End Function

Private Function ISeq_CountIt(ByVal ipComparer As IComparer) As Long
    ISeq_CountIt = CountIt(ipComparer)
End Function

Private Function ISeq_ReduceIt(ByRef ipReducer As IReducer) As Variant
    ISeq_ReduceIt = ReduceIt(ipReducer)
End Function

Private Function ISeq_Push(ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_Push = Push(ipParamarray)
End Function

Private Function ISeq_PushRange(ByRef ipRange As Variant) As Variant
    Set ISeq_PushRange = PushRange(ipRange)
End Function

Private Function ISeq_Pop() As Variant
    ISeq_Pop = Pop()
End Function

Private Function ISeq_PopRange(Optional ByVal ipCount As Long = 1) As Variant
    Set ISeq_PopRange = PopRange(ipCount)
End Function

Private Function ISeq_enQueue(ParamArray ipParamarray() As Variant) As Variant
    Set ISeq_enQueue = enQueue(ipParamarray)
End Function

Private Function ISeq_EnqueueRange(ByRef ipRange As Variant) As Variant
    Set ISeq_EnqueueRange = EnqueueRange(ipRange)
End Function

Private Function ISeq_Dequeue() As Variant
    ISeq_Dequeue = Dequeue()
End Function

Private Function ISeq_DequeueRange(Optional ByVal ipCount As Long = 1) As Variant
    Set ISeq_DequeueRange = DequeueRange(ipCount)
End Function

Private Function ISeq_Sort() As Variant
    Set ISeq_Sort = Sort()
End Function

Private Function ISeq_Sorted() As Variant
    Set ISeq_Sorted = Sorted()
End Function

Private Sub ISeq_Swap(ByRef ipLHSIndex As Long, ByRef ipRHSIndex As Long)
    Swap ipLHSIndex, ipRHSIndex
End Sub

Private Function ISeq_Reverse() As Variant
    Set ISeq_Reverse = Reverse()
End Function

Private Function ISeq_Reversed() As Variant
    Set ISeq_Reversed = Reversed()
End Function

Private Function ISeq_IsUnique() As Boolean
    ISeq_IsUnique = IsUnique()
End Function

Private Function ISeq_IsNotUnique() As Boolean
    ISeq_IsNotUnique = IsNotUnique()
End Function

Private Function ISeq_Dedup() As Variant
    Set ISeq_Dedup = Dedup()
End Function

Private Function ISeq_Deduped() As Variant
    Set ISeq_Deduped = Deduped()
End Function

Private Function ISeq_Freq() As KvpA
    Set ISeq_Freq = Freq()
End Function

Private Function ISeq_SetOf(ByRef ipSet As e_SetoF, ByRef ipRangeItem As ISeq) As ISeq
    Set ISeq_SetOf = SetOf(ipSet, ipRangeItem)
End Function
