VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "SeqT"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
'@PredeclaredId
'@Exposed
'@Folder("Seq")
'@ModuleDescription"SeqT is a Collection/ArrayList replacement. Items are stored in a treap and a seqc. Order of addition is preserved. Keys are not supported (see kvp classes)
Option Explicit
'https://www.geeksforgeeks.org/implementation-of-search-insert-and-delete-in-treap/  python
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' Items are accessed using 1 based indexing
' Not enumerable via NewEnum (See Iteritems)
' Keys are not supported (see Kvp classes)r
' Preserves order of addition.
' Insertion at a defined order position is supported
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

Private Const MY_TYPENAME                       As String = "SeqT"
Private Const FIRST_INDEX                       As Long = 1
Private Const WHOLE_SEQ                         As Long = -1
Private Const TO_LAST_INDEX                     As Long = 0
Private Const DEFAULT_STEP                      As Long = 1
Private Const LACKS_ITEMS                       As Long = -1
Private Const INDEX_OUT_OF_BOUNDS               As Long = -1
Private Const NOT_FOUND                         As Long = -1

Private Type State
    Root                                        As SeqTNode
    Last                                        As SeqTNode
    Order                                       As SeqA
    Result                                      As Variant
End Type

Private s                                       As State


'Private Type Properties
'    FirstIndex                                  As Long
'End Type
'
'Private p                                       As Properties

' Deb is a Factory method of the PredeclaredId which returns a new instance of SeqC
'=================================================================================
' The input for Deb is a ParamArray.
' The ParamArray is interpreted according to the folowing rules
' If the ParamArray contains no Items
' - A empty Sequence (count = 0)
' If the ParamArray has 2 or more items
' - A SeqC of size equal to the ParamArray, items as generated by for each over the ParamArray
' If the ParamArray has a single Item
' - Number: Ignored as it is not necessary to set the size of the underlying collection
' - String: A Seq whose capacity is the length of the string with one character per Item
' - Array: Seq of items as provided by For Each over the array.  Multidimension arrays are flattened but the position in the original array can be calculated by the user if required.
' - Dictionaries: a Seq of key/value arrays as generated from for each on the Keys array.
' - Collection: The collection is copied to the Host collection.  There is no refererence link to the original collection (See Bind Property)
' - SeqC: Items as generated by for each on the SeqC
' - mscorlib Arraylist: Items as generated by for each on the arrylist
' - mscorlib Stack: Items as generated by for each on the stack
' - mscorlib Queue: Items as generated by for eac on the queue

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'Setup and reinitialisation methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'@DefaultMember
Public Function Deb(ParamArray ipParamarray() As Variant) As SeqT
Attribute Deb.VB_UserMemId = 0
    With New SeqT
        Set Deb = .ConstructInstance(VBA.CVar(ipParamarray))
    End With
End Function

Public Function ConstructInstance(ByRef ipFpa As Variant) As SeqT
    
    VBA.Randomize
    Set s.Root = Nothing
    Set s.Last = Nothing
    Set s.Order = SeqA.Deb
    
    
    If ArrayOp.LacksItems(ipFpa) Then
        Set ConstructInstance = Me
        Exit Function
    End If
    
    ' ipParamArray contains one or more items depending on the input type.
    ' if the input contains only a single item we want to use that item
    ' else we want to treat the forwrded paramarray as a single array item
    
    Dim myItem As Variant
    If ArrayOp.HoldsOneItem(ipFpa) Then
        If VBA.IsObject(ipFpa(0)) Then
            Set myItem = ipFpa(0)
        Else
            myItem = ipFpa(0)
        End If
    Else
        myItem = ipFpa
    End If
    
    If GroupInfo.IsNumber(myItem) Then
        ' ignore the number, we don't need to set an underlying capacity
        Set ConstructInstance = Me
        Exit Function
    End If
    
    ' Resolve the items in the forwarded paramarray using the rules
    ' as described above.
    Select Case True

        Case VBA.IsArray(myItem):               Set ConstructInstance = AddRange(ArrayOp.Linearise(myItem))
        Case GroupInfo.IsContainer(myItem):     Set ConstructInstance = AddRange(myItem)
        Case GroupInfo.IsString(myItem):        Set ConstructInstance = AddRange(myItem)
        Case Else:                              Set ConstructInstance = AddItems(myItem)
    End Select

End Function

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Core methods - essential for making the class work and status of the object
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
Public Function Add(ByRef ipItem As Variant) As Long
    'Debug.Print
    'Debug.Print "Adding ", ipItem
    Dim myNode As SeqTNode: Set myNode = SeqTNode(ipItem, GetPriority)
    Set s.Root = InsertNode(s.Root, myNode)
    s.Order.Add myNode
    UpdateOrder s.Order.Lastindex
    Add = Me.Lastindex
    
End Function

Public Function Count(Optional ByRef ipItem As Variant) As Long

    Count = LACKS_ITEMS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If VBA.IsMissing(ipItem) Then
        Count = s.Order.Lastindex
        Exit Function
    End If

    ' items of equal value are stored in the right hand brach of a node
    ' changing priorities doesn't break this arrangement
    Dim myNode As SeqTNode: Set myNode = GetNodeOf(s.Root, ipItem)
    
    If NotFound(myNode) Then
        Exit Function
    End If
    
    Dim myCount As Long
    ' The -1 is a fudge to get the right anser.
    ' I don't understand why the recursive countof method
    ' is overestimating the count by 1
    myCount = Countof(ipItem, myNode) - 1

    Count = myCount
    
End Function

'@Description("Inserts one or more items starting at ipIndex. Returns the index of the inserted item")
Public Function InsertAt(ByRef ipIndex As Long, ByRef ipItem As Variant) As Long
Attribute InsertAt.VB_Description = "Inserts one or more items starting at ipIndex. Returns the index of the inserted item"

    InsertAt = INDEX_OUT_OF_BOUNDS
    
    If Guard.IndexOutOfBounds(ipIndex, Me, "InsertAt", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    Dim myNode As SeqTNode: Set myNode = SeqTNode(ipItem, GetPriority, ipIndex)
    Set s.Root = InsertNode(myNode, s.Root)
    s.Order.InsertAt ipIndex, myNode
    UpdateOrder ipIndex
    
    InsertAt = ipIndex

End Function

Public Property Get Item(ByVal ipIndex As Long) As Variant

    Item = Null
    
    If Guard.IndexOutOfBounds(ipIndex, Me, "Get Item", Guard.REPORT_BACK) Then
        Exit Property
    End If

    Dim myItem As Variant: myItem = Array(s.Order.Item(ipIndex).Item)

    If VBA.IsObject(myItem(0)) Then
        Set Item = myItem(0)
    Else
        Item = myItem(0)
    End If

End Property


Public Property Let Item(ByVal ipIndex As Long, ByVal ipItem As Variant)

    Guard.IndexOutOfBounds ipIndex, Me, "Let_Item"

    ' Because the underlying structure is a treap we can't just replace the
    ' item in a node.  Instead we have to delete the existing node and then
    ' replace with a new node. The replacement ensures that the new node
    ' has the same location in s.order but due to the way in which a
    ' node is constructed the new node will be in a different position in the
    ' treap and the treap istelf will have some reorganistion due to rotations.
    
    RemoveAt ipIndex
    ' The removal means that we could have a case where ipindex now exceeds
    ' the lastindex because we just deleted lastindex.  In this case we cannot just
    ' insertat because the index won't exist so we have to do an insertnode
    ' and then an s.order.add
    If ipIndex = Me.Lastindex + 1 Then
        Dim myNode As SeqTNode: Set myNode = SeqTNode(ipItem, GetPriority)
        InsertNode s.Root, myNode
        s.Order.Add myNode
        UpdateOrder ipIndex
    Else
        InsertAt ipIndex, ipItem
    End If
        
End Property

 
Public Property Set Item(ByVal ipIndex As Long, ByVal ipItem As Variant)

    Guard.IndexOutOfBounds ipIndex, Me, "Set Item"

    ' Because the underlying structure is a treap we can't just replace the
    ' item in a node.  Instead we have to delete the existing node and then
    ' replace with a new node. The replacement ensures that the new node
    ' has the same location in s.order but due to the way in which a
    ' node is constructed the new node will be in a different position in the
    ' treap and the treap istelf will have some reorganistion due to rotations.
    
    RemoveAt ipIndex
    ' The removal means that we could have a case where ipindex now exceeds
    ' the lastindex because we just deleted lastindex.  In this case we cannot just
    ' insertat because the index won't exist so we have to do an insertnode
    ' and then an s.order.add
    If ipIndex = Me.Lastindex + 1 Then
        Dim myNode As SeqTNode: Set myNode = SeqTNode(ipItem, GetPriority)
        InsertNode s.Root, myNode
        s.Order.Add myNode
        UpdateOrder ipIndex
    Else
        InsertAt ipIndex, ipItem
    End If

End Property

Public Function Remove(ByRef ipItem As Variant) As Long
    
    Remove = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Set s.Root = DeleteNode(s.Root, ipItem)
    ' The deletion of the node occurs at the lowest point of the recursion
    ' so we use a parameter external to DeleteNode to record the
    ' index of the node that is deleted
    Remove = s.Result
    
End Function

'@Description("Removes the item at the specified index")
Public Function RemoveAt(ByRef ipIndex As Long) As Long
Attribute RemoveAt.VB_Description = "Removes the item at the specified index"
    'Debug.Print "RemoveAt ",
    'Fmt.Dbg "{0},{1},{2}", s.Order.Item(1).Item, s.Order.Item(1).Left, s.Order.Item(1).Right
    RemoveAt = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If Guard.IndexOutOfBounds(ipIndex, Me, "RemoveAt", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    
    Dim myNode As SeqTNode: Set myNode = s.Order.Item(ipIndex)
    'Debug.Print
    'Debug.Print
    'Debug.Print "Deleting Index", ipIndex, " node is ", myNode.Order, myNode.Item
    myNode.Priority = -1
   '@Ignore AssignmentNotUsed
   
   'Debug.Print "Searching from root ", s.Root.Item
   Set myNode = DeleteNodeAt(s.Root, myNode.Item, ipIndex) ', ipItem)
    'DeleteNodeAt myNode
'    s.Order.Item(ipIndex) = Nothing
'    s.Order.RemoveAt ipIndex
'
'    'Set myNode = Nothing
'
'    UpdateOrder ipIndex
    RemoveAt = ipIndex
    
End Function

'
'Private Function NodeIsLowerPriority(ByRef ipNode As Variant) As Boolean
'
'    If IsNotNothing(ipNode.Right) Then
'        NodeIsLowerPriority = ipNode.Priority < ipNode.Right.Priority
'        Exit Function
'    End If
'
'    If IsNotNothing(ipNode.Left) Then
'        NodeIsLowerPriority = ipNode.Priority < ipNode.Left.Priority
'        ExiIndex t Function
'    End If
'
'
'End Function

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Sugar methods' Add to the flexibility of the seq class
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

' There is no bind method as the underlying object does not support setting a capacity
'@Description("Makes a shallow copy of the seq. Items are stored in the correct order but the tree may be different as priorities will be different")
Public Function Clone() As SeqT
Attribute Clone.VB_Description = "Makes a shallow copy of the seq. Items are stored in the correct order but the tree may be different as priorities will be different"

    Dim myS As SeqT: Set myS = SeqT.Deb
    Set Clone = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = s.Order.FirstIndex To s.Order.Lastindex
        myS.Add s.Order.Item(myIndex).Item
    Next
    
    Set Clone = myS
    
End Function


'@Description("Returns the Items in the seq as an Array() of variants")
Public Function Items() As Variant
Attribute Items.VB_Description = "Returns the Items in the seq as an Array() of variants"

    Items = Array()

    If Me.LacksItems Then
        Exit Function
    End If

    Items = Me.ToArray
    
End Function

'@Description("Returns a subset of the SeqC")
Public Function Slice _
( _
Optional ByRef ipStart As Long = FIRST_INDEX, _
Optional ByRef ipRun As Long = WHOLE_SEQ, _
Optional ByRef ipStep As Long = DEFAULT_STEP _
) As SeqT
Attribute Slice.VB_Description = "Returns a subset of the SeqC"
    
    ' ToDo: Should all Seq return a SeqA for SLice?
    Set Slice = SeqT.Deb

    If Me.LacksItems Then
        Exit Function
    End If
    
    Guard.IndexOutOfBounds ipStart, Me, "Slice"
    
    Dim myEnd As Long
    If ipRun < Me.FirstIndex Then
        myEnd = Me.Lastindex
    Else
        myEnd = ipStart + ipRun - 1
        If myEnd > Me.Lastindex Then
            myEnd = Me.Lastindex
        End If
    End If

   
    Dim myS As SeqT: Set myS = SeqT.Deb
   
    Dim mySeqIndex As Long
    For mySeqIndex = ipStart To myEnd Step ipStep
        myS.Add s.Order.Item(mySeqIndex).Item
    Next

    Set Slice = myS

End Function

'@Description("Returns a shallow copy of the SeqC as an Array.  The Lbound of the array is 1")
Public Function ToArray() As Variant
Attribute ToArray.VB_Description = "Returns a shallow copy of the SeqC as an Array.  The Lbound of the array is 1"

    ToArray = Array()

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myS As SeqA: Set myS = SeqA(Me.Lastindex)
        
    Dim myIndex As Long
    For myIndex = s.Order.FirstIndex To s.Order.Lastindex
        myS.Add s.Order.Item(myIndex).Item
    Next
    
    ToArray = myS.ToArray

End Function

'@Description("Returns a shallow copy of the SeqC as a VBA collection")
Public Function ToCollection() As Collection
Attribute ToCollection.VB_Description = "Returns a shallow copy of the SeqC as a VBA collection"
    
    Dim myC As Collection: Set myC = New Collection
    Set ToCollection = myC
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = s.Order.FirstIndex To s.Order.Lastindex
        myC.Add s.Order.Item(myIndex).Item
    Next
    
    Set ToCollection = myC
    
End Function

'Public Sub isbalanced()
'
'    IsTreeIsBalanced s.Root
'
'End Sub
'Private Sub IsTreeIsBalanced(ByVal ipNode As SeqTNode)
'
'    If ipNode Is Nothing Then
'        Exit Sub
'    End If
'
'    IsTreeIsBalanced ipNode.Left
'
'    If IsNotNothing(ipNode.Left) And IsNotNothing(ipNode.Right) Then
'        If ipNode.Left.Priority < ipNode.Right.Priority Then
'            'Debug.Print ipNode.Item, "Is balanced", ipNode.Left.Priority, ipNode.Right.Priority
'        Else
'            'Debug.Print ipNode.Item, "Not balanced", ipNode.Left.Priority, ipNode.Right.Priority
'        End If
'    End If
'
'    IsTreeIsBalanced ipNode.Right
'
'End Sub
Public Function FirstIndex() As Long
    FirstIndex = s.Order.FirstIndex
End Function
     
     
Public Function Lastindex() As Long
    Lastindex = s.Order.Lastindex
End Function

'@Description("Returns the predefined First but One index")
Public Function FBOIndex() As Long
Attribute FBOIndex.VB_Description = "Returns the predefined First but One index"
    FBOIndex = s.Order.FBOIndex
End Function

'Description("Returns the index of the second to last item in the SeqC, or -1 if the SeqC has lees than 2 items")
Public Function LBOIndex() As Long
    LBOIndex = s.Order.LBOIndex
End Function


'@DescriptioN("Returns the item at FirstIndex")
Public Property Get First() As Variant
Attribute First.VB_Description = "Returns the item at FirstIndex"

    First = Null

    If Me.LacksItems Then
        Exit Property
    End If
  
    Dim myA() As Variant: myA = Array(s.Order.First.Item)
    If VBA.IsObject(myA(0)) Then
        Set First = myA(0)
    Else
        First = myA(0)
    End If
   
End Property

'@DescriptioN("Assigns to the Item at FirstIndex")
' Applies to let/set of First/Last/FBO/LBO
' Because the underlying structure is a treap we can't just replace the
' item in a node.  Instead we have to delete the existing node and then
' replace with a new node. The replacement ensures that the new node
' has the same location in s.order however, due to the way in which a
' node is constructed the new node will be in a different position in the
' treap and the treap istelf will have some reorganistion due to rotations.

Public Property Let First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    ' ToDo: review if the add action is better as an error
    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If
    
    Set s.Root = DeleteNodeAt(s.Order.First, s.Root, Me.FirstIndex)
    InsertAt s.Order.FirstIndex, ipItem
    
End Property


'@DescriptioN("Assigns to the Item at FirstIndex")
Public Property Set First(ByVal ipItem As Variant)
Attribute First.VB_Description = "Assigns to the Item at FirstIndex"

    ' ToDo: review if the add action is better as an error
    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If
    
    Set s.Root = DeleteNodeAt(s.Order.First, s.Root, Me.FirstIndex)
    InsertAt s.Order.FirstIndex, ipItem
    
End Property

'@Description("Returns the Item at LastIndex")
Public Property Get Last() As Variant
Attribute Last.VB_Description = "Returns the Item at LastIndex"

    Last = Null

    If Me.LacksItems Then
        Exit Property
    End If
   
    Dim myA() As Variant: myA = Array(s.Order.Last.Item)
    If VBA.IsObject(myA(0)) Then
        Set Last.Item = myA(0)
    Else
        Last.Item = myA(0)
    End If
    
End Property

'@Description("Assigns to the Item at LastIndex")
Public Property Let Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the Item at LastIndex"

    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If
    
    Set s.Root = DeleteNodeAt(s.Order.Last, s.Root, Me.Lastindex)
    InsertAt s.Order.Lastindex, ipItem
   
End Property

'@Description("Assigns to the Item at LastIndex")
Public Property Set Last(ByVal ipItem As Variant)
Attribute Last.VB_Description = "Assigns to the Item at LastIndex"

    If Me.LacksItems Then
        Me.Add ipItem
        Exit Property
    End If
    
    Set s.Root = DeleteNodeAt(s.Order.Last, s.Root, Me.Lastindex)
    InsertAt s.Order.Lastindex, ipItem
   
End Property

'@Description("Returns the item at FirstIndex")
Public Property Get FBO() As Variant
Attribute FBO.VB_Description = "Returns the item at FirstIndex"

    Dim myA() As Variant: myA = Array(s.Order.FBO.Item)
    If VBA.IsObject(myA(0)) Then
        Set FBO = myA(0)
    Else
        FBO = myA(0)
    End If
    
End Property
   
'@Description("Assigns to the Item at First but one Index")
Public Property Let FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at First but one Index"
    Set s.Root = DeleteNodeAt(s.Order.FBO, s.Root, Me.FBOIndex)
    InsertAt s.Order.FBOIndex, ipItem
End Property

'@Description("Assigns to the Item at First but one Index")
Public Property Set FBO(ByVal ipItem As Variant)
Attribute FBO.VB_Description = "Assigns to the Item at First but one Index"
    Set s.Root = DeleteNodeAt(s.Order.FBO, s.Root, Me.FBOIndex)
    InsertAt s.Order.FBOIndex, ipItem
End Property

'@Description("Returns the item at FirstIndex")
Public Property Get LBO() As Variant
Attribute LBO.VB_Description = "Returns the item at FirstIndex"

    Dim myA() As Variant: myA = Array(s.Order.LBO.Item)
    If VBA.IsObject(myA(0)) Then
        Set LBO = myA(0)
    Else
        LBO = myA(0)
    End If
End Property
   
'@Description("Assigns to the Item at First but one Index")
Public Property Let LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the Item at First but one Index"
    Set s.Root = DeleteNodeAt(s.Order.LBO, s.Root, Me.LBOIndex)
    InsertAt s.Order.LBOIndex, ipItem
End Property

'@Description("Assigns to the Item at First but one Index")
Public Property Set LBO(ByVal ipItem As Variant)
Attribute LBO.VB_Description = "Assigns to the Item at First but one Index"
    Set s.Root = DeleteNodeAt(s.Order.LBO, s.Root, Me.LBOIndex)
    InsertAt s.Order.LBOIndex, ipItem
End Property

'@Description("Returns the index of the first Item found or -1.  Search range may be specified")
Public Function IndexOf _
( _
    ByVal ipItem As Variant, _
    Optional ByVal ipStart As Long = FIRST_INDEX, _
    Optional ByVal ipRun As Long = TO_LAST_INDEX _
) As Long
Attribute IndexOf.VB_Description = "Returns the index of the first Item found or -1.  Search range may be specified"

    IndexOf = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If Guard.IndexOutOfBounds(ipStart, Me, "IndexOf", Guard.REPORT_BACK) Then
        Exit Function
    End If
        
    ' No quick check for lacksitem as its too expensive

    
    ' ensure that ipstart+iprun only goes to the end of the seq
    Dim myEnd As Long
    If ipRun = TO_LAST_INDEX Then
        myEnd = Me.Lastindex
    ElseIf ipRun > 0 Then
        myEnd = ipStart + ipRun - 1
        If myEnd > Me.Lastindex Then
            myEnd = Me.Lastindex
        End If
    Else
        Exit Function
    End If
    
    ' we only need to search in the range defined by ipStart, myEnd
    Dim myIndex As Long
    For myIndex = ipStart To myEnd
   
        If Comparers.EQ(s.Order.Item(myIndex).Item, ipItem) Then
            IndexOf = myIndex
            Exit Function
        End If
    
    Next
    
End Function

'@Description("Returns the index of the last item inthe specified range or -1 if not found")
Public Function LastIndexOf _
( _
ByVal ipItem As Variant, _
Optional ByVal ipStart As Long = FIRST_INDEX, _
Optional ByVal ipRun As Long = TO_LAST_INDEX _
) As Long
Attribute LastIndexOf.VB_Description = "Returns the index of the last item inthe specified range or -1 if not found"
    
    LastIndexOf = NOT_FOUND
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If Guard.IndexOutOfBounds(ipStart, Me, "LastIndexOf", Guard.REPORT_BACK) Then
        Exit Function
    End If

    ' No quick check for lacksitem as its too expensive
    
    Dim myEnd As Long
    If ipRun = TO_LAST_INDEX Then
        myEnd = Me.Lastindex
    ElseIf ipRun > 0 Then
        myEnd = ipStart + ipRun - 1
        If myEnd > Me.Lastindex Then
            myEnd = Me.Lastindex
        End If
    Else
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = myEnd To ipStart Step -1
    
        If Comparers.EQ(s.Order.Item(myIndex).Item, ipItem) Then
            LastIndexOf = myIndex
            Exit Function
        End If
    
    Next
    
    LastIndexOf = NOT_FOUND
    
End Function


'@Description("Adds one or more items . Return the Me instance")
Public Function AddItems(ParamArray ipParamarray() As Variant) As SeqT
Attribute AddItems.VB_Description = "Adds one or more items . Return the Me instance"

    If ArrayOp.LacksItems(VBA.CVar(ipParamarray)) Then
        Set AddItems = Me
        Exit Function
    End If

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))

    AddRange myParamarray

    Set AddItems = Me

End Function

'@Description("Add an array, list type, dictionary type, or characters of a string")
Public Function AddRange(ByVal ipRange As Variant) As SeqT
Attribute AddRange.VB_Description = "Add an array, list type, dictionary type, or characters of a string"
        
    Set AddRange = Me
    
    Guard.InvalidRangeItem ipRange, MY_TYPENAME, "AddRange", Guard.REPORT_BACK
    
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        If GroupInfo.IsDictionary(ipRange) Then
            Me.Add Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            Me.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set AddRange = Me

End Function

'@Description("Inserts one or more items starting at ipIndex")
Public Function InsertAtItems(ByRef ipIndex As Long, ParamArray ipParamarray() As Variant) As SeqT
Attribute InsertAtItems.VB_Description = "Inserts one or more items starting at ipIndex"
    
    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set InsertAtItems = InsertAtRange(ipIndex, myParamarray)
    
End Function

'@Description("Inserts items in a cotainer starting at ipIndex")
Public Function InsertAtRange(ByRef ipIndex As Long, ByRef ipRange As Variant) As SeqT
Attribute InsertAtRange.VB_Description = "Inserts items in a cotainer starting at ipIndex"

    Set InsertAtRange = Me
        
    If Guard.IndexOutOfBounds(ipIndex, Me, "InsertAtRange", Guard.REPORT_BACK) Then
        Exit Function
    End If
    
    Guard.InvalidRangeItem ipRange, MY_TYPENAME, "InsertAtRange"
    
    ' insert in reverse order so we don't have to increment ipIndex
    Dim myItems As IterItems: Set myItems = IterItems(ipRange).MoveToEndIndex
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        If GroupInfo.IsDictionary(ipRange) Then
            InsertAt ipIndex, Array(myItems.CurKey(0), myItems.CurItem(0))
        Else
            InsertAt ipIndex, myItems.CurItem(0)
        End If
   
    Loop While myItems.MovePrev
    
    Set InsertAtRange = Me
    
End Function

'@Description "Removes the first encountered item from the SeqC"
Public Function RemoveItems(ParamArray ipParamarray() As Variant) As SeqT
Attribute RemoveItems.VB_Description = "Removes the first encountered item from the SeqC"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set RemoveItems = RemoveRange(myParamarray)
    
    Set RemoveItems = Me
    
End Function


'@Description("Remove items in the specified range of Indexes")
Public Function RemoveRange(ByRef ipRange As Variant) As SeqT
Attribute RemoveRange.VB_Description = "Remove items in the specified range of Indexes"
  
    Set RemoveRange = Me
    
    If Me.LacksItems Then
        Exit Function
    End If
   
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
        ''Debug.Print "Removing", myItems.CurItem(0)
        Dim myA() As Variant: myA = Array(myItems.CurItem(0))
        Remove myA(0)
        'Debug.Print
        'Debug.Print
        'Me.PrintByOrder
    Loop While myItems.MoveNext
 
End Function

'@Description("If the ParamArray is empty, removes all items otherwise removes all ocurrences of  each item in the paramarray")
Public Function RemoveAll(ParamArray ipParamarray() As Variant) As SeqT
Attribute RemoveAll.VB_Description = "If the ParamArray is empty, removes all items otherwise removes all ocurrences of  each item in the paramarray"

    Set RemoveAll = Me
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    If ArrayOp.LacksItems(myParamarray) Then
  
        RemoveAllItems s.Root
        Set s.Order = Nothing
        Set s.Order = SeqA.Deb
        Set s.Root = Nothing
        Exit Function
        
    End If
        
    Dim myItem As Variant
    For Each myItem In myParamarray
        RemoveAllSingleItem myItem
    Next
    
End Function

'@Description("Removes all Items from the SeqC")
Public Function Clear() As SeqT
Attribute Clear.VB_Description = "Removes all Items from the SeqC"
    ' We cannot replace the current Host with a new collection
    ' as the Host may have been bound to an external collection
    ' and consequently a new instance would unbind the external collection
    Set Clear = RemoveAll
End Function

'@Description("Removes all Items by replacing the Host collection with a new collection")
Public Function Reset() As SeqT
Attribute Reset.VB_Description = "Removes all Items by replacing the Host collection with a new collection"
    Set Reset = RemoveAll
End Function

'@Description("Removes the items at the Indexes.  Indexes are sorted before use.")
Public Function RemoveIndexes(ParamArray ipParamarray() As Variant) As SeqT
Attribute RemoveIndexes.VB_Description = "Removes the items at the Indexes.  Indexes are sorted before use."

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set RemoveIndexes = RemoveIndexesRange(myParamarray)
    
    Set RemoveIndexes = Me
    
End Function

'@Description("Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use")
Public Function RemoveIndexesRange(ByRef ipRange As Variant) As SeqT
Attribute RemoveIndexesRange.VB_Description = "Remove items in the specified range of Indexes. Indexes are sorted in reverse order before use"
  
    Set RemoveIndexesRange = Me
    
    If Me.LacksItems Then
        Exit Function
    End If

    ' We cannot use iteritems on ipRange directly because
    ' we need to ensure that the indexes are removed in reverse
    ' order to avoid indexes being disconnected from thier original positions
    Dim myS As SeqA
    ' SeqA will combine keys and items to a an array
    ' if ipRange is a dictionary
    ' so we choose to select the Items as the indexes
    If GroupInfo.IsDictionary(ipRange) Then
        Set myS = SeqA(ipRange.Items)
    Else
        Set myS = SeqA(ipRange)
    End If
    
    If myS.LacksItems Then
        Exit Function
    End If
        
    myS.Sorted

    'Remove the sorted indexes in reverse order
    Dim myItems As IterItems: Set myItems = IterItems(myS).MoveToEndIndex
    Do
        Dim myItem As Variant: myItem = myItems.CurItem(0)
        'Debug.Print "Removing Index", myItem
        RemoveAt VBA.CLng(myItem)
        
    Loop While myItems.MovePrev
    
    Set RemoveIndexesRange = Me
        
End Function

'@Description("Adds Count of Item to the SeqC")
Public Function Fill(ByRef ipItem As Variant, Optional ByVal ipCount As Long = 1) As SeqT
Attribute Fill.VB_Description = "Adds Count of Item to the SeqC"

    Set Fill = Me
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        Me.Add ipItem
    Next
    
End Function

'@Description("Returns the first N items of the SeqC, Default 1")
Public Function Head(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As SeqT
Attribute Head.VB_Description = "Returns the first N items of the SeqC, Default 1"
    
    Set Head = SeqT.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If

    If ipSplitAfter < Me.FirstIndex Then
        Exit Function
    End If
    
    If ipSplitAfter >= Me.Lastindex Then
        Set Head = Me.Clone
        Exit Function
    End If
    
    Set Head = Me.Slice(Me.FirstIndex, ipSplitAfter)

End Function

'@Description("Returns the Items after SplitAfter, Default is Index 2")
Public Function Tail(Optional ByVal ipSplitAfter As Long = FIRST_INDEX) As SeqT
Attribute Tail.VB_Description = "Returns the Items after SplitAfter, Default is Index 2"

    Set Tail = SeqT.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipSplitAfter >= Me.Lastindex Then
        Exit Function
    End If
    
    If ipSplitAfter < Me.FirstIndex Then
        Set Tail = Me.Clone
        Exit Function
    End If
    
    Set Tail = Me.Slice(ipSplitAfter + 1)

End Function

'@Description("True if the Item is found in the SeqC")
Public Function HoldsItem(ByRef ipItem As Variant) As Boolean
Attribute HoldsItem.VB_Description = "True if the Item is found in the SeqC"
    
    HoldsItem = False
    
    If Me.LacksItems Then
        Exit Function
    End If

    Dim myNode As SeqTNode: Set myNode = GetNodeOf(s.Root, ipItem)
    
    If NotFound(myNode) Then
        Exit Function
    End If
    
    HoldsItem = True
    
End Function

'@Description("ArrayList terminology for HoldsItem")
Public Function Contains(ByRef ipItem As Variant) As Boolean
Attribute Contains.VB_Description = "ArrayList terminology for HoldsItem"
    Contains = Me.HoldsItem(ipItem)
End Function


'@Description("True if the Item is not found in the SeqC")
Public Function LacksItem(ByRef ipItem As Variant) As Boolean
Attribute LacksItem.VB_Description = "True if the Item is not found in the SeqC"
    LacksItem = Not Me.HoldsItem(ipItem)
End Function


Public Function HoldsItems() As Boolean
    HoldsItems = Not LacksItems
End Function

Public Function LacksItems() As Boolean
    LacksItems = s.Root Is Nothing
End Function


Public Property Get TypeName() As String
    TypeName = MY_TYPENAME
End Property

'@Description("Adds items to the seq at the end of the seq")
Public Function Push(ParamArray ipParamarray() As Variant) As SeqT
Attribute Push.VB_Description = "Adds items to the seq at the end of the seq"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set Push = AddRange(myParamarray)
    
End Function

'@Description("Add the Items in ipRange to the end of the Seq")
Public Function PushRange(ByRef ipRange As Variant) As SeqT
Attribute PushRange.VB_Description = "Add the Items in ipRange to the end of the Seq"
    Set PushRange = AddRange(ipRange)
End Function

'@Description("Removes the last item from the seq and returns it")
Public Function Pop() As Variant
Attribute Pop.VB_Description = "Removes the last item from the seq and returns it"

    Pop = Null

    If Me.LacksItems Then
        Exit Function
    End If

    Dim myA() As Variant: myA = Array(s.Order.Last.Item)
    
    Me.RemoveAt s.Order.Lastindex
    
    If VBA.IsObject(myA(0)) Then
        Set Pop = myA(0)
    Else
        Pop = myA(0)
    End If
    
End Function


'@Description("Removes ipCount Items from the  end of the Seq. Returns a SeqA of the items in order of removal"
Public Function PopRange(Optional ByVal ipCount As Long = 1) As SeqA

    Set PopRange = SeqA.Deb
    
    If ipCount < 1 Then
        Exit Function
    End If
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount > Me.Lastindex Then
        'Bug: SeqA(Me).reverse instantiates a seqc
        Set PopRange = SeqA(Me.Reverse)
        Me.RemoveAll
        Exit Function
    End If
    
    Dim myS As SeqA: Set myS = SeqA.Deb
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        myS.Add Me.Pop
    Next
    
    Set PopRange = myS
        
End Function


'@Description("Adds items to the seq at the end of the seq")
Public Function enQueue(ParamArray ipParamarray() As Variant) As SeqT
Attribute enQueue.VB_Description = "Adds items to the seq at the end of the seq"

    Dim myParamarray As Variant: myParamarray = ArrayOp.Splat(VBA.CVar(ipParamarray))
    
    Set enQueue = AddRange(myParamarray)
    
End Function

Public Function EnqueueRange(ByRef ipRange As Variant) As SeqT
    Set EnqueueRange = AddRange(ipRange)
End Function


Public Function Dequeue() As Variant

    Dequeue = Null

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItem As Variant: myItem = Array(Me.First)
    
    Me.RemoveAt Me.FirstIndex
    
    If VBA.IsObject(myItem(0)) Then
        Set Dequeue = myItem(0)
    Else
        Dequeue = myItem(0)
    End If
    
    
    
End Function

Public Function DequeueRange(Optional ByRef ipCount As Long = 1) As SeqA

    Set DequeueRange = SeqA.Deb
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    If ipCount < 1 Then
        Exit Function
    End If
    
    If ipCount > Me.Lastindex Then
        ipCount = Me.Lastindex
    End If
    
    Dim myS As SeqA: Set myS = SeqA.Deb
    
    Dim myCount As Long
    For myCount = 1 To ipCount
        myS.Add Me.Dequeue
    Next
    
    Set DequeueRange = myS
        
End Function

'@Description("Returns a new seq with the items in ' Ascending' order")
Public Function Sort() As SeqT
Attribute Sort.VB_Description = "Returns a new seq with the items in ' Ascending' order"
    '******************************
    'Treap is already in sort order so we need to compile a seq where Item(ipIndex)
    ' is sorted.  This is simple to do as we just scan the treap in order and
    'build the new treap by adding to a new seq.  Recursion makes this awkward so
    ' the new seq is provided as an out parameter
    Dim myS As SeqT: Set myS = SeqT.Deb
    
    If Me.LacksItems Then
        Set Sort = myS
        Exit Function
    End If
    
    SeqInOrder s.Root, myS
    
    Set Sort = myS
    
End Function
    
'@Description("Sorts the seq in place in 'Ascending' order ")
Public Function Sorted() As SeqT
Attribute Sorted.VB_Description = "Sorts the seq in place in 'Ascending' order "
    ' For a seqT sorted in place means ensuring that the
    ' s.order is also in order seq.  We can change change the position
    ' in s.order without affecting the treap.  Likewise the
    ' node internal order value (which should match position in s.Order)
    Set Sorted = Me

    If Me.LacksItems Then
        Exit Function
    End If
        
    Sorters.ShakerSortByItemOfItem s.Order
    UpdateOrder s.Order.FirstIndex
    Set Sorted = Me
    
End Function


'@Description("Returns a new seq with Items in reverse order")
Public Sub Swap(ByRef ipLHSIndex As Long, ByRef ipRHSIndex As Long)
Attribute Swap.VB_Description = "Returns a new seq with Items in reverse order"

    Guard.IndexOutOfBounds ipLHSIndex, Me, "Swap"
    Guard.IndexOutOfBounds ipRHSIndex, Me, "Swap"
    Dim myTemp As Variant
    
    Set myTemp = Item(ipLHSIndex)
    Set Item(ipLHSIndex) = Item(ipRHSIndex)
    Set Item(ipRHSIndex) = myTemp

End Sub


'@Description("Returns a new seq with Items in reverse order")
Public Function Reverse() As SeqT
Attribute Reverse.VB_Description = "Returns a new seq with Items in reverse order"
    ' Reverse cannot change the order of the treap without changing
    ' the nature of how the treap works.  So its only the s.order that is reversed
    

    Dim myS As SeqT: Set myS = SeqT.Deb
    Set Reverse = myS
    
    If Me.LacksItems Then
        Exit Function
    End If

    Dim myIndex As Long
    For myIndex = s.Order.Lastindex To s.Order.FirstIndex Step -1
        myS.Add s.Order.Item(myIndex).Item
    Next
     
    Set Reverse = myS

End Function

'@Description("Reverses the order of items in place")
Public Function Reversed() As SeqT
Attribute Reversed.VB_Description = "Reverses the order of items in place"
    
    Set Reversed = Me
    If s.Order.Count <= 1 Then
        Exit Function
    End If
     
    Dim myFirstIndex As Long: myFirstIndex = Me.FirstIndex
    Dim myLastIndex As Long: myLastIndex = Me.Lastindex
    
    Do
    
        s.Order.Swap myFirstIndex, myLastIndex
        myFirstIndex = myFirstIndex + 1
        myLastIndex = myLastIndex - 1
    
    Loop Until myFirstIndex >= myLastIndex

    UpdateOrder Me.FirstIndex
    
    Set Reversed = Me

End Function

'@Description("Returns true if there are no duplicate items")
Public Function IsUnique() As Boolean
Attribute IsUnique.VB_Description = "Returns true if there are no duplicate items"

    IsUnique = False
    
    If LacksItems Then
        Exit Function
    End If
    
    Dim myS As SeqT: Set myS = SeqT.Deb
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.Lastindex
        With s.Order.Item(myIndex)
        
            If myS.LacksItem(.Item) Then
                myS.Add .Item
            Else
                Exit Function
            End If
            
        End With
    Next
    
    IsUnique = True

End Function

Public Function IsNotUnique() As Boolean
    IsNotUnique = Not IsUnique
End Function


'@Description("Returns the a new seq with the unique subset of the host Seq")
Public Function Dedup() As SeqT
Attribute Dedup.VB_Description = "Returns the a new seq with the unique subset of the host Seq"

    Dim myS As SeqT: Set myS = SeqT.Deb
    Set Dedup = myS

    If Me.LacksItems Then
        Exit Function
    End If

    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.Lastindex
    
        With s.Order.Item(myIndex)
        
            If myS.LacksItem(.Item) Then
                myS.Add .Item
            End If
        
        End With
        
    Next

    Set Dedup = myS
            
End Function

'@Description("Removes duplicate items from the seq")
Public Function Deduped() As SeqT
Attribute Deduped.VB_Description = "Removes duplicate items from the seq"

    Set Deduped = Me
    
    If s.Order.Count <= 1 Then
        Exit Function
    End If
    
    Dim myS As SeqT: Set myS = SeqT.Deb
    
    Dim myIndex As Long
    For myIndex = Me.Lastindex To Me.FirstIndex Step -1
    
        With s.Order.Item(myIndex)
            If myS.LacksItem(.Item) Then
                myS.Add .Item
            Else
                RemoveAt .Item.Order
            End If
        End With
    Next
    
    Set Deduped = Me
    
End Function

Public Function Freq() As KvpA

    Dim myK As KvpA: Set myK = KvpA.Deb
    Set Freq = myK
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.Lastindex
    
        With s.Order.Item(myIndex)
            If myK.HoldsItem(.Item) Then
                myK.Item(.Item) = myK.Item(.Item) + 1
            Else
                myK.Add .Item, 1
            End If
        End With
         
    Next

    Set Freq = myK
    
End Function
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' Some set stuff
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C

Public Function SetOf(ByRef ipSet As e_SetoF, ByRef ipRange As Variant) As SeqT

    Select Case ipSet

        Case e_SetoF.m_Common:           Set SetOf = SetOfCommon(ipRange)
        Case e_SetoF.m_HostOnly:         Set SetOf = SetOfHostOnly(ipRange)
        Case e_SetoF.m_ParamOnly:        Set SetOf = SetOfParamOnly(ipRange)
        Case e_SetoF.m_NotCommon:        Set SetOf = SetOfNotCommon(ipRange)
        Case e_SetoF.m_Unique:           Set SetOf = SetofUnique(ipRange)
        Case Else
            Err.Raise 17 + vbObjectError, _
            "VBALib.SeqL.SetOf", _
            Fmt.Text("Invalid e_set member. Expecting {0} to {1}. Got {2}", e_SetoF.m_First, e_SetoF.m_Last, ipSet)

    End Select

End Function



'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' Private methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
Private Function SetOfCommon(ByRef ipRange As Variant) As SeqT

    Dim myS As SeqT: Set myS = SeqT.Deb
    Set SetOfCommon = myS
    
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If Me.LacksItems Or myItems.LacksItems Then
        Exit Function
    End If

    Do
        If myS.HoldsItem(myItems.CurItem(0)) Then
            myS.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext

    Set SetOfCommon = myS

End Function


Private Function SetOfHostOnly(ByRef ipRange As Variant) As SeqT

    Dim myS As SeqT: Set myS = SeqT.Deb
    Set SetOfHostOnly = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    If myItems.LacksItems Then
        Exit Function
    End If
        
    Do
    
        If myS.HoldsItem(myItems.CurItem(0)) Then
            myS.RemoveAll myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetOfHostOnly = myS
    
End Function


Private Function SetOfParamOnly(ByRef ipRange As Variant) As SeqT

    Dim myS As SeqT: Set myS = SeqT.Deb
    Set SetOfParamOnly = myS
    
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If myItems.LacksItems Then
        Exit Function
    End If
    
    Do
    
        If myS.LacksItem(myItems.CurItem(0)) Then
            myS.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetOfParamOnly = myS
    
End Function


Private Function SetOfNotCommon(ByRef ipRange As Variant) As SeqT

    
    Set SetOfNotCommon = SeqT.Deb
    
    Dim mySR As SeqT: Set mySR = SeqT(ipRange).Dedup
    Dim mySL As SeqT: Set mySL = Me.Dedup
    
    If mySL.LacksItems And mySR.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = mySL.FirstIndex To mySL.Lastindex
    
        If mySR.LacksItem(mySL.Item(myIndex)) Then
            mySR.Add mySL.Item(myIndex)
        Else
            mySR.Remove mySL.Item(myIndex)
        End If
        
    Next
    
    Set SetOfNotCommon = mySR

End Function


Private Function SetofUnique(ByRef ipRange As Variant) As SeqT

    Dim myS As SeqT: Set myS = SeqT.Deb
    Set SetofUnique = myS
    
    Dim myItems As IterItems: Set myItems = IterItems(ipRange)
    
    If Me.LacksItems And myItems.LacksItems Then
        Exit Function
    End If
    
    Set myS = Me.Dedup
    
    Do
    
        If myS.LacksItem(myItems.CurItem(0)) Then
            myS.Add myItems.CurItem(0)
        End If
        
    Loop While myItems.MoveNext
    
    Set SetofUnique = myS

End Function

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
' An attempt as  providing some 'lambda' functionality - see IMapper and mp/cmp/rd classes
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========C
'@Description("Mutates the Seq in place by applying the function in IMapper to each item")
Public Function MappedIt(ByRef ipMapper As IMapper) As SeqT
Attribute MappedIt.VB_Description = "Mutates the Seq in place by applying the function in IMapper to each item"
    'Mapped it works by reference but we allow a function return to enable fluid use of Mappedit
    
    Set MappedIt = Me
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.Lastindex
        ' execmapper returns a single value array
        Dim myA() As Variant: myA = ipMapper.ExecMapper(s.Order.Item(myIndex).Item)
        
        ' Use me.Item as we have to add and remove for collection
        If VBA.IsObject(myA(0)) Then
            Set s.Order.Item(myIndex).Item = myA(0)
        Else
            s.Order.Item(myIndex).Item = myA(0)
        End If
        
    Next
    
End Function


'@Description("Returns a new Seq where each item in the Host has been mutated by the function provided by IMapper")
Public Function MapIt(ByRef ipMapper As IMapper) As SeqT
Attribute MapIt.VB_Description = "Returns a new Seq where each item in the Host has been mutated by the function provided by IMapper"

    Dim myS As SeqT: Set myS = SeqT.Deb
    Set MapIt = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Order)
    Do
        myS.Add ipMapper.ExecMapper(myItems.CurItem(0).Item)(0)
    Loop While myItems.MoveNext
    
    Set MapIt = myS

End Function




'@Description("Returns a new Seq where each item returns true from the IComparer")
Public Function FilterIt(ByVal ipComparer As IComparer) As SeqT
Attribute FilterIt.VB_Description = "Returns a new Seq where each item returns true from the IComparer"

    Dim myS As SeqT: Set myS = SeqT.Deb
    Set FilterIt = myS
    
    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItems As IterItems: Set myItems = IterItems(s.Order)
    Do
    
        If ipComparer.ExecCmp(myItems.CurItem(0).Item) Then
            myS.Add myItems.CurItem(0)
        End If
    
    Loop While myItems.MoveNext
    
      Set FilterIt = myS

End Function


'@Description("Returns the count the number of items where IComparer returns true")
Public Function CountIt(ByVal ipComparer As IComparer) As Long
Attribute CountIt.VB_Description = "Returns the count the number of items where IComparer returns true"

    CountIt = LACKS_ITEMS
    
    If Me.LacksItems Then
        Exit Function
    End If
   
    Dim myCount As Long: myCount = 0
   
    Dim myItems As IterItems: Set myItems = IterItems(Me.ToArray)
    Do
    
        If ipComparer.ExecCmp(myItems.CurItem(0)) Then
            myCount = myCount + 1
        End If
        
    Loop While myItems.MoveNext
   
    CountIt = myCount
    
End Function


'@Description("Returns the single value computed by the IReducer").
Public Function ReduceIt(ByRef ipReducer As IReducer) As Variant

    ReduceIt = Null

    If Me.LacksItems Then
        Exit Function
    End If
    
    Dim myItem As Variant: myItem = Array(ipReducer.ExecReduction(Me.ToArray))
   
    If VBA.IsObject(myItem(0)) Then
        Set ReduceIt = myItem(0)
    Else
        ReduceIt = myItem(0)
    End If
   
End Function
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Private methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'@Description("Returns the node that was rotated to root position.")
'@Ignore AssignedByValParameter
Private Function InsertNode(ByVal ipCurnode As SeqTNode, ByVal ipNewNode As SeqTNode) As SeqTNode
Attribute InsertNode.VB_Description = "Returns the node that was rotated to root position."
    'Debug.Print "InsertNode",
    If IsNothing(ipCurnode) Then
        'Debug.Print "ipCurNode is nothing, setting to newnode", ipNewNode.Item
        Set InsertNode = ipNewNode
        Exit Function
    End If
    'Debug.Print ipNewNode.Item

    Select Case True
        Case Comparers.LTEQ(ipNewNode.Item, ipCurnode.Item)
            'Debug.Print "NewNode is <= than CurNode", ipNewNode.Item, ipCurnode.Item
            'Debug.Print "Setting left child  to ", ipNewNode.Item
            Set ipCurnode.Left = InsertNode(ipCurnode.Left, ipNewNode)
            If ipCurnode.Left.Priority > ipCurnode.Priority Then
                'Debug.Print "Left priority > parent", ipCurnode.Left.Priority, ipCurnode.Priority
                'Debug.Print "Rotating root to right child"
                Set ipCurnode = RotateRootToRightChild(ipCurnode)
            End If
                
        
        Case Else
            'Debug.Print "NewNode is > than CurNode", ipNewNode.Item, ipCurnode.Item
            'Debug.Print "Setting right child to to ", ipNewNode.Item
            Set ipCurnode.Right = InsertNode(ipCurnode.Right, ipNewNode)
            If ipCurnode.Right.Priority > ipCurnode.Priority Then
                'Debug.Print "Right priority > parent", ipCurnode.Right.Priority, ipCurnode.Priority
                'Debug.Print "Rotating root to leftt child"
                Set ipCurnode = RotateRootToLeftChild(ipCurnode)
            End If
            
    End Select
    
    Set InsertNode = ipCurnode
    
End Function

'@Description("Returns the first node with a matching Item or nothing")
Private Function GetNodeOf(ByVal ipNode As SeqTNode, ByRef ipItem As Variant) As SeqTNode
Attribute GetNodeOf.VB_Description = "Returns the first node with a matching Item or nothing"

    If IsNothing(ipNode) Then
        Set GetNodeOf = ipNode
        Exit Function
    End If
    
    If Comparers.EQ(ipNode.Item, ipItem) Then
        Set GetNodeOf = ipNode
        Exit Function
    End If
    
    If Comparers.LT(ipNode.Item, ipItem) Then
        Set GetNodeOf = GetNodeOf(ipNode.Right, ipItem)
        Exit Function
    End If
    
    Set GetNodeOf = GetNodeOf(ipNode.Left, ipItem)
        
End Function



'@Description("Returns the node at the specified index or -1 (where index is the order of addition of the item)"
Private Function GetPriority() As Variant
    ' can this be simplified
        GetPriority = VBA.CVar(VBA.CLng(VBA.Rnd(1) * (Globals.maxLong - 1)))
End Function



'@Ignore AssignedByValParameter
Private Function DeleteNode(ByVal ipRoot As SeqTNode, ByVal ipItem As Variant) As SeqTNode
' NB Root does not refer to s.Root, rather, it is the first node in the current substree
' 1) If node is a leaf, delete it.
' 2) If node has one child NULL and other as non-NULL, replace node with the non-empty child.
' 3) If node has both children as non-NULL, find max of left and right children.
'  a) If priority of right child is greater, perform left rotation at node
'  b) If priority of left child is greater, perform right rotation at node.
'The idea of step 3 is to move the node to down so that we end up with either case 1 or case 2.

    Dim myTmp As SeqTNode
    
    If IsNothing(ipRoot) Then
        ''Debug.Print "Root is nothing found"
        Set DeleteNode = ipRoot
        Exit Function
    End If
            
    If Comparers.LT(ipItem, ipRoot.Item) Then
        'If IsNothing(ipRoot.Left) Then 'Debug.Print "Moving left from", ipRoot.Item, " to nothing"
        'Debug.Print "Moving left from ", ipRoot.Item, " to ", ipRoot.Left.Item
        Set ipRoot.Left = DeleteNode(ipRoot.Left, ipItem)
            
    ElseIf Comparers.MT(ipItem, ipRoot.Item) Then
        'If IsNothing(ipRoot.Right) Then 'Debug.Print "Moving right from ", ipRoot.Item, " to nothing"
        'Debug.Print "Moving right from ", ipRoot.Item, " to ", ipRoot.Right.Item
        Set ipRoot.Right = DeleteNode(ipRoot.Right, ipItem)
            
    ' to get to this point ipcurnode.item == item
    ' why does there not appear to be code that actually deletes a leaf.
    ElseIf IsNothing(ipRoot.Left) And IsNothing(ipRoot.Right) Then
        
        'Set ipRoot = s.Order.Item(ipIndex)
        'Debug.Print "No Children, Deleting", ipRoot.Item
        s.Result = ipRoot.Order
        s.Order.Item(s.Result) = Nothing
        s.Order.RemoveAt VBA.CLng(s.Result)
        UpdateOrder VBA.CVar(s.Result)
        Set ipRoot = Nothing
        Set DeleteNode = ipRoot
        'Exit Function
        
    ElseIf IsNothing(ipRoot.Left) Then
        'Debug.Print "No Left Child, Deleting", ipRoot.Item
        Set myTmp = ipRoot.Right
        s.Result = ipRoot.Order
        s.Order.Item(s.Result) = Nothing
        s.Order.RemoveAt VBA.CLng(s.Result)
        UpdateOrder VBA.CVar(s.Result)
        Set ipRoot = Nothing
        Set ipRoot = myTmp
        'Set DeleteNode = myTmp
        'Exit Function
        
    ElseIf IsNothing(ipRoot.Right) Then
        'Debug.Print "No Right Child, Deleting", ipRoot.Item
        Set myTmp = ipRoot.Left
        s.Result = ipRoot.Order
        s.Order.Item(s.Result) = Nothing
        s.Order.RemoveAt VBA.CLng(s.Result)
        UpdateOrder VBA.CVar(s.Result)
        Set ipRoot = Nothing
        Set ipRoot = myTmp
        'Set DeleteNode = myTmp
        'Exit Function
        
    ElseIf ipRoot.Left.Priority < ipRoot.Right.Priority Then
        ''Debug.Print "Rotate Left"
        Set ipRoot = RotateRootToLeftChild(ipRoot)
        Set ipRoot.Left = DeleteNode(ipRoot.Left, ipItem)
    
    Else
        ''Debug.Print "RotateRight"
    
        Set ipRoot = RotateRootToRightChild(ipRoot)
        Set ipRoot.Right = DeleteNode(ipRoot.Right, ipItem)
    
    End If
        
  

    Set DeleteNode = ipRoot
    
End Function




'@Ignore AssignedByValParameter
Private Function DeleteNodeAt(ByVal ipRoot As SeqTNode, ByRef ipItem As Variant, ByRef ipIndex As Long) As SeqTNode  ' , ByVal ipItemNode As SeqTNode

' 1) If node is a leaf, delete it.
' 2) If node has one child NULL and other as non-NULL, replace node with the non-empty child.
' 3) If node has both children as non-NULL, find max of left and right children.
'  a) If priority of right child is greater, perform left rotation at node
'  b) If priority of left child is greater, perform right rotation at node.
'The idea of step 3 is to move the node to down so that we end up with either case 1 or case 2.
    Dim myTmp As SeqTNode

    If IsNothing(ipRoot) Then
        'Debug.Print "Sub tree Root is nothing"
        Set DeleteNodeAt = ipRoot
        Exit Function
    End If

    If Comparers.LT(ipItem, ipRoot.Item) Then
       ' If IsNothing(ipRoot.Left) Then 'Debug.Print "Moving left from", ipRoot.Item, " to nothing"
        'Debug.Print "Moving left from ", ipRoot.Item, " to ", ipRoot.Left.Item
        Set ipRoot.Left = DeleteNodeAt(ipRoot.Left, ipItem, ipIndex)

    ElseIf Comparers.MT(ipItem, ipRoot.Item) Then
       ' If IsNothing(ipRoot.Right) Then 'Debug.Print "Moving right from ", ipRoot.Item, " to nothing"
        'Debug.Print "Moving right from ", ipRoot.Item, " to ", ipRoot.Right.Item
        Set ipRoot.Right = DeleteNodeAt(ipRoot.Right, ipItem, ipIndex)

    ' to get to this point ipcurnode.item == item
    ' why does there not appear to be code that actually deletes a leaf.
    ElseIf Comparers.EQ(ipRoot.Item, ipItem) And ipRoot.Order <> ipIndex Then
            'Debug.Print "Items match", ipRoot.Item, ipItem
            'Debug.Print "Index mismatch", ipRoot.Order, ipIndex

'            If IsNothing(ipRoot.Left) And IsNothing(ipRoot.Right) And (ipRoot.Order = ipIndex) Then
'
'                Set ipRoot = s.Order.Item(ipIndex)
'                'Debug.Print "EqualItems: Equal Order: Deleting when both children exist", ipRoot.Item
'                s.Result = ipIndex
'                s.Order.Item(s.Result) = Nothing
'                s.Order.RemoveAt VBA.CLng(s.Result)
'                UpdateOrder VBA.CVar(s.Result)
'                Set ipRoot = Nothing
''                Set DeleteNodeAt = ipRoot
''                Exit Function

            If IsNotNothing(ipRoot.Left) Then
                If Comparers.EQ(ipRoot.Left.Item, ipItem) Then
                    'Debug.Print "Equal Items: FindingIndex: Moving Left from ", ipRoot.Item, " to ", ipRoot.Left.Item
                    Set ipRoot = DeleteNodeAt(ipRoot.Left, ipItem, ipIndex)

                End If

            ElseIf IsNotNothing(ipRoot.Right) Then
                If Comparers.EQ(ipRoot.Right.Item, ipItem) Then
                    'Debug.Print "Equal items: Finding Index: Moving right from ", ipRoot.Item, " to ", ipRoot.Right.Item
                    Set ipRoot = DeleteNodeAt(ipRoot.Right, ipItem, ipIndex)
                End If


            ElseIf Comparers.EQ(ipRoot.Left.Item, ipRoot.Item) And (ipRoot.Left.Priority <= ipRoot.Right.Priority) Then
                'Debug.Print "Equal Items: FInding Index: rotating left based on priority"
                Set ipRoot = RotateRootToLeftChild(ipRoot)
                Set ipRoot.Left = DeleteNodeAt(ipRoot.Left, ipItem, ipIndex)

            ElseIf Comparers.EQ(ipRoot.Right.Item, ipRoot.Item) And (ipRoot.Left.Priority > ipRoot.Right.Priority) Then
                'Debug.Print "Equal Items: FInding Index: rotating right based on priority"
                Set ipRoot = RotateRootToRightChild(ipRoot)
                Set ipRoot.Right = DeleteNodeAt(ipRoot.Right, ipItem, ipIndex)

'            Else
'
'                Debug.Print "oops in mismatched indexes branch"
'                Stop
            End If

            Exit Function

'            If Comparers.EQ(ipRoot.Left.Item, ipItem) Then
'                If IsNothing(ipRoot.Left) Then 'Debug.Print "Equal Items: Moving Left from ", ipRoot.Item, " to nothing"
'                'Debug.Print "Equal Items: Moving Left from ", ipRoot.Item, " to ", ipRoot.Left.Item
'                Set ipRoot = DeleteNodeAt(ipRoot.Left, ipItem, ipIndex)
'
'            ElseIf Comparers.EQ(ipRoot.Right.Item, ipItem) Then
'                If IsNothing(ipRoot.LRight) Then 'Debug.Print "Moving Left from ", ipRoot.Item, " to nothing"
'                'Debug.Print "Moving right from ", ipRoot.Item, " to ", ipRoot.Right.Item
'                Set ipRoot = DeleteNodeAt(ipRoot.Left, ipItem, ipIndex)
'            End If



        ElseIf IsNothing(ipRoot.Left) And IsNothing(ipRoot.Right) And (ipRoot.Order = ipIndex) Then

            Set ipRoot = s.Order.Item(ipIndex)
            'Debug.Print "Deleting when neither child exists", ipRoot.Item
            s.Result = ipIndex
            s.Order.Item(s.Result) = Nothing
            s.Order.RemoveAt VBA.CLng(s.Result)
            UpdateOrder VBA.CVar(s.Result)
            Set ipRoot = Nothing
            Set DeleteNodeAt = ipRoot
            Exit Function

        ElseIf IsNothing(ipRoot.Left) And ipRoot.Order = ipIndex Then
                Set ipRoot = s.Order.Item(ipIndex)
                'Debug.Print "Deleting when left child is nothing", ipRoot.Item
                Set myTmp = ipRoot.Right
                s.Result = ipIndex
                s.Order.Item(s.Result) = Nothing
                s.Order.RemoveAt VBA.CLng(s.Result)
                UpdateOrder VBA.CVar(s.Result)
                Set ipRoot = Nothing
                Set DeleteNodeAt = myTmp
                Exit Function

        ElseIf IsNothing(ipRoot.Right) And ipRoot.Order = ipIndex Then
            Set ipRoot = s.Order.Item(ipIndex)
            'Debug.Print "Deleting when right child is nothing", ipRoot.Item
            Set myTmp = ipRoot.Left
            s.Result = ipIndex
            s.Order.Item(ipIndex) = Nothing
            s.Order.RemoveAt VBA.CLng(ipIndex)
            UpdateOrder VBA.CVar(ipIndex)
            Set ipRoot = Nothing
            Set DeleteNodeAt = myTmp
            Exit Function

'        ElseIf Comparers.EQ(ipItem, ipRoot.Item) And (ipRoot.Left.Priority <= ipRoot.Right.Priority) Then
'
'            Set ipRoot = RotateRootToLeftChild(ipRoot)
'            Set ipRoot.Left = DeleteNodeAt(ipRoot.Left, ipItem, ipIndex)
'
'        ElseIf Comparers.EQ(ipItem, ipRoot.Item) And (ipRoot.Left.Priority > ipRoot.Right.Priority) Then
'
'
'            Set ipRoot = RotateRootToRightChild(ipRoot)
'            Set ipRoot.Right = DeleteNodeAt(ipRoot.Right, ipItem, ipIndex)


'        Else
'
'            'Debug.Print "Can't find Item/order combination", ipItem, ipIndex
'            Stop
        End If


    Set DeleteNodeAt = ipRoot

End Function


Private Function RotateRootToRightChild(ByVal y As SeqTNode) As SeqTNode
    'Debug.Print "Rotating Right: root is", y.Item, " left child is ", y.Left.Item
    ' Formerly RightRotate
    Dim x As SeqTNode: Set x = y.Left
    Dim myTmp As SeqTNode: Set myTmp = x.Right
     
    ' Perform rotation
    Set x.Right = y
    Set y.Left = myTmp
     
    ' Return new root
   ' Dim myRight As Long: If IsNothing(x.Right) Then myRight = 0 Else myRight = x.Right.Item
    'Debug.Print "After rotation: root is ", x.Item, " right child is"; myRight
    Set RotateRootToRightChild = x
End Function

Private Function RotateRootToLeftChild(ByVal x As SeqTNode) As SeqTNode
' Formerly leftrotate
'Debug.Print "Rotating Left: root  is", x.Item, " right child is ", x.Right.Item
    
    Dim y As SeqTNode: Set y = x.Right
    Dim myTmp As SeqTNode: Set myTmp = y.Left
     
    ' Perform rotation
    Set y.Left = x
    Set x.Right = myTmp
     
    ' Return new root
    'Dim myLeft As variant: If IsNothing(y.Left) Then myLeft = 0 Else myLeft = y.Left.Item
    'Debug.Print "After rotation: root is ", y.Item, " left child is "; myLeft
    Set RotateRootToLeftChild = y
    
End Function


Public Sub PrintByOrder()

    Debug.Print "Root is ", s.Root.Item
    inorder s.Root
    
End Sub
Private Sub inorder(ByVal ipNode As SeqTNode)

    If IsNotNothing(ipNode) Then
      
        inorder ipNode.Left
        Debug.Print "key:", ipNode.Item, "| priority:", ipNode.Priority, " ",
        If IsNotNothing(ipNode.Left) Then
            Debug.Print " | left child:", ipNode.Left.Item,
        End If
        
        If IsNotNothing(ipNode.Right) Then
            Debug.Print " | right child:", ipNode.Right.Item, " ",
        End If
        
        Debug.Print
        inorder ipNode.Right
        
    End If
    
End Sub

Public Sub PrintByColl()
    Debug.Print "Root is ", s.Root.Item
    Dim myIndex As Long
    For myIndex = Me.FirstIndex To Me.Lastindex
        Dim myNode As SeqTNode: Set myNode = s.Order.Item(myIndex)
        Debug.Print "key:", myNode.Item, "| priority:", myNode.Priority, " ",
        If IsNotNothing(myNode.Left) Then
            Debug.Print " | left child:", myNode.Left.Item,
        End If
        
        If IsNotNothing(myNode.Right) Then
            Debug.Print " | right child:", myNode.Right.Item, " ",
        End If
        
        Debug.Print
    Next
    
End Sub

Private Function NotFound(ByRef ipItem As Variant) As Boolean

    If VBA.IsObject(ipItem) Then
        NotFound = ipItem Is Nothing
    ElseIf GroupInfo.IsNumber(ipItem) Then
        NotFound = ipItem = NOT_FOUND
    Else
        NotFound = VBA.IsEmpty(ipItem)
    End If
         
End Function

Private Function Countof(ByRef ipItem As Variant, ByVal ipNode As SeqTNode) As Long

    Dim myCount As Long: myCount = 0
    
    If ipNode Is Nothing Then
        Exit Function
    End If
    
    
    myCount = myCount + Countof(ipItem, ipNode.Left)
    myCount = myCount + Countof(ipItem, ipNode.Right)
    
    If Comparers.EQ(ipItem, ipNode.Item) Then
        myCount = myCount + 1
    End If
    
   Countof = myCount
   
End Function

Private Sub UpdateOrder(ByRef ipIndex As Long)

    Dim myIndex As Long
    For myIndex = ipIndex To s.Order.Lastindex
        Dim myNode As SeqTNode: Set myNode = s.Order.Item(myIndex)
        myNode.Order = myIndex
    Next
    
End Sub

Private Sub SeqInOrder(ByVal ipNode As SeqTNode, ByRef opS As SeqT)

    If IsNothing(ipNode) Then
        Exit Sub
    End If
    ' Remember in a treap everything to the left is < current node
    ' everything to the right is > current node
    ' hence the order of searching below
    SeqInOrder ipNode.Left, opS
    opS.Add ipNode.Item
    SeqInOrder ipNode.Right, opS
        
End Sub

'@Ignore ProcedureCanBeWrittenAsFunction
Private Sub RemoveAllItems(ByRef ipNode As SeqTNode)

    If IsNothing(ipNode) Then
        Exit Sub
    End If
    RemoveAllItems ipNode.Left
    RemoveAllItems ipNode.Right
    Set ipNode = Nothing
    
End Sub


Private Sub RemoveAllSingleItem(ByRef ipItem As Variant)

    Do While Me.HoldsItem(ipItem)
        Remove ipItem
    Loop
  
End Sub
